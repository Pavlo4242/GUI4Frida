 
--- File: D:\ANDROID\FridaGUI\src\main.py --- 
import sys
import os
from pathlib import Path

def setup_qt_environment():
    """Setup Qt environment variables and paths"""
    try:
        # Get the PyQt5 location
        import PyQt5
        pyqt_path = Path(PyQt5.__file__).parent
        
        # Set environment variables
        os.environ['QT_DEBUG_PLUGINS'] = '1'
        os.environ['QT_QPA_PLATFORM_PLUGIN_PATH'] = str(pyqt_path / 'Qt5' / 'plugins')
        
        # Print debug info
        print(f"PyQt5 path: {pyqt_path}")
        print(f"Plugin path: {os.environ['QT_QPA_PLATFORM_PLUGIN_PATH']}")
        
        # Verify plugin exists
        cocoa_path = pyqt_path / 'Qt5' / 'plugins' / 'platforms' / 'libqcocoa.dylib'
        if cocoa_path.exists():
            print(f"Found cocoa plugin at: {cocoa_path}")
        else:
            print(f"Warning: Could not find cocoa plugin at: {cocoa_path}")
            
            # Try alternate locations
            alt_paths = [
                pyqt_path / 'Qt' / 'plugins' / 'platforms' / 'libqcocoa.dylib',
                Path('/opt/anaconda3/plugins/platforms/libqcocoa.dylib'),
                Path('/opt/anaconda3/lib/python3.11/site-packages/PyQt5/Qt/plugins/platforms/libqcocoa.dylib')
            ]
            
            for path in alt_paths:
                if path.exists():
                    print(f"Found cocoa plugin in alternate location: {path}")
                    os.environ['QT_QPA_PLATFORM_PLUGIN_PATH'] = str(path.parent.parent)
                    break
            
    except Exception as e:
        print(f"Error setting up Qt environment: {e}")

# Add project root to Python path
project_root = Path(__file__).parent
sys.path.append(str(project_root))

# Setup Qt environment before importing PyQt
setup_qt_environment()

from PyQt5.QtWidgets import QApplication, QMessageBox
from gui.main_window import FridaInjectorMainWindow
from utils.themes import set_application_style

def main():
    try:
        # Create application
        app = QApplication(sys.argv)
        set_application_style(app)
        
        window = FridaInjectorMainWindow()
        window.show()
        
        sys.exit(app.exec_())
    except Exception as e:
        print(f"Error starting application: {e}")
        QMessageBox.critical(None, "Error", f"Application failed to start: {str(e)}")
        sys.exit(1)

if __name__ == '__main__':
    main()  
--- File: D:\ANDROID\FridaGUI\src\core\android_helper.py --- 
import subprocess
import os
import time
import requests
import platform

class AndroidHelper:
    FRIDA_SERVER_URL = "https://github.com/frida/frida/releases/download/16.1.4/frida-server-16.1.4-android-arm64.xz"
    
    @staticmethod
    def get_adb_path():
        """Get the ADB executable path"""
        if platform.system() == "Windows":
            return "adb.exe"
        return "adb"
        
    @staticmethod
    def is_device_connected(device_id):
        """Check if device is connected"""
        try:
            output = subprocess.check_output([AndroidHelper.get_adb_path(), 'devices'], text=True)
            return device_id in output
        except:
            return False
            
    @staticmethod
    def get_device_arch(device_id):
        """Get device architecture"""
        try:
            output = subprocess.check_output([
                AndroidHelper.get_adb_path(), '-s', device_id, 'shell', 'getprop ro.product.cpu.abi'
            ], text=True).strip()
            
            if 'arm64' in output:
                return 'arm64'
            elif 'arm' in output:
                return 'arm'
            elif 'x86_64' in output:
                return 'x86_64'
            elif 'x86' in output:
                return 'x86'
            return 'arm64'  # Default to arm64
        except:
            return 'arm64'

    @staticmethod
    def start_frida_server(device_id):
        """Start frida-server on device"""
        try:
            adb = AndroidHelper.get_adb_path()
            
            # Get device architecture
            arch = AndroidHelper.get_device_arch(device_id)
            #server_url = f"https://github.com/frida/frida/releases/download/16.1.4/frida-server-16.1.4-android-{arch}.xz"
            server_url = f"https://github.com/frida/frida/releases/download/15.2.2/frida-server-15.2.2-android-{arch}.xz"
            
            # First, try to get root access
            print(f"[ADB] Attempting to gain root access on device {device_id}")
            subprocess.run([adb, '-s', device_id, 'root'], check=True, capture_output=True, text=True)
            time.sleep(1)  # Wait for root to take effect
            
            # Remount system as read-write
            print(f"[ADB] Remounting system as read-write on device {device_id}")
            subprocess.run([adb, '-s', device_id, 'remount'], check=True, capture_output=True, text=True)
            
            # Download and push frida-server (always get fresh copy)
            print(f"Downloading frida-server for {arch}...")
            response = requests.get(server_url, stream=True)
            response.raise_for_status()  # Raise HTTPError for bad responses (4xx or 5xx)
            server_path = os.path.join(os.path.expanduser('~'), '.frida_gui', f'frida-server-{arch}')
            
            # Create directory if it doesn't exist
            os.makedirs(os.path.dirname(server_path), exist_ok=True)
            
            # Save and extract
            with open(server_path + '.xz', 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            
            try:
                print(f"Extracting frida-server archive...")
                subprocess.run(['xz', '-d', '-f', server_path + '.xz'], check=True, capture_output=True, text=True)  # Force extraction
            except subprocess.CalledProcessError as e:
                print(f"Error extracting with xz: {e}. Trying alternative method...")
                import lzma
                try:
                    with lzma.open(server_path + '.xz') as f:
                        with open(server_path, 'wb') as out:
                            out.write(f.read())
                    print("Successfully extracted using lzma.")
                except Exception as e2:
                    print(f"Error extracting with lzma: {e2}.  Failed to extract frida-server.")
                    return False
            
            # Push to device
            print("Pushing frida-server to device...")
            subprocess.run([
                adb, '-s', device_id, 'push',
                server_path, '/data/local/tmp/frida-server'
            ], check=True, capture_output=True, text=True)
            
            # Kill any existing frida-server processes
            print("Killing existing frida-server processes...")
            kill_commands = [
                'pkill -f frida-server',
                'killall -9 frida-server',
                'kill $(pidof frida-server)',
            ]
            
            for cmd in kill_commands:
                try:
                    subprocess.run([adb, '-s', device_id, 'shell', cmd], check=False, capture_output=True, text=True)
                except Exception as e:
                    print(f"Error killing frida-server with command '{cmd}': {e}")
            
            # Set permissions and start server
            start_commands = [
                'chmod 755 /data/local/tmp/frida-server',
                'su -c "chmod 755 /data/local/tmp/frida-server"',
                'su -c "setenforce 0"',
                'su -c "/data/local/tmp/frida-server -D"',  # Run in daemon mode
                '/data/local/tmp/frida-server -D'  # Fallback without su
            ]
            
            for cmd in start_commands:
                try:
                    print(f"Executing command: {cmd}")
                    subprocess.run([adb, '-s', device_id, 'shell', cmd], check=False, capture_output=True, text=True, timeout=5)
                    time.sleep(1)
                    if AndroidHelper.is_frida_running(device_id):
                        print("Frida server started successfully")
                        return True
                except subprocess.TimeoutExpired:
                    print("Timeout while starting frida-server.  Server may be running.")
                    if AndroidHelper.is_frida_running(device_id):
                        print("Frida server started successfully")
                        return True
                except Exception as e:
                    print(f"Error starting frida-server with command '{cmd}': {e}")
                    continue
            
            print("Failed to start frida-server")
            return False
            
        except requests.exceptions.RequestException as e:
            print(f"Error downloading frida-server: {e}")
            return False
        except subprocess.CalledProcessError as e:
            print(f"ADB error: {e.stderr}")
            return False
        except Exception as e:
            print(f"Error starting frida-server: {e}")
            return False

    @staticmethod
    def is_frida_running(device_id):
        """Check if frida-server is running on device"""
        try:
            # Try different ps commands as they vary by Android version
            commands = [
                'ps -A | grep frida-server',
                'ps -ef | grep frida-server',
                'ps | grep frida-server',
                'top -n 1 | grep frida-server',
                'pidof frida-server'
            ]
            
            for cmd in commands:
                try:
                    output = subprocess.check_output(
                        [AndroidHelper.get_adb_path(), '-s', device_id, 'shell', cmd],
                        text=True,
                        stderr=subprocess.PIPE,
                        timeout=2
                    )
                    if ('frida-server' in output and 'grep' not in output) or output.strip().isdigit():
                        return True
                except:
                    continue
            
            # Try netstat as last resort
            try:
                output = subprocess.check_output(
                    [AndroidHelper.get_adb_path(), '-s', device_id, 'shell', 'netstat -tlnp'],
                    text=True,
                    stderr=subprocess.PIPE,
                    timeout=2
                )
                if ':27042' in output:  # Default frida port
                    return True
            except:
                pass
                
            return False
        except:
            return False  
--- File: D:\ANDROID\FridaGUI\src\core\history_manager.py --- 
from datetime import datetime
import json
import os
from collections import deque
import weakref

class HistoryManager:
    def __init__(self):
        self.history_file = os.path.join(os.path.expanduser('~'), '.frida_gui', 'history.json')
        self._history = deque(maxlen=1000)  # Limit history size
        self.load_history()
        
    def load_history(self):
        try:
            if os.path.exists(self.history_file):
                with open(self.history_file, 'r') as f:
                    # Load directly into deque with max size
                    data = json.load(f)
                    self._history.extend(data[-1000:])  # Only keep last 1000 entries
        except Exception as e:
            print(f"Error loading history: {e}")
            
    def save_history(self):
        try:
            os.makedirs(os.path.dirname(self.history_file), exist_ok=True)
            with open(self.history_file, 'w') as f:
                # Convert deque to list for JSON serialization
                json.dump(list(self._history), f, indent=2)
        except Exception as e:
            print(f"Error saving history: {e}")
            
    def add_entry(self, action_type, details):
        entry = {
            'timestamp': datetime.now().isoformat(),
            'type': action_type,
            'details': details
        }
        self._history.appendleft(entry)  # Use deque's appendleft
        
        # Periodically save to prevent memory buildup
        if len(self._history) % 10 == 0:  # Save every 10 entries
            self.save_history()
            
    def clear_history(self):
        self._history.clear()
        self.save_history()
        
    @property
    def history(self):
        return list(self._history)  # Return a copy to prevent memory leaks
        
    def __del__(self):
        self.save_history() 
--- File: D:\ANDROID\FridaGUI\src\core\process_monitor.py --- 
from PyQt5.QtCore import QObject, pyqtSignal, QTimer
#import psutil
import frida
import weakref

class ProcessMonitor(QObject):
    process_started = pyqtSignal(str, int)  # name, pid
    process_ended = pyqtSignal(str, int)    # name, pid
    # Removed memory_updated signal as psutil is removed
    # memory_updated = pyqtSignal(str, float) # pid, memory_usage
    
    def __init__(self, refresh_rate=2000):
        super().__init__()
        self.refresh_rate = refresh_rate
        self.monitored_processes = {}
        self.timer = QTimer()
        self.timer.timeout.connect(self.check_processes)
        self._stopped = False
        self.device_id = None # Added: Store the ID of the device to monitor
        
    def set_device(self, device_id):
        """Sets the device ID to monitor and resets state."""
        self.device_id = device_id
        # Clear monitored processes when device changes
        self.monitored_processes.clear()
        # Optionally, trigger an immediate check
        self.check_processes()

    def start_monitoring(self):
        self._stopped = False
        # Only start the timer if a device is set, or adjust logic as needed
        if self.device_id:
            self.timer.start(self.refresh_rate)

    def stop_monitoring(self):
        self._stopped = True
        self.timer.stop()
        self.monitored_processes.clear()  # Clear the dictionary
        self.device_id = None # Reset device ID on stop

    
    
    def check_processes(self):
        if self._stopped or not self.device_id: # Modified: Don't run if stopped or no device ID
            return

        current_processes = {}

        try:
            # Modified: Get the specific device using the stored ID
            device = frida.get_device(self.device_id)

            # Ensure the device is still available (e.g., USB connected)
            # Simple check by trying to enumerate processes
            processes = device.enumerate_processes()

            for process in processes:
                if self._stopped:
                    return

                # Only include processes with a valid PID and name
                if process.pid > 0 and process.name:
                    current_processes[process.pid] = process.name

                    # New process detected
                    if process.pid not in self.monitored_processes:
                        self.process_started.emit(process.name, process.pid)

                # Removed memory usage update via psutil, as it's not applicable directly to remote devices
                # try:
                #     p = psutil.Process(process.pid)
                #     memory_mb = p.memory_info().rss / 1024 / 1024
                #     self.memory_updated.emit(str(process.pid), memory_mb)
                # except (psutil.NoSuchProcess, psutil.AccessDenied):
                #     continue

            # Check for ended processes
            ended_pids = list(self.monitored_processes.keys() - current_processes.keys())
            for pid in ended_pids:
                name = self.monitored_processes.get(pid, "Unknown") # Get name safely
                self.process_ended.emit(name, pid)

            self.monitored_processes = current_processes

        except frida.ServerNotRunningError:
             print(f"Frida server not running on device {self.device_id}. Stopping monitor for this device.")
             # Handle case where server stops - maybe emit a signal?
             self.stop_monitoring() # Stop timer if server isn't running
        except frida.TransportError as e:
             print(f"Transport error with device {self.device_id}: {e}. Stopping monitor.")
             # Handle case where device disconnects
             self.stop_monitoring() # Stop timer if device disconnects
        except Exception as e:
            print(f"Error monitoring processes on device {self.device_id}: {str(e)}")
            # Consider stopping or pausing timer on repeated errors

    def __del__(self):
        self.stop_monitoring() 
--- File: D:\ANDROID\FridaGUI\src\core\script_history.py --- 
import json
import os
from datetime import datetime

class ScriptHistory:
    def __init__(self):
        self.base_dir = os.path.join(os.path.expanduser('~'), '.frida_gui')
        self.history_file = os.path.join(self.base_dir, 'script_history.json')
        self.favorites_file = os.path.join(self.base_dir, 'favorites.json')
        self.ensure_dirs()
        self.load_history()
        
    def ensure_dirs(self):
        os.makedirs(self.base_dir, exist_ok=True)
        
    def load_history(self):
        try:
            if os.path.exists(self.history_file):
                with open(self.history_file, 'r') as f:
                    self.history = json.load(f)
            else:
                self.history = {
                    'local': [],
                    'codeshare': [],
                    'favorites': []
                }
        except Exception as e:
            print(f"Error loading history: {e}")
            self.history = {'local': [], 'codeshare': [], 'favorites': []}
            
    def save_history(self):
        try:
            with open(self.history_file, 'w') as f:
                json.dump(self.history, f, indent=2)
        except Exception as e:
            print(f"Error saving history: {e}")
            
    def add_to_history(self, script_type, script_info):
        """Add script to history with timestamp"""
        entry = {
            'timestamp': datetime.now().isoformat(),
            'info': script_info
        }
        
        # Keep only last 50 entries
        self.history[script_type] = ([entry] + 
                                   [x for x in self.history[script_type] 
                                    if x['info'].get('id') != script_info.get('id')])[:50]
        self.save_history()
        
    def add_to_favorites(self, script_info):
        """Add script to favorites"""
        if script_info not in self.history['favorites']:
            self.history['favorites'].append(script_info)
            self.save_history()
            
    def remove_from_favorites(self, script_id):
        """Remove script from favorites"""
        self.history['favorites'] = [
            x for x in self.history['favorites'] 
            if x.get('id') != script_id
        ]
        self.save_history()
        
    def get_recent_scripts(self, script_type, limit=10):
        """Get recent scripts of specified type"""
        return self.history[script_type][:limit]
        
    def get_favorites(self):
        """Get all favorite scripts"""
        return self.history['favorites']
        
    def is_favorite(self, script_id):
        """Check if script is in favorites"""
        return any(x.get('id') == script_id 
                  for x in self.history['favorites'])  
--- File: D:\ANDROID\FridaGUI\src\core\script_manager.py --- 
from PyQt5.QtCore import QObject, pyqtSignal
from pygments import highlight
from pygments.lexers import JavascriptLexer
from pygments.formatters import HtmlFormatter
from cryptography.fernet import Fernet
import json
import os

class ScriptManager(QObject):
    script_loaded = pyqtSignal(str, str)  # name, content
    script_saved = pyqtSignal(str)  # name
    
    def __init__(self):
        super().__init__()
        self.scripts_dir = os.path.join(os.path.expanduser('~'), '.frida_gui', 'scripts')
        self.key = Fernet.generate_key()
        self.cipher_suite = Fernet(self.key)
        self._ensure_dirs()
        
    def _ensure_dirs(self):
        os.makedirs(self.scripts_dir, exist_ok=True)
        
    
    def save_script(self, name, content, encrypt=False):
        """Save script with optional encryption"""
        script_path = os.path.join(self.scripts_dir, f"{name}.js")
        metadata_path = f"{script_path}.meta"
        
        try:
            with open(script_path, 'w') as f:
                f.write(content)
            print(f"[ScriptManager] Script '{name}' saved to {script_path}")
        except Exception as e:
            print(f"[ScriptManager] Error saving script '{name}': {e}")
            
        try:
            metadata = {
                'name': name,
                'encrypted': encrypt,
                'tags': [],
                'description': '',
                'version': '1.0'
            }
            with open(metadata_path, 'w') as f:
                json.dump(metadata, f)
            print(f"[ScriptManager] Metadata saved for '{name}' to {metadata_path}")
        except Exception as e:
            print(f"[ScriptManager] Error saving metadata for '{name}': {e}")
        
        self.script_saved.emit(name)
        
    def load_script(self, name):
        """Load script and handle decryption if needed"""
        script_path = os.path.join(self.scripts_dir, f"{name}.js")
        metadata_path = f"{script_path}.meta"
        
        try:
            with open(metadata_path, 'r') as f:
                metadata = json.load(f)
                
            with open(script_path, 'r') as f:
                content = f.read()
                
            if metadata.get('encrypted', False):
                content = self.cipher_suite.decrypt(content.encode()).decode()
                
            self.script_loaded.emit(name, content)
            return content
        except Exception as e:
            print(f"Error loading script: {str(e)}")
            return None
            
    def get_highlighted_script(self, content):
        """Return HTML-formatted highlighted script"""
        return highlight(
            content,
            JavascriptLexer(),
            HtmlFormatter(style='monokai')
        )  
--- File: D:\ANDROID\FridaGUI\src\core\script_templates.py --- 
SCRIPT_TEMPLATES = {
    'API_LOGGING': '''
Java.perform(function() {
    // Common Android API hooks
    var HttpURLConnection = Java.use('java.net.HttpURLConnection');
    var OkHttpClient = Java.use('okhttp3.OkHttpClient');
    var Retrofit = Java.use('retrofit2.Retrofit');
    
    // HTTP URL Connection
    HttpURLConnection.connect.implementation = function() {
        console.log('[+] HttpURLConnection.connect() called');
        console.log('URL: ' + this.getURL().toString());
        console.log('Method: ' + this.getRequestMethod());
        this.connect();
    };
    
    // OkHttp
    OkHttpClient.newCall.implementation = function(request) {
        console.log('[+] OkHttpClient.newCall() intercepted');
        console.log('URL: ' + request.url().toString());
        console.log('Method: ' + request.method());
        console.log('Headers: ' + request.headers().toString());
        return this.newCall(request);
    };
    
    // Retrofit
    Retrofit.create.implementation = function(service) {
        console.log('[+] Retrofit API Service created');
        console.log('Service: ' + service.toString());
        return this.create(service);
    };
});
''',

    'SSL_PINNING_BYPASS': '''
Java.perform(function() {
    var TrustManager = Java.registerClass({
        name: 'com.custom.TrustManager',
        implements: [Java.use('javax.net.ssl.X509TrustManager')],
        methods: {
            checkClientTrusted: function(chain, authType) {},
            checkServerTrusted: function(chain, authType) {},
            getAcceptedIssuers: function() { return []; }
        }
    });

    var SSLContext = Java.use('javax.net.ssl.SSLContext');
    SSLContext.init.implementation = function(keyManager, trustManager, secureRandom) {
        console.log('[+] Bypassing SSL Pinning');
        var trustManagers = [TrustManager.$new()];
        this.init(keyManager, trustManagers, secureRandom);
    };
});
''',

    'APP_INFO': '''
Java.perform(function() {
    var ActivityThread = Java.use('android.app.ActivityThread');
    var Context = Java.use('android.content.Context');
    
    var currentApplication = ActivityThread.currentApplication();
    var context = currentApplication.getApplicationContext();
    
    console.log('\\n[App Information]');
    console.log('Package Name:', context.getPackageName());
    console.log('Process Name:', ActivityThread.currentProcessName());
    console.log('App Version:', context.getPackageManager().getPackageInfo(context.getPackageName(), 0).versionName.value);
    console.log('Target SDK:', context.getApplicationInfo().targetSdkVersion.value);
    
    // List all activities
    var packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 
                     Java.use('android.content.pm.PackageManager').GET_ACTIVITIES.value);
    console.log('\\n[Activities]');
    packageInfo.activities.value.forEach(function(activity) {
        console.log(activity.name.value);
    });
});
''',

    'CUSTOM_API_LOGGER': '''
Java.perform(function() {
    // Add your custom API class/method hooks here
    var targetClass = Java.use('com.example.api.ServiceClass');
    
    targetClass.apiMethod.implementation = function() {
        console.log('[+] API Call Intercepted');
        console.log('Arguments:', arguments);
        var result = this.apiMethod.apply(this, arguments);
        console.log('Result:', result);
        return result;
    };
});
'''
}  
--- File: D:\ANDROID\FridaGUI\src\gui\main_window.py --- 
# --- File: D:\ANDROID\FridaGUI\src\gui\main_window.py ---
from PyQt5.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
                           QPushButton, QStackedWidget, QLabel, QListWidget, QTableWidget,
                           QGroupBox, QCheckBox, QSpinBox, QMessageBox, QScrollArea,
                           QGridLayout, QLineEdit, QTextEdit, QFrame, QDialog, QFileDialog,
                           QSplitter, QApplication)
from PyQt5.QtCore import Qt, QSize, pyqtSlot, QTimer
from PyQt5.QtGui import QFont
import qtawesome as qta
from .widgets.device_panel import DevicePanel
from .widgets.process_panel import ProcessPanel
from .widgets.script_editor import ScriptEditorPanel
from .widgets.output_panel import OutputPanel
from .widgets.codeshare_browser import CodeShareBrowser
from .widgets.app_launcher import AppLauncher
from .widgets.process_monitor import ProcessMonitor as ProcessMonitorWidget
from .widgets.injection_panel import InjectionPanel
from .widgets.device_selector import DeviceSelector
from .widgets.history_page import HistoryPage
from core.history_manager import HistoryManager
from core.android_helper import AndroidHelper
import frida
import subprocess
import os
import json
import requests
import sys

SETTINGS_DIR = os.path.join(os.path.expanduser('~'), '.frida_gui')
FAVORITES_FILE = os.path.join(SETTINGS_DIR, 'favorites.json')

class FridaInjectorMainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Oliver Stankiewicz's | Frida Script Manager")
        self.setMinimumSize(1400, 800)
        self.history_manager = HistoryManager()
        self.favorites = []
        self.load_favorites()
        self.current_device = None
        self.current_pid = None
        self.spawn_target = None
        self.current_session = None
        self.current_script = None
        self.pages = {}
        self.setup_ui()
        self.init_pages()
        
        if hasattr(self, 'codeshare_browser'):
            self.codeshare_browser.favorites_updated.connect(self.refresh_favorites)
            

    def load_favorites(self):
        """Loads favorites list from the JSON file."""
        try:
            if os.path.exists(FAVORITES_FILE):
                with open(FAVORITES_FILE, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    loaded_scripts = data.get('scripts', [])
                    self.favorites = loaded_scripts if isinstance(loaded_scripts, list) else []
                    print(f"[Favorites] Loaded {len(self.favorites)} favorites.")
            else:
                self.favorites = []
                print("[Favorites] No favorites file found, starting empty.")
        except Exception as e:
            print(f"[Favorites] Error loading favorites: {e}. Starting empty.")
            self.favorites = []

    def save_favorites(self):
        """Saves favorites list to the JSON file."""
        try:
            os.makedirs(SETTINGS_DIR, exist_ok=True)
            with open(FAVORITES_FILE, 'w', encoding='utf-8') as f:
                json.dump({'scripts': self.favorites}, f, indent=2)
            print(f"[Favorites] Saved {len(self.favorites)} favorites.")
        except Exception as e:
            print(f"[Favorites] Error saving favorites: {e}")

    def setup_ui(self):
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QHBoxLayout(central_widget)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        sidebar = self.create_sidebar()
        layout.addWidget(sidebar)
        self.stack = QStackedWidget()
        layout.addWidget(self.stack)
        layout.setStretch(0, 1)
        layout.setStretch(1, 4)
        
        return sidebar


    def create_sidebar(self):
        sidebar = QWidget()
        sidebar.setObjectName("sidebar")
        sidebar.setStyleSheet("""
            QWidget#sidebar {
                background-color: #2f3136;
                border-right: 1px solid #202225;
                min-width: 180px;
                max-width: 180px;
            }
            QPushButton {
                text-align: left; padding: 6px 8px; border: none;
                border-radius: 4px; margin: 1px 4px;
                min-height: 32px; max-height: 32px; font-size: 13px;
                color: #b9bbbe; background-color: transparent;
            }
            QPushButton:hover { background-color: #36393f; color: #ffffff; }
            QPushButton:checked { background-color: #404249; color: #ffffff; }
        """)
        layout = QVBoxLayout(sidebar)
        layout.setSpacing(1); layout.setContentsMargins(0, 5, 0, 5)
        self.nav_buttons = {}
        nav_items = [
            ("home", "Home", "fa5s.home"),
            ("inject", "Script Injection", "fa5s.syringe"),
            ("codeshare", "CodeShare", "fa5s.cloud-download-alt"),
            ("favorites", "Favorites", "fa5s.star"),
            ("history", "History", "fa5s.history"),
            ("monitor", "Process Monitor", "fa5s.desktop"),
            ("settings", "Settings", "fa5s.cog")
        ]
        for id_, text, icon in nav_items:
            btn = QPushButton(qta.icon(icon, color='#b9bbbe'), f" {text}")
            btn.setCheckable(True)
            btn.clicked.connect(lambda checked, page_id=id_: self.switch_page(page_id))
            btn.setIconSize(QSize(14, 14))
            self.nav_buttons[id_] = btn
            layout.addWidget(btn)
        layout.addStretch()
        status_layout = QHBoxLayout(); status_layout.setContentsMargins(8, 4, 8, 4)
        self.status_icon = QLabel(); self.status_icon.setPixmap(qta.icon('fa5s.circle', color='#43b581').pixmap(8, 8))
        self.status_text = QLabel("Ready"); self.status_text.setStyleSheet("color: #b9bbbe; font-size: 12px;")
        status_layout.addWidget(self.status_icon); status_layout.addWidget(self.status_text)
        layout.addLayout(status_layout)
        return sidebar

    def init_pages(self):
        self.pages = {
            'home': None, 'inject': None, 'codeshare': None, 
            'favorites': None, 'history': None, 'monitor': None, 'settings': None
        }

        # Attempt to create each page and store it in the self.pages dictionary.
        try: self.pages['home'] = self.create_home_page()
        except Exception as e: print(f"Error creating home page: {e}")
        
        try: self.pages['inject'] = self.create_injection_page()
        except Exception as e: print(f"Error creating injection page: {e}")
        
        try: self.pages['codeshare'] = self.create_codeshare_page()
        except Exception as e: print(f"Error creating codeshare page: {e}")
        
        try: self.pages['favorites'] = self.create_favorites_page()
        except Exception as e: print(f"Error creating favorites page: {e}")
        
        try: self.pages['history'] = self.create_history_page()
        except Exception as e: print(f"Error creating history page: {e}")
        
        try: self.pages['monitor'] = self.create_monitor_page()
        except Exception as e: print(f"Error creating monitor page: {e}")
        
        try: self.pages['settings'] = self.create_settings_page()
        except Exception as e: print(f"Error creating settings page: {e}")

        for page_id, page_widget in self.pages.items():
            if page_widget:
                self.stack.addWidget(page_widget)
            else:
                if page_id in self.nav_buttons:
                    self.nav_buttons[page_id].setEnabled(False)
                    print(f"Disabled nav button for failed page: {page_id}")

        # Set the initial page to 'home'.
        initial_page = 'home'
        if initial_page in self.pages and self.pages[initial_page]:
            self.stack.setCurrentWidget(self.pages[initial_page])
            if initial_page in self.nav_buttons:
                self.nav_buttons[initial_page].setChecked(True)
        # Fallback to the first available page if 'home' failed to create.
        elif any(self.pages.values()):
            # Find the first valid page ID from the nav_buttons order
            valid_page_ids = [pid for pid in self.nav_buttons if pid in self.pages and self.pages[pid]]
            if valid_page_ids:
                first_page_id = valid_page_ids[0]
                self.stack.setCurrentWidget(self.pages[first_page_id])
                if first_page_id in self.nav_buttons:
                    self.nav_buttons[first_page_id].setChecked(True)


    def switch_page(self, page_id):
        if page_id not in self.pages or not self.pages[page_id]:
            print(f"Error: Cannot switch to non-existent page '{page_id}'.")
            return
        target_widget = self.pages[page_id]
        if self.stack.currentWidget() == target_widget: return
        for id_, btn in self.nav_buttons.items():
            if btn: btn.setChecked(id_ == page_id)
        self.stack.setCurrentWidget(target_widget)
        print(f"[MainWindow] Switched to page: {page_id}")

    def create_home_page(self):
        page = QWidget(); layout = QVBoxLayout(page); layout.setSpacing(20); layout.setContentsMargins(20, 20, 20, 20)
        header = QFrame(); header.setStyleSheet("QFrame { background-color: #2f3136; border-radius: 10px; padding: 20px; } QLabel { color: white; }")
        header_layout = QVBoxLayout(header)
        title = QLabel("Welcome to Frida Script Manager"); title.setStyleSheet("font-size: 24px; font-weight: bold;")
        subtitle = QLabel("A powerful GUI tool for Frida script management and injection"); subtitle.setStyleSheet("font-size: 16px; color: #b9bbbe;")
        author = QLabel("Created by Oliver Stankiewicz"); author.setStyleSheet("font-size: 14px; color: #7289da;")
        header_layout.addWidget(title); header_layout.addWidget(subtitle); header_layout.addWidget(author)
        actions = QFrame(); actions.setStyleSheet("QFrame { background-color: #2f3136; border-radius: 10px; padding: 20px; } QLabel { color: white; } QPushButton { background-color: #7289da; border-radius: 5px; padding: 10px; color: white; text-align: left; font-size: 14px; } QPushButton:hover { background-color: #677bc4; }")
        actions_layout = QVBoxLayout(actions); actions_title = QLabel("Quick Actions"); actions_title.setStyleSheet("font-size: 18px; font-weight: bold; margin-bottom: 10px;")
        inject_btn = QPushButton(qta.icon('fa5s.syringe'), " Script Injection"); inject_btn.clicked.connect(lambda: self.switch_page('inject'))
        browse_btn = QPushButton(qta.icon('fa5s.cloud-download-alt'), " Browse CodeShare"); browse_btn.clicked.connect(lambda: self.switch_page('codeshare'))
        favorites_btn = QPushButton(qta.icon('fa5s.star'), " View Favorites"); favorites_btn.clicked.connect(lambda: self.switch_page('favorites'))
        monitor_btn = QPushButton(qta.icon('fa5s.desktop'), " Process Monitor"); monitor_btn.clicked.connect(lambda: self.switch_page('monitor'))
        actions_layout.addWidget(actions_title); actions_layout.addWidget(inject_btn); actions_layout.addWidget(browse_btn); actions_layout.addWidget(favorites_btn); actions_layout.addWidget(monitor_btn)
        layout.addWidget(header); layout.addWidget(actions); layout.addStretch()
        return page

    def create_injection_page(self):
        page = QWidget()
        layout = QVBoxLayout(page)
        layout.setContentsMargins(10, 10, 10, 10); layout.setSpacing(10)
        try:
             self.device_selector = DeviceSelector()
             self.script_editor = ScriptEditorPanel()
             self.injection_panel = InjectionPanel()
             self.output_panel = OutputPanel()
        except NameError as ne:
             print(f"Error instantiating injection widgets: {ne}. Check imports.")
             QMessageBox.critical(self, "Init Error", f"Failed to create injection UI component: {ne}")
             return None
        self.injection_panel.injection_started.connect(self.handle_injection_request)
        self.injection_panel.injection_stopped.connect(self.stop_injection)

        # Forward process selection to injection panel
        self.device_selector.process_selected.connect(self.injection_panel.set_process)
        editor_widget = self.script_editor.get_editor_widget()
        if editor_widget:
            if hasattr(self.injection_panel, 'set_script_editor_widget'):
                 self.injection_panel.set_script_editor_widget(editor_widget)
                 print("[MainWindow] Linked InjectionPanel to ScriptEditorPanel's editor.")
            else:
                 print("CRITICAL ERROR: InjectionPanel has no 'set_script_editor_widget' method!")
                 QMessageBox.critical(self, "Code Error", "InjectionPanel is missing 'set_script_editor_widget'. Cannot link editor.")
                 return None
        else:
             print("CRITICAL ERROR: Could not get editor widget from ScriptEditorPanel!")
             QMessageBox.critical(self, "Init Error", "Failed to get script editor widget.")
             return None
        editor_output_splitter = QSplitter(Qt.Vertical)
        editor_output_splitter.addWidget(self.script_editor)
        editor_output_splitter.addWidget(self.output_panel)
        editor_output_splitter.setSizes([400, 200])
        layout.addWidget(self.device_selector)
        layout.addWidget(editor_output_splitter)
        layout.addWidget(self.injection_panel)
        try:
             # Connect signals for both attaching to a running process and spawning a new one.
             self.device_selector.process_selected.connect(self._update_current_selection)
             self.device_selector.application_selected_for_spawn.connect(self._update_spawn_target)
             
             
             # The injection panel now triggers a unified handler in the main window.
             self.injection_panel.injection_started.connect(self.handle_injection_request)
             self.injection_panel.injection_stopped.connect(self.stop_injection)
             
             # Ensure the injection panel is aware of the initial process selection.
             self.device_selector.process_selected.connect(self.injection_panel.set_process)

        except TypeError as te:
             print(f"SIGNAL/SLOT TYPE ERROR during connection: {te}")
             QMessageBox.critical(self, "Signal/Slot Error", f"Connection failed due to type mismatch: {te}\nCheck @pyqtSlot decorators and signal definitions.")
             return None
        return page

    @pyqtSlot(str, int)
    def _update_current_selection(self, device_id, pid):
        # This slot handles the selection of a currently running process.
        pid_int = None
        if pid is not None:
             try:
                  pid_int = int(pid)
                  if pid_int <= 0: pid_int = None
             except (ValueError, TypeError):
                  pid_int = None
        else: pid_int = None
        
        self.current_device = device_id
        self.current_pid = pid_int
        # Clear the spawn target, as we are now in "attach" mode.
        self.spawn_target = None
        
        status_text = "Ready"; icon_color = '#99aab5'
        if self.current_device and self.current_pid:
             status_text = f"PID: {self.current_pid} @ {self.current_device}"; icon_color = '#43b581'
        elif self.current_device:
             status_text = f"Device: {self.current_device} | No process"; icon_color = '#faa61a'
        else:
             status_text = "No device selected"
        self.status_text.setText(status_text)
        self.status_icon.setPixmap(qta.icon('fa5s.circle', color=icon_color).pixmap(10, 10))
        print(f"[MainWindow] Selection Updated: Device={self.current_device}, PID={self.current_pid}")

    @pyqtSlot(str, str, str, str)
    def _update_spawn_target(self, device_id, app_identifier, script_paths, frida_options):
        """
        Handles spawn request with multiple scripts in sequence.
        Called when user selects app + multiple scripts + Frida options.
        """
        self.current_device = device_id
        self.spawn_target = app_identifier
        self.current_pid = None  # Clear PID until spawn completes

        # Update status bar
        status_text = f"Spawn: {self.spawn_target} @ {self.current_device}"
        self.status_text.setText(status_text)
        self.status_icon.setPixmap(qta.icon('fa5s.circle', color='#7289da').pixmap(10, 10))

        print(f"[MainWindow] Spawn Target Set: {app_identifier} on {device_id}")
        print(f"    Scripts: {len(script_paths)}")
        print(f"    Options: {frida_options}")

        # Switch to inject page
        self.switch_page('inject')

        # Start the multi-script spawn sequence
        self._start_multi_script_spawn(device_id, app_identifier, script_paths, frida_options)

        
    def _start_multi_script_spawn(self, device_id, app_identifier, script_paths, frida_options):
        """Launches app and injects scripts one by one."""
        try:
            device = frida.get_device(device_id)
            if device.type == 'usb' and not AndroidHelper.is_frida_running(device_id):
                raise Exception("Frida server not running on device.")

            self.output_panel.append_output(f"[*] Spawning '{app_identifier}'...")
            print(f"[Spawn] Spawning {app_identifier}...")
            pid = device.spawn([app_identifier])

            # Update state with new PID
            self._update_current_selection(device_id, pid)
            self.output_panel.append_output(f"[+] Spawned PID: {pid}")

            # Resume only after ALL scripts are loaded
            base_cmd = ["frida", "-D", device_id, "-n", str(pid)]
            if frida_options:
                base_cmd.extend(frida_options.split())

            # Inject each script in order
            for i, script_path in enumerate(script_paths):
                self.output_panel.append_output(f"[*] Loading script {i+1}/{len(script_paths)}: {os.path.basename(script_path)}")
                print(f"  → Running script {i+1}: {script_path}")

                cmd = base_cmd.copy()
                cmd.extend(["-l", "-"])  # load from stdin

                try:
                    with open(script_path, 'r', encoding='utf-8') as f:
                        script_content = f.read()

                    proc = subprocess.Popen(
                        cmd,
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        text=True
                    )
                    stdout, stderr = proc.communicate(script_content)

                    if proc.returncode == 0:
                        self.output_panel.append_output(f"[+] Script {i+1} injected.")
                        print(f"  Success: Script {i+1} completed.")
                    else:
                        err = stderr.strip() or "Unknown error"
                        self.output_panel.append_output(f"[-] Script {i+1} failed: {err}")
                        print(f"  Failed: {err}")
                        # Continue to next script or break?
                        # break  # Uncomment to stop on first error

                except Exception as e:
                    self.output_panel.append_output(f"[-] Error reading script {i+1}: {e}")
                    print(f"  Error: {e}")

            # Final resume
            print(f"[Spawn] Resuming PID {pid}...")
            device.resume(pid)
            self.output_panel.append_output(f"[*] Resumed PID: {pid}")
            self.output_panel.append_output("[+] All scripts injected and app resumed.")

            # Trigger injection panel success
            if hasattr(self, 'injection_panel'):
                self.injection_panel.injection_succeeded()

        except Exception as e:
            error_msg = str(e)
            self.output_panel.append_output(f"[-] Spawn failed: {error_msg}")
            print(f"[Spawn] Failed: {error_msg}")
            if hasattr(self, 'injection_panel'):
                self.injection_panel.injection_failed(error_msg)

    def create_codeshare_page(self):
        page = QWidget(); layout = QVBoxLayout(page); layout.setContentsMargins(0,0,0,0)
        self.codeshare_browser = CodeShareBrowser()
        self.codeshare_browser.open_in_injector.connect(self.open_script_in_injector)
        layout.addWidget(self.codeshare_browser)
        return page

    def create_favorites_page(self):
        page = QWidget(); layout = QVBoxLayout(page); layout.setContentsMargins(10, 10, 10, 10); layout.setSpacing(10)
        toolbar = QHBoxLayout(); search_input = QLineEdit(); search_input.setPlaceholderText("Search favorites..."); search_input.textChanged.connect(self.filter_favorites)
        upload_btn = QPushButton(qta.icon('fa5s.file-upload'), "Upload Script"); upload_btn.clicked.connect(self.upload_script)
        toolbar.addWidget(search_input); toolbar.addWidget(upload_btn)
        scroll = QScrollArea(); scroll.setWidgetResizable(True); scroll.setStyleSheet("QScrollArea { border: none; background-color: #36393f; }")
        self.favorites_grid = QWidget(); self.favorites_grid.setStyleSheet("QWidget { background-color: #36393f; }")
        self.favorites_grid_layout = QGridLayout(self.favorites_grid); self.favorites_grid_layout.setSpacing(10); self.favorites_grid_layout.setContentsMargins(15, 15, 15, 15)
        scroll.setWidget(self.favorites_grid); layout.addLayout(toolbar); layout.addWidget(scroll)
        self.refresh_favorites()
        return page

    def create_history_page(self):
        page = QWidget(); layout = QVBoxLayout(page); layout.setContentsMargins(10, 10, 10, 10)
        self.history_page = HistoryPage(self.history_manager)
        self.history_page.script_selected.connect(self.open_script_in_injector)
        layout.addWidget(self.history_page)
        return page

    def create_monitor_page(self):
        page = QWidget(); layout = QVBoxLayout(page); layout.setContentsMargins(10, 10, 10, 10)
        self.process_monitor_widget = ProcessMonitorWidget(main_window=self)
        layout.addWidget(self.process_monitor_widget)
        return page

    def create_settings_page(self):
        page = QWidget(); layout = QVBoxLayout(page); layout.setContentsMargins(20, 20, 20, 20); layout.setSpacing(15)
        settings_categories = [
            ("General", [("Auto-inject on launch", "checkbox"), ("Save script history", "checkbox"), ("Dark theme", "checkbox")]),
            ("Script Editor", [("Font size", "spinbox"), ("Show line numbers", "checkbox"), ("Auto-completion", "checkbox")]),
            ("Monitoring", [("Update interval", "spinbox"), ("Show memory usage", "checkbox"), ("Log to file", "checkbox")])
        ]
        for category, settings in settings_categories:
            group = QGroupBox(category); group_layout = QVBoxLayout()
            for setting_name, setting_type in settings:
                setting_layout = QHBoxLayout(); setting_layout.addWidget(QLabel(setting_name))
                widget = QCheckBox() if setting_type == "checkbox" else QSpinBox()
                setting_layout.addWidget(widget); group_layout.addLayout(setting_layout)
            group.setLayout(group_layout); layout.addWidget(group)
        layout.addStretch()
        return page

    @pyqtSlot(str, int)
    def handle_injection_request(self, script_content, pid):
        """Unified injection handler for both attaching to a running process and spawning a new one."""
        device = None
        session = None
        
        # Determine if this is an ATTACH or SPAWN operation based on the current state.
        is_attach_mode = self.current_pid is not None and self.current_pid == pid
        is_spawn_mode = self.spawn_target is not None and not is_attach_mode

        try:
            if is_attach_mode:
                # ATTACH workflow for existing processes.
                print(f"[Inject] Handling ATTACH request for PID: {self.current_pid}")
                device_id = self.current_device
                attach_target = self.current_pid
                
                device = frida.get_device(device_id)
                if device.type == 'usb' and not AndroidHelper.is_frida_running(device_id):
                    raise Exception(f"Frida server not running on {device_id}.")
                
                print(f"[Inject] Attaching to PID: {attach_target}...")
                session = device.attach(attach_target)
                self.output_panel.append_output(f"[+] Attached to PID: {attach_target}")

            elif is_spawn_mode:
                # SPAWN workflow for starting new application instances.
                print(f"[Inject] Handling SPAWN request for App: {self.spawn_target}")
                device_id = self.current_device
                app_identifier = self.spawn_target

                device = frida.get_device(device_id)
                if device.type == 'usb' and not AndroidHelper.is_frida_running(device_id):
                    raise Exception(f"Frida server not running on {device_id}.")
                
                print(f"[Inject] Spawning '{app_identifier}'...")
                self.output_panel.append_output(f"[*] Spawning '{app_identifier}'...")
                new_pid = device.spawn([app_identifier])
                
                # Update the main state to reflect the newly spawned process.
                self._update_current_selection(device_id, new_pid)
                
                print(f"[Inject] Attaching to newly spawned PID: {new_pid}...")
                session = device.attach(new_pid)
                self.output_panel.append_output(f"[+] Attached to spawned PID: {new_pid}")
            
            else:
                raise Exception("Injection target mismatch. Re-select the process or app.")
            
            # Common logic for script loading and session handling.
            if not session or session.is_detached:
                raise Exception("Failed to establish a Frida session.")
            
            self.current_session = session
            
            def on_detached(reason, crash):
                if self.current_session is not None:
                    print(f"[Inject] Session detached! Reason: {reason}")
                    self.output_panel.append_output(f"[!] Session detached: {reason}" + (" (App Crashed)" if crash else ""))
                    self.stop_injection(process_ended=crash is not None)
                    if hasattr(self, 'injection_panel'):
                        self.injection_panel.injection_stopped_externally()

            session.on('detached', on_detached)
            
            print("[Inject] Creating script object...")
            script = session.create_script(script_content)
            self.current_script = script
            
            def on_message(message, data):
                try:
                    msg_type = message.get('type') if isinstance(message, dict) else 'unknown'
                    payload = message.get('payload', '') if isinstance(message, dict) else str(message)
                    log_entry = f"[Frida] {payload}" if msg_type == 'send' else f"[Frida] Type {msg_type}: {message}"
                    self.output_panel.append_output(log_entry)
                except Exception as msg_e:
                    print(f"Error processing Frida message: {msg_e}")

            script.on('message', on_message)
            
            print("[Inject] Loading script...")
            script.load()
            print("[Inject] Script loaded.")
            self.output_panel.append_output("[+] Script loaded successfully.")
            
            # If we are in spawn mode, resume the application now that the script is loaded.
            if is_spawn_mode:
                print(f"[Inject] Resuming PID: {self.current_pid}")
                device.resume(self.current_pid)
                self.output_panel.append_output(f"[*] Resumed PID: {self.current_pid}")
            
            if hasattr(self, 'injection_panel'):
                self.injection_panel.injection_succeeded()
            
            self.history_manager.add_entry('script_injection', {
                'script': script_content[:200] + "...", 'pid': self.current_pid, 'device': self.current_device, 'status': 'success'
            })

        except Exception as e:
            error_msg = f"{str(e)}"
            print(f"[Inject] Injection process failed: {error_msg}")
            self.output_panel.append_output(f"[-] Injection Error: {error_msg}")
            if hasattr(self, 'injection_panel'):
                self.injection_panel.injection_failed(error_msg)
            self.stop_injection()
            self.history_manager.add_entry('script_injection', {
                'script': script_content[:200] + "...", 'pid': pid, 'device': self.current_device, 'status': 'failed', 'error': error_msg
            })

    def stop_injection(self, process_ended=False):
         """Stop the current injection and clean up state."""
         pid_context = self.current_pid if self.current_pid else "N/A"
         if getattr(self, '_stopping', False): return
         self._stopping = True
         print(f"[StopInject] Initiated. PID: {pid_context}, Process Ended: {process_ended}")
 
         # Perform the potentially blocking Frida calls in a short delay
         def _perform_blocking_cleanup():
             try:
                 if self.current_script:
                     try: self.current_script.unload()
                     except Exception as e: print(f"[StopInject] Error unloading: {e}")
                 if self.current_session and not self.current_session.is_detached:
                     try: self.current_session.detach()
                     except Exception as e: print(f"[StopInject] Error detaching: {e}")
             finally:
                 self._finish_cleanup(pid_context, process_ended)
 
         # Use QTimer to briefly yield control back to the event loop before blocking
         QTimer.singleShot(10, _perform_blocking_cleanup)
 
    def _finish_cleanup(self, pid_context, process_ended):
         # This method contains the non-blocking cleanup logic
         was_running = self.current_session is not None
         self.current_script = None
         self.current_session = None
         # Reset both attach and spawn targets on stop.
         self.spawn_target = None
 
         if process_ended:
             self.output_panel.append_output(f"[*] Target process {pid_context} ended.")
             self.current_pid = None
         elif was_running:
             self.output_panel.append_output("[*] Script injection stopped.")
 
         if hasattr(self, 'injection_panel'):
             self.injection_panel.injection_stopped_update()
 
         self._update_current_selection(self.current_device, self.current_pid)
         self._stopping = False

    def on_process_selected(self, device_id, pid):
        pass

    def open_in_injector(self, device_id, pid):
        print(f"[MainWindow] Opening Injector for: {pid}@{device_id}")
        self.switch_page('inject')
        if hasattr(self, 'device_selector'):
            self.device_selector.select_device(device_id)
            QTimer.singleShot(100, lambda: self.device_selector.select_process(pid))
        else: print("Error: device_selector not found")

    @pyqtSlot(str)
    def open_script_in_injector(self, code):
        print("[MainWindow] Opening script in injector editor.")
        self.switch_page('inject')
        if hasattr(self, 'script_editor'):
            self.script_editor.set_script(code)
            editor_widget = self.script_editor.get_editor_widget()
            if editor_widget: editor_widget.setFocus()
        else: print("Error: script_editor panel not found")

    def refresh_favorites(self):
        layout = getattr(self, 'favorites_grid_layout', None)
        if not layout: return
        while layout.count(): 
            item = layout.takeAt(0)
            widget = item.widget()
            if widget: widget.deleteLater()
        all_favorites = []
        if hasattr(self, 'codeshare_browser') and hasattr(self.codeshare_browser, 'favorites'):
            try:
                response = requests.get(self.codeshare_browser.api_url, timeout=10)
                response.raise_for_status()
                codeshare_scripts = response.json()
                cs_favs = self.codeshare_browser.favorites
                if isinstance(cs_favs, (list, set)):
                    all_favorites.extend(s for s in codeshare_scripts if s.get('id') in cs_favs)
            except Exception as e: 
                print(f"Error getting CodeShare favs: {e}")
        all_favorites.extend(s for s in self.favorites if isinstance(s, dict) and s.get('id','').startswith('custom/'))
        all_favorites.sort(key=lambda x: x.get('title', '').lower())
        if all_favorites:
            for idx, script_info in enumerate(all_favorites):
                row, col = divmod(idx, 3)
                card = self.create_favorite_card(script_info)
                if card: layout.addWidget(card, row, col)
        else:
            msg = QLabel("No favorites found.")
            msg.setAlignment(Qt.AlignCenter)
            msg.setStyleSheet("color: #b9bbbe; padding: 20px;")
            layout.addWidget(msg, 0, 0, 1, 3)
        layout.setRowStretch(layout.rowCount(), 1)
        layout.setColumnStretch(layout.columnCount(), 1)

    def filter_favorites(self, text):
        search_text = text.lower()
        layout = getattr(self, 'favorites_grid_layout', None)
        if not layout: return
        no_fav_label = None
        has_visible_card = False
        for i in range(layout.count()):
            widget = layout.itemAt(i).widget()
            if widget and isinstance(widget, QFrame):
                labels = widget.findChildren(QLabel)
                title_label = labels[0] if labels else None
                desc_label = labels[2] if len(labels) > 2 else None
                if title_label and desc_label:
                     title_matches = search_text in title_label.text().lower()
                     desc_matches = search_text in desc_label.text().lower()
                     is_visible = not search_text or title_matches or desc_matches
                     widget.setVisible(is_visible)
                     if is_visible: has_visible_card = True
            elif widget and isinstance(widget, QLabel): 
                no_fav_label = widget
        if no_fav_label: 
            no_fav_label.setVisible(not has_visible_card and not search_text)

    def upload_script(self):
        start_dir = os.getcwd()
        #start_dir = os.path.expanduser('~')
        file_path, _ = QFileDialog.getOpenFileName(self, "Upload Script", start_dir, "JavaScript Files (*.js);;All Files (*.*)")
        if file_path:
            try:
                with open(file_path, 'r', encoding='utf-8') as f: 
                    script_content = f.read()
                script_name = os.path.basename(file_path)
                script_info = {
                    'id': f"custom/{script_name}",
                    'title': script_name,
                    'author': 'Custom Script',
                    'description': 'Uploaded custom script',
                    'likes': 0,
                    'seen': 0,
                    'content': script_content
                }
                self.add_to_favorites(script_info)
            except Exception as e: 
                QMessageBox.critical(self, "Error", f"Failed to upload script: {str(e)}")

    def add_to_favorites(self, script_info):
        if not any(isinstance(s, dict) and s.get('id') == script_info.get('id') for s in self.favorites):
            self.favorites.append(script_info)
            self.save_favorites()
        card = self.create_favorite_card(script_info)
        layout = getattr(self, 'favorites_grid_layout', None)
        if card and layout: 
            count = layout.count()
            row, col = divmod(count, 3)
            layout.addWidget(card, row, col)

    def create_favorite_card(self, script_info):
        card = QFrame()
        card.setStyleSheet("QFrame { background-color: #2f3136; border-radius: 8px; padding: 10px; } QFrame:hover { background-color: #40444b; }")
        layout = QVBoxLayout(card)
        title = QLabel(script_info.get('title', 'N/A'))
        title.setStyleSheet("font-size: 14px; font-weight: bold; color: white;")
        author = QLabel(f"by {script_info.get('author', 'N/A')}")
        author.setStyleSheet("color: #b9bbbe;")
        desc_text = script_info.get('description', '')
        desc = QLabel(desc_text[:100] + ('...' if len(desc_text) > 100 else ''))
        desc.setWordWrap(True)
        desc.setStyleSheet("color: #b9bbbe;")
        buttons = QHBoxLayout()
        view_btn = QPushButton("View")
        view_btn.clicked.connect(lambda checked, si=script_info: self.view_favorite(si))
        inject_btn = QPushButton("Inject")
        inject_btn.clicked.connect(lambda checked, si=script_info: self.open_script_in_injector(si.get('content', '')))
        remove_btn = QPushButton("Remove")
        remove_btn.clicked.connect(lambda checked, si=script_info, c=card: self.remove_from_favorites(si, c))
        buttons.addWidget(view_btn)
        buttons.addWidget(inject_btn)
        buttons.addWidget(remove_btn)
        buttons.addStretch()
        layout.addWidget(title)
        layout.addWidget(author)
        layout.addWidget(desc)
        layout.addLayout(buttons)
        return card

    def view_favorite(self, script_info):
        dialog = QDialog(self)
        dialog.setWindowTitle(f"View Script - {script_info.get('title', 'N/A')}")
        dialog.resize(800, 600)
        layout = QVBoxLayout(dialog)
        content = QTextEdit()
        content.setReadOnly(True)
        try: content.setFont(QFont('Consolas', 11))
        except: pass
        content.setText(script_info.get('content', 'Script content not available'))
        buttons = QHBoxLayout()
        copy_btn = QPushButton(" Copy")
        copy_btn.clicked.connect(lambda: self.copy_to_clipboard(content.toPlainText()))
        inject_btn = QPushButton("Inject")
        inject_btn.clicked.connect(lambda: self.open_script_in_injector(content.toPlainText()))
        buttons.addWidget(copy_btn)
        buttons.addWidget(inject_btn)
        buttons.addStretch()
        layout.addWidget(content)
        layout.addLayout(buttons)
        dialog.exec_()

    def remove_from_favorites(self, script_info, card):
        script_id = script_info.get('id')
        if not script_id: return
        reply = QMessageBox.question(self, "Remove Favorite", f"Remove {script_info.get('title', 'N/A')} from favorites?", QMessageBox.Yes | QMessageBox.No)
        if reply == QMessageBox.Yes:
            card.setParent(None)
            if script_id.startswith('custom/'):
                self.favorites = [s for s in self.favorites if not (isinstance(s, dict) and s.get('id') == script_id)]
                self.save_favorites()
            elif hasattr(self, 'codeshare_browser') and hasattr(self.codeshare_browser, 'favorites'):
                 try: 
                     self.codeshare_browser.favorites.remove(script_id)
                     self.codeshare_browser.save_favorites()
                 except: pass
            self.refresh_favorites()

    def copy_to_clipboard(self, text):
        QApplication.clipboard().setText(text)
        QMessageBox.information(self, "Success", "Copied to clipboard!")

    def cleanup(self):
        print("[MainWindow] Running cleanup...")
        if hasattr(self, 'process_monitor_widget') and hasattr(self.process_monitor_widget, 'stop_monitoring'):
            self.process_monitor_widget.stop_monitoring()
        if hasattr(self, 'history_manager'):
            self.history_manager.save_history()
        if hasattr(self, 'device_selector'):
            self.device_selector.cleanup()
        self.stop_injection()
        self.current_script = None
        self.current_session = None
        print("[MainWindow] Cleanup finished.")

    def closeEvent(self, event):
        """Handle window close event."""
        self.cleanup()
        event.accept() 
--- File: D:\ANDROID\FridaGUI\src\gui\__init__.py --- 
# Empty file to make the directory a Python package  
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\app_launcher.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, 
                           QLineEdit, QComboBox, QLabel, QTableWidget, 
                           QTableWidgetItem, QMenu, QAction, QCheckBox,
                           QFileDialog, QGroupBox)
from PyQt5.QtCore import pyqtSignal, Qt
import subprocess
import json
import os
import qtawesome as qta
import sys

class AppLauncher(QWidget):
    app_launched = pyqtSignal(str, int)  # package_name, pid
    script_selected = pyqtSignal(str)  # script content
    
    def __init__(self):
        super().__init__()
        self.favorites_file = os.path.join(os.path.expanduser('~'), '.frida_gui', 'favorites.json')
        self.scripts_dir = os.path.join(os.path.expanduser('~'), '.frida_gui', 'scripts')
        self.load_favorites()
        self.setup_ui()
        
    def setup_ui(self):
        layout = QVBoxLayout(self)
        
        # Quick Launch Section
        quick_launch_group = QGroupBox("Quick Launch")
        quick_launch_layout = QVBoxLayout()
        
        # Package input
        package_layout = QHBoxLayout()
        self.package_input = QLineEdit()
        self.package_input.setPlaceholderText("Enter package name or path...")
        self.launch_button = QPushButton("Launch")
        self.launch_button.setIcon(qta.icon('fa5s.play'))
        self.launch_button.clicked.connect(self.launch_app)
        package_layout.addWidget(self.package_input)
        package_layout.addWidget(self.launch_button)
        
        # Script Selection
        script_layout = QHBoxLayout()
        self.script_input = QLineEdit()
        self.script_input.setPlaceholderText("Select Frida script file...")
        self.script_input.setReadOnly(True)
        
        self.browse_script_btn = QPushButton("Browse")
        self.browse_script_btn.setIcon(qta.icon('fa5s.folder-open'))
        self.browse_script_btn.clicked.connect(self.browse_script)
        
        self.edit_script_btn = QPushButton("Edit")
        self.edit_script_btn.setIcon(qta.icon('fa5s.edit'))
        self.edit_script_btn.clicked.connect(self.edit_script)
        self.edit_script_btn.setEnabled(False)
        
        script_layout.addWidget(self.script_input)
        script_layout.addWidget(self.browse_script_btn)
        script_layout.addWidget(self.edit_script_btn)
        
        # Launch Options
        options_layout = QHBoxLayout()
        self.debug_check = QCheckBox("Debug Mode")
        self.wait_check = QCheckBox("Wait for Debugger")
        self.inject_check = QCheckBox("Auto-Inject Script")
        self.inject_check.toggled.connect(self.toggle_script_selection)
        
        options_layout.addWidget(self.debug_check)
        options_layout.addWidget(self.wait_check)
        options_layout.addWidget(self.inject_check)
        
        quick_launch_layout.addLayout(package_layout)
        quick_launch_layout.addLayout(script_layout)
        quick_launch_layout.addLayout(options_layout)
        quick_launch_group.setLayout(quick_launch_layout)
        
        # Favorites Section
        favorites_group = QGroupBox("Favorites")
        favorites_layout = QVBoxLayout()
        
        self.favorites_table = QTableWidget(0, 4)  # Added column for script
        self.favorites_table.setHorizontalHeaderLabels(["Name", "Package", "Script", "Actions"])
        self.favorites_table.horizontalHeader().setStretchLastSection(True)
        self.favorites_table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.favorites_table.customContextMenuRequested.connect(self.show_context_menu)
        
        favorites_layout.addWidget(self.favorites_table)
        favorites_group.setLayout(favorites_layout)
        
        # Recent Apps Section
        recent_group = QGroupBox("Recent Apps")
        recent_layout = QHBoxLayout()
        self.recent_combo = QComboBox()
        self.recent_combo.setPlaceholderText("Recent Apps")
        recent_launch_btn = QPushButton("Launch Recent")
        recent_launch_btn.clicked.connect(self.launch_recent)
        
        recent_layout.addWidget(self.recent_combo)
        recent_layout.addWidget(recent_launch_btn)
        recent_group.setLayout(recent_layout)
        
        # Add all sections to main layout
        layout.addWidget(quick_launch_group)
        layout.addWidget(favorites_group)
        layout.addWidget(recent_group)
        
        # Populate favorites
        self.update_favorites_table()
        
    def browse_script(self):
        file_name, _ = QFileDialog.getOpenFileName(
            self,
            "Select Frida Script",
            self.scripts_dir,
            "JavaScript Files (*.js);;All Files (*.*)"
        )
        
        if file_name:
            self.script_input.setText(file_name)
            self.edit_script_btn.setEnabled(True)
            
            # Read script content
            try:
                with open(file_name, 'r') as f:
                    script_content = f.read()
                self.script_selected.emit(script_content)
            except Exception as e:
                print(f"Error reading script: {str(e)}")
                
    def edit_script(self):
        script_path = self.script_input.text()
        if script_path and os.path.exists(script_path):
            # You can implement your own script editor or use system default
            if sys.platform == 'win32':
                os.startfile(script_path)
            elif sys.platform == 'darwin':
                subprocess.run(['open', script_path])
            else:
                subprocess.run(['xdg-open', script_path])
                
    def toggle_script_selection(self, enabled):
        self.script_input.setEnabled(enabled)
        self.browse_script_btn.setEnabled(enabled)
        self.edit_script_btn.setEnabled(enabled and bool(self.script_input.text()))
        
    def add_to_favorites(self, name, package, script_path=None):
        self.favorites[name] = {
            'package': package,
            'script': script_path
        }
        self.save_favorites()
        self.update_favorites_table()
        
    def update_favorites_table(self):
        self.favorites_table.setRowCount(0)
        for name, data in self.favorites.items():
            row = self.favorites_table.rowCount()
            self.favorites_table.insertRow(row)
            
            name_item = QTableWidgetItem(name)
            package_item = QTableWidgetItem(data['package'])
            script_item = QTableWidgetItem(data.get('script', ''))
            
            launch_btn = QPushButton("Launch")
            launch_btn.clicked.connect(
                lambda checked, p=data['package'], s=data.get('script'): 
                self.launch_favorite(p, s)
            )
            
            self.favorites_table.setItem(row, 0, name_item)
            self.favorites_table.setItem(row, 1, package_item)
            self.favorites_table.setItem(row, 2, script_item)
            self.favorites_table.setCellWidget(row, 3, launch_btn)
            
    def launch_favorite(self, package, script_path=None):
        if script_path:
            try:
                with open(script_path, 'r') as f:
                    script_content = f.read()
                self.script_selected.emit(script_content)
            except Exception as e:
                print(f"Error reading script: {str(e)}")
        self.launch_app(package)
        
    def show_context_menu(self, position):
        menu = QMenu()
        remove_action = QAction("Remove from Favorites", self)
        remove_action.triggered.connect(self.remove_selected_favorite)
        
        edit_script_action = QAction("Edit Script", self)
        edit_script_action.triggered.connect(self.edit_selected_script)
        
        menu.addAction(remove_action)
        menu.addAction(edit_script_action)
        menu.exec_(self.favorites_table.mapToGlobal(position))
        
    def edit_selected_script(self):
        current_row = self.favorites_table.currentRow()
        if current_row >= 0:
            script_path = self.favorites_table.item(current_row, 2).text()
            if script_path:
                if sys.platform == 'win32':
                    os.startfile(script_path)
                elif sys.platform == 'darwin':
                    subprocess.run(['open', script_path])
                else:
                    subprocess.run(['xdg-open', script_path])
                
    def launch_app(self, package_name=None):
        if not package_name:
            package_name = self.package_input.text()
            
        try:
            cmd = ['adb', 'shell', 'am', 'start']
            
            if self.debug_check.isChecked():
                cmd.extend(['-D'])
                
            if self.wait_check.isChecked():
                cmd.extend(['-W'])
                
            cmd.extend(['-n', f'{package_name}/{package_name}.MainActivity'])
            
            process = subprocess.Popen(cmd, 
                                    stdout=subprocess.PIPE, 
                                    stderr=subprocess.PIPE)
            
            stdout, stderr = process.communicate()
            
            if process.returncode == 0:
                self.add_to_recent(package_name)
                # Get PID of launched app
                pid_cmd = ['adb', 'shell', 'pidof', package_name]
                pid = subprocess.check_output(pid_cmd).decode().strip()
                if pid:
                    self.app_launched.emit(package_name, int(pid))
            else:
                raise Exception(stderr.decode())
                
        except Exception as e:
            print(f"Error launching app: {str(e)}")
            
    def add_to_favorites(self, name, package):
        self.favorites[name] = package
        self.save_favorites()
        self.update_favorites_table()
        
    def remove_from_favorites(self, name):
        if name in self.favorites:
            del self.favorites[name]
            self.save_favorites()
            self.update_favorites_table()
            
    def load_favorites(self):
        try:
            if os.path.exists(self.favorites_file):
                with open(self.favorites_file, 'r') as f:
                    self.favorites = json.load(f)
            else:
                self.favorites = {}
        except:
            self.favorites = {}
            
    def save_favorites(self):
        os.makedirs(os.path.dirname(self.favorites_file), exist_ok=True)
        with open(self.favorites_file, 'w') as f:
            json.dump(self.favorites, f)
            
    def update_favorites_table(self):
        self.favorites_table.setRowCount(0)
        for name, package in self.favorites.items():
            row = self.favorites_table.rowCount()
            self.favorites_table.insertRow(row)
            
            name_item = QTableWidgetItem(name)
            package_item = QTableWidgetItem(package)
            
            launch_btn = QPushButton("Launch")
            launch_btn.clicked.connect(lambda checked, p=package: self.launch_app(p))
            
            self.favorites_table.setItem(row, 0, name_item)
            self.favorites_table.setItem(row, 1, package_item)
            self.favorites_table.setCellWidget(row, 2, launch_btn)
            
    def show_context_menu(self, position):
        menu = QMenu()
        remove_action = QAction("Remove from Favorites", self)
        remove_action.triggered.connect(lambda: self.remove_selected_favorite())
        menu.addAction(remove_action)
        menu.exec_(self.favorites_table.mapToGlobal(position))
        
    def remove_selected_favorite(self):
        current_row = self.favorites_table.currentRow()
        if current_row >= 0:
            name = self.favorites_table.item(current_row, 0).text()
            self.remove_from_favorites(name)
            
    def add_to_recent(self, package_name):
        current_text = self.recent_combo.currentText()
        if current_text != package_name:
            self.recent_combo.insertItem(0, package_name)
            if self.recent_combo.count() > 10:
                self.recent_combo.removeItem(10)
                
    def launch_recent(self):
        package_name = self.recent_combo.currentText()
        if package_name:
            self.launch_app(package_name)  
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\codeshare_browser.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, 
                           QLineEdit, QPushButton, QListWidget, 
                           QTextBrowser, QSplitter, QComboBox,
                           QLabel, QProgressBar, QMessageBox, QGroupBox, QDialog, QTabWidget, QMenu, QFrame, QTableWidget, QHeaderView, QFileDialog, QScrollArea, QGridLayout, QTextEdit)
from PyQt5.QtCore import pyqtSignal, Qt, QThread, QUrl
from PyQt5.QtGui import QFont, QDesktopServices, QIcon
import aiohttp
import asyncio
import qtawesome as qta
import json
import os
from bs4 import BeautifulSoup
from core.script_templates import SCRIPT_TEMPLATES
from core.script_history import ScriptHistory
import time
import requests
import threading
import re

class CodeFetcher(QThread):
    code_fetched = pyqtSignal(str)
    error_occurred = pyqtSignal(str)
    
    def __init__(self, url):
        super().__init__()
        self.url = url
        
    def run(self):
        try:
            response = requests.get(self.url)
            if response.status_code != 200:
                self.error_occurred.emit(f"HTTP Error: {response.status_code}")
                return
                
            # Find the script content in the Vue.js data
            script_match = re.search(r'projectSource: "(.*?)",', response.text, re.DOTALL)
            if script_match:
                # Unescape the JavaScript string
                code = script_match.group(1).encode().decode('unicode_escape')
                self.code_fetched.emit(code)
            else:
                # Try alternative method - look for the editor content
                soup = BeautifulSoup(response.text, 'html.parser')
                editor_div = soup.find('div', {'id': 'editor'})
                if editor_div and editor_div.string:
                    self.code_fetched.emit(editor_div.string)
                else:
                    self.error_occurred.emit("Could not find script content")
                
        except Exception as e:
            self.error_occurred.emit(f"Error fetching script: {str(e)}")

class CodeShareBrowser(QWidget):
    script_selected = pyqtSignal(str)  # For injector
    open_in_injector = pyqtSignal(str)  # New signal for opening in injector
    favorites_updated = pyqtSignal()    # New signal for favorites updates
    
    def __init__(self):
        super().__init__()
        self.scripts_cache = {}
        self.api_url = "https://konsumer.js.org/frida-codeshare/codeshare.json"
        self.favorites = []  # Initialize as empty list
        self.load_favorites()
        self.setup_ui()
        
    def load_favorites(self):
        """Load favorites from file"""
        try:
            favorites_file = os.path.join(os.path.expanduser('~'), '.frida_gui', 'favorites.json')
            if os.path.exists(favorites_file):
                with open(favorites_file, 'r') as f:
                    data = json.load(f)
                    # Make sure we get a list, even if loading from a dict
                    if isinstance(data, dict):
                        self.favorites = data.get('favorites', [])
                    else:
                        self.favorites = data if isinstance(data, list) else []
            else:
                self.favorites = []
        except Exception as e:
            print(f"Error loading favorites: {e}")
            self.favorites = []
        
    def save_favorites(self):
        """Save favorites to file"""
        try:
            favorites_file = os.path.join(os.path.expanduser('~'), '.frida_gui', 'favorites.json')
            os.makedirs(os.path.dirname(favorites_file), exist_ok=True)
            with open(favorites_file, 'w') as f:
                # Save as a simple list
                json.dump(self.favorites, f)
        except Exception as e:
            print(f"Error saving favorites: {e}")
            
    def is_favorite(self, script_id):
        """Check if script is favorited"""
        return script_id in self.favorites
        
    def toggle_favorite(self, script_info):
        """Toggle favorite status of script"""
        script_id = script_info['id']
        if script_id in self.favorites:
            self.favorites.remove(script_id)
        else:
            self.favorites.append(script_id)
        self.save_favorites()
        self.refresh_favorites()
        self.favorites_updated.emit()  # Emit signal when favorites change
        
    def setup_ui(self):
        layout = QVBoxLayout(self)
        
        # Create tab widget
        self.tab_widget = QTabWidget()
        
        # Create tabs
        self.browse_tab = QWidget()
        self.favorites_tab = QWidget()
        
        self.setup_browse_tab()
        self.setup_favorites_tab()
        
        # Add tabs
        self.tab_widget.addTab(self.browse_tab, "Browse")
        self.tab_widget.addTab(self.favorites_tab, "★ Favorites")
        
        layout.addWidget(self.tab_widget)
        
        self.refresh_scripts()
        
    def setup_browse_tab(self):
        """Setup the browse tab (existing functionality)"""
        layout = QVBoxLayout(self.browse_tab)
        
        # Move existing toolbar and grid here
        toolbar = QHBoxLayout()
        
        # Search bar
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("⌕ Search scripts...")
        self.search_input.textChanged.connect(self.filter_scripts)
        
        # Category filter
        self.category_combo = QComboBox()
        self.category_combo.addItems(['All', 'Android', 'iOS', 'Windows', 'Linux', 'macOS'])
        self.category_combo.currentTextChanged.connect(self.filter_scripts)
        
        # Sort options
        self.sort_combo = QComboBox()
        self.sort_combo.addItems(['★ Most Popular', '👁 Most Viewed', '⏲ Latest'])
        self.sort_combo.currentTextChanged.connect(self.refresh_scripts)
        
        toolbar.addWidget(self.search_input)
        toolbar.addWidget(self.category_combo)
        toolbar.addWidget(self.sort_combo)
        
        # Grid layout for scripts
        self.grid_widget = QWidget()
        self.grid_layout = QGridLayout(self.grid_widget)
        self.grid_layout.setSpacing(10)
        
        # Scroll area for grid
        scroll = QScrollArea()
        scroll.setWidget(self.grid_widget)
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("""
            QScrollArea {
                border: none;
                background-color: #36393f;
            }
        """)
        
        # Add all components
        layout.addLayout(toolbar)
        layout.addWidget(scroll)
        
    def setup_favorites_tab(self):
        """Setup the favorites tab"""
        layout = QVBoxLayout(self.favorites_tab)
        
        # Create grid for favorite scripts
        self.favorites_grid = QWidget()
        self.favorites_grid_layout = QGridLayout(self.favorites_grid)
        self.favorites_grid_layout.setSpacing(10)
        
        # Scroll area for favorites
        scroll = QScrollArea()
        scroll.setWidget(self.favorites_grid)
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("""
            QScrollArea {
                border: none;
                background-color: #36393f;
            }
        """)
        
        # Add to layout
        layout.addWidget(scroll)
        
        # Initial population of favorites
        self.refresh_favorites()
        
    def refresh_favorites(self):
        """Refresh the favorites grid"""
        # Clear existing favorites grid
        for i in reversed(range(self.favorites_grid_layout.count())): 
            widget = self.favorites_grid_layout.itemAt(i).widget()
            if widget:
                widget.setParent(None)
            
        # Get favorite scripts
        try:
            # Get all scripts
            response = requests.get(self.api_url)
            all_scripts = response.json()
            
            # Filter to only favorited scripts
            favorite_scripts = [s for s in all_scripts if s['id'] in self.favorites]
            
            if favorite_scripts:
                # Add scripts to grid
                for idx, script_info in enumerate(favorite_scripts):
                    row = idx // 3
                    col = idx % 3
                    card = self.create_script_card(script_info)
                    self.favorites_grid_layout.addWidget(card, row, col)
            else:
                # Show message if no favorites
                msg = QLabel("No favorite scripts yet.\nBrowse scripts and click the ★ to add favorites!")
                msg.setAlignment(Qt.AlignCenter)
                msg.setStyleSheet("""
                    color: #b9bbbe;
                    font-size: 14px;
                    padding: 20px;
                """)
                self.favorites_grid_layout.addWidget(msg, 0, 0, 1, 3)
                
        except Exception as e:
            print(f"Error refreshing favorites: {e}")
            error_msg = QLabel(f"Error loading favorites: {str(e)}")
            error_msg.setStyleSheet("color: #ff4444;")
            self.favorites_grid_layout.addWidget(error_msg, 0, 0, 1, 3)

    def fetch_scripts(self):
        """Fetch scripts from API"""
        try:
            response = requests.get(self.api_url)
            scripts = response.json()
            
            # Sort scripts
            sort_option = self.sort_combo.currentText()
            if sort_option == 'Most Popular':
                scripts.sort(key=lambda x: x.get('likes', 0), reverse=True)
            elif sort_option == 'Most Viewed':
                scripts.sort(key=lambda x: x.get('seen', 0), reverse=True)
            
            return scripts
        except Exception as e:
            print(f"Error fetching scripts: {e}")
            return []
            
    def create_script_card(self, script_info):
        """Create a card widget for a script"""
        card = QFrame()
        card.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 8px;
                padding: 10px;
            }
            QFrame:hover {
                background-color: #40444b;
            }
            QLabel {
                color: white;
            }
        """)
        
        layout = QVBoxLayout(card)
        
        # Title
        title = QLabel(script_info['title'])
        title.setStyleSheet("font-size: 14px; font-weight: bold;")
        title.setWordWrap(True)
        
        # Author
        author = QLabel(f"by {script_info['author']}")
        author.setStyleSheet("color: #b9bbbe;")
        
        # Stats
        stats = QHBoxLayout()
        stars = QLabel(f"★ {script_info.get('likes', 0)}")
        views = QLabel(f"👁 {script_info.get('seen', 0)}")
        stats.addWidget(stars)
        stats.addWidget(views)
        
        # Description
        desc = QLabel(script_info.get('description', '')[:100] + '...')
        desc.setWordWrap(True)
        desc.setStyleSheet("color: #b9bbbe;")
        
        # Action buttons
        buttons = QHBoxLayout()
        
        view_btn = QPushButton("View")
        view_btn.clicked.connect(lambda: self.fetch_script_code(script_info))
        
        fav_btn = QPushButton()
        if self.is_favorite(script_info['id']):
            fav_btn.setIcon(QIcon())
            fav_btn.setText("★")
        else:
            fav_btn.setIcon(QIcon())
            fav_btn.setText("☆")
            fav_btn.setStyleSheet("color: #b9bbbe;")
        fav_btn.clicked.connect(lambda: self.toggle_favorite_ui(script_info, fav_btn))
        
        buttons.addWidget(view_btn)
        buttons.addWidget(fav_btn)
        buttons.addStretch()
        
        layout.addWidget(title)
        layout.addWidget(author)
        layout.addLayout(stats)
        layout.addWidget(desc)
        layout.addLayout(buttons)
        
        return card
        
    def fetch_script_code(self, script_info):
        """Fetch and show script code"""
        # Remove author name from ID if it's included
        script_id = script_info['id'].replace(f"{script_info['author']}/", "")
        url = f"https://codeshare.frida.re/@{script_info['author']}/{script_id}"
        print(f"Fetching script from: {url}")  # Debug print
        
        # Create preview dialog
        dialog = QDialog(self)
        dialog.setWindowTitle(f"Frida CodeShare - {script_info['title']}")
        dialog.resize(1000, 800)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #2f3136;
            }
            QLabel {
                color: white;
            }
            QPushButton {
                background-color: #7289da;
                color: white;
                padding: 8px 16px;
                border-radius: 4px;
                min-width: 100px;
            }
            QPushButton:hover {
                background-color: #677bc4;
            }
            QTextEdit {
                background-color: #36393f;
                color: #dcddde;
                border: none;
                border-radius: 4px;
                padding: 10px;
                font-family: 'Consolas', monospace;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        layout.setSpacing(15)
        
        # Header
        header = QHBoxLayout()
        title = QLabel(script_info['title'])
        title.setStyleSheet("font-size: 18px; font-weight: bold;")
        author = QLabel(f"by {script_info['author']}")
        author.setStyleSheet("color: #b9bbbe;")
        header.addWidget(title)
        header.addWidget(author)
        header.addStretch()
        
        # Stats
        stats = QHBoxLayout()
        likes = QLabel(f"★ {script_info.get('likes', 0)}")
        views = QLabel(f"👁 {script_info.get('seen', 0)}")
        stats.addWidget(likes)
        stats.addWidget(views)
        stats.addStretch()
        
        # Description
        desc = QLabel(script_info.get('description', ''))
        desc.setWordWrap(True)
        desc.setStyleSheet("color: #b9bbbe; padding: 10px;")
        
        # Code preview
        code_view = QTextEdit()
        code_view.setReadOnly(True)
        code_view.setFont(QFont('Consolas', 11))
        code_view.setLineWrapMode(QTextEdit.NoWrap)
        code_view.setText("Loading script...")
        
        # Usage instructions
        usage = QLabel(f"Try this code out by running:\n$ frida --codeshare {script_info['author']}/{script_info['id']} -f YOUR_BINARY")
        usage.setStyleSheet("""
            background-color: #202225;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
        """)
        
        # Action buttons
        buttons = QHBoxLayout()
        
        copy_btn = QPushButton(qta.icon('fa5s.copy'), "⎘ Copy Code")
        copy_btn.clicked.connect(lambda: self.copy_to_clipboard(code_view.toPlainText()))
        
        inject_btn = QPushButton(qta.icon('fa5s.syringe'), "⚡ Open in Injector")
        inject_btn.clicked.connect(lambda: self.open_in_injector_page(code_view.toPlainText(), dialog))
        
        download_btn = QPushButton(qta.icon('fa5s.download'), "⤓ Download")
        download_btn.clicked.connect(lambda: self.download_script(script_info['title'], code_view.toPlainText()))
        
        open_btn = QPushButton(qta.icon('fa5s.external-link-alt'), "⧉ Open in Browser")
        open_btn.clicked.connect(lambda: QDesktopServices.openUrl(QUrl(url)))
        
        buttons.addWidget(copy_btn)
        buttons.addWidget(inject_btn)
        buttons.addWidget(download_btn)
        buttons.addWidget(open_btn)
        buttons.addStretch()
        
        # Add all components
        layout.addLayout(header)
        layout.addLayout(stats)
        layout.addWidget(desc)
        layout.addWidget(usage)
        layout.addWidget(code_view)
        layout.addLayout(buttons)
        
        dialog.show()
        
        # Create and start the code fetcher thread
        self.code_fetcher = CodeFetcher(url)
        self.code_fetcher.code_fetched.connect(code_view.setText)
        self.code_fetcher.error_occurred.connect(lambda err: code_view.setText(f"Error loading script: {err}"))
        self.code_fetcher.start()

    def refresh_scripts(self):
        """Refresh scripts from API"""
        # Clear existing grid
        for i in reversed(range(self.grid_layout.count())): 
            self.grid_layout.itemAt(i).widget().setParent(None)
            
        # Fetch and sort scripts
        scripts = self.fetch_scripts()
        
        # Add all scripts to grid
        for idx, script_info in enumerate(scripts):
            row = idx // 3
            col = idx % 3
            card = self.create_script_card(script_info)
            self.grid_layout.addWidget(card, row, col)
            
        # Refresh favorites tab
        self.refresh_favorites()

    def add_script(self, script_info):
        """Add a script card to the grid"""
        # Calculate grid position
        count = self.grid_layout.count()
        row = count // 3
        col = count % 3
        
        # Create and add card
        card = self.create_script_card(script_info)
        self.grid_layout.addWidget(card, row, col)
        
        # Cache the script
        self.scripts_cache[script_info['id']] = script_info

    def filter_scripts(self):
        """Filter visible scripts based on search and category"""
        search_text = self.search_input.text().lower()
        category = self.category_combo.currentText()
        
        # Show/hide cards based on filters
        for i in range(self.grid_layout.count()):
            widget = self.grid_layout.itemAt(i).widget()
            if widget:
                title = widget.findChild(QLabel).text().lower()
                desc = widget.findChildren(QLabel)[-2].text().lower()  # Description label
                
                show = True
                if search_text and search_text not in title and search_text not in desc:
                    show = False
                if category != 'All' and category not in desc:
                    show = False
                    
                widget.setVisible(show)

    def copy_to_clipboard(self, text):
        """Copy text to clipboard"""
        clipboard = QApplication.clipboard()
        clipboard.setText(text)
        QMessageBox.information(self, "✓ Success", "⎘ Copied to clipboard!")

    def download_script(self, title, code):
        """Download script to file"""
        filename = f"{title.lower().replace(' ', '_')}.js"
        file_path, _ = QFileDialog.getSaveFileName(
            self, "⤓ Save Script", filename, "JavaScript Files (*.js)"
        )
        
        if file_path:
            try:
                with open(file_path, 'w') as f:
                    f.write(code)
                QMessageBox.information(self, "✓ Success", "⤓ Script downloaded successfully!")
            except Exception as e:
                QMessageBox.critical(self, "✗ Error", f"Failed to save script: {str(e)}")

    def toggle_favorite_ui(self, script_info, button):
        """Toggle favorite status and update UI"""
        self.toggle_favorite(script_info)
        if self.is_favorite(script_info['id']):
            button.setIcon(QIcon())
            button.setText("★")
        else:
            button.setIcon(QIcon())
            button.setText("☆")
            button.setStyleSheet("color: #b9bbbe;")
            
        # Refresh favorites tab when status changes
        self.refresh_favorites()

    def open_in_injector_page(self, code, dialog=None):
        """Open the script in the injector page"""
        self.open_in_injector.emit(code)  # Emit signal to main window
        if dialog:
            dialog.close()  # Close the preview dialog 
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\data_visualizer.py --- 
from PyQt5.QtWidgets import QWidget, QVBoxLayout
from PyQt5.QtChart import QChart, QChartView, QLineSeries
from PyQt5.QtCore import Qt, QTimer
import json

class DataVisualizer(QWidget):
    def __init__(self):
        super().__init__()
        self.setup_ui()
        self.api_calls = []
        self.setup_timer()
        
    def setup_ui(self):
        layout = QVBoxLayout(self)
        
        # Create chart
        self.chart = QChart()
        self.chart.setTitle("API Calls Over Time")
        self.chart.setAnimationOptions(QChart.SeriesAnimations)
        
        self.series = QLineSeries()
        self.chart.addSeries(self.series)
        
        chart_view = QChartView(self.chart)
        chart_view.setRenderHint(QPainter.Antialiasing)
        
        layout.addWidget(chart_view)
        
    def setup_timer(self):
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_chart)
        self.timer.start(1000)  # Update every second
        
    def add_api_call(self, call_data):
        self.api_calls.append({
            'timestamp': time.time(),
            'data': call_data
        })
        
    def update_chart(self):
        # Update chart with new data
        self.series.clear()
        for i, call in enumerate(self.api_calls[-50:]):  # Show last 50 calls
            self.series.append(i, len(call['data']))  
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\device_panel.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, 
                           QComboBox, QPushButton, QLabel)
from PyQt5.QtCore import pyqtSignal
import frida

class DevicePanel(QWidget):
    device_selected = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.setup_ui()
        
    def setup_ui(self):
        layout = QHBoxLayout(self)
        
        # Device selection combo box
        self.device_combo = QComboBox()
        self.scan_button = QPushButton("Scan Devices")
        
        layout.addWidget(QLabel("Select Device:"))
        layout.addWidget(self.device_combo)
        layout.addWidget(self.scan_button)
        
        # Connect signals
        self.scan_button.clicked.connect(self.scan_devices)
        self.device_combo.currentIndexChanged.connect(self._on_device_selected)
        
        # Initial scan
        self.scan_devices()
        
    def scan_devices(self):
        try:
            self.device_combo.clear()
            devices = frida.enumerate_devices()
            for device in devices:
                if device.type in ['usb', 'remote']:
                    self.device_combo.addItem(f"{device.name} (ADB - {device.type})", device.id)
                elif device.type == 'local':
                    self.device_combo.addItem(f"{device.name} (Local)", device.id)
        except Exception as e:
            print(f"Error scanning devices: {str(e)}")
            
    def _on_device_selected(self):
        device_id = self.device_combo.currentData()
        if device_id:
            self.device_selected.emit(device_id)  
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\device_selector.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QComboBox,
                           QPushButton, QLabel, QFrame, QLineEdit, QMessageBox,
                           QApplication, QDialog, QListWidget, QListWidgetItem,
                           QDialogButtonBox, QFileDialog, QTextEdit, QCheckBox,
                           QFormLayout, QGroupBox)
from PyQt5.QtWidgets import (QPushButton, QListWidget, QHBoxLayout, QVBoxLayout,
                             QLabel, QDialog, QDialogButtonBox, QFileDialog,
                             QTextEdit, QCheckBox, QFormLayout, QGroupBox)                           
from PyQt5.QtCore import pyqtSignal, Qt
from PyQt5.QtGui import QFont

import frida
import subprocess
import qtawesome as qta
import sys
from pathlib import Path
import os

# Add project root to Python path
sys.path.append(str(Path(__file__).parent.parent.parent))
from core.android_helper import AndroidHelper


class DeviceSelector(QWidget):
    process_selected = pyqtSignal(str, int)  # device_id, pid
    application_selected_for_spawn = pyqtSignal(str, str, list, str)  # device, pkg, [scripts], options

    def __init__(self):
        super().__init__()
        self.current_device = None
        self.process_list = []
        self.applications = []
        self.script_files = []
        self.frida_spawn_options = ""
        self.setup_ui()

    def setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        frame = QFrame()
        frame.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 8px;
                padding: 10px;
            }
            QComboBox {
                background-color: #36393f;
                border: none;
                border-radius: 4px;
                padding: 8px;
                color: white;
                min-width: 200px;
            }
            QComboBox::drop-down {
                border: none;
                padding-right: 10px;
            }
        """)
        frame_layout = QVBoxLayout(frame)

        # Device selection
        device_layout = QHBoxLayout()
        self.device_combo = QComboBox()
        self.device_combo.setPlaceholderText("Select Device...")
        self.device_combo.currentIndexChanged.connect(self.on_device_changed)

        refresh_btn = QPushButton(qta.icon('fa5s.sync'), "")
        refresh_btn.setToolTip("Refresh Devices")
        refresh_btn.clicked.connect(self.refresh_devices)

        device_layout.addWidget(QLabel("Device:"))
        device_layout.addWidget(self.device_combo, 1)
        device_layout.addWidget(refresh_btn)
        frame_layout.addLayout(device_layout)

        # Process / Spawn row
        process_spawn_layout = QHBoxLayout()

        self.process_filter = QLineEdit()
        self.process_filter.setPlaceholderText("Filter running processes...")
        self.process_filter.textChanged.connect(self.filter_processes)

        self.process_combo = QComboBox()
        self.process_combo.setPlaceholderText("Attach to Process...")
        self.process_combo.currentIndexChanged.connect(self.on_process_changed)
        self.process_combo.setMaxVisibleItems(20)
        self.process_combo.setStyleSheet("QComboBox QListView { min-width: 300px; }")

        refresh_proc_btn = QPushButton(qta.icon('fa5s.sync'), "")
        refresh_proc_btn.setToolTip("Refresh Running Processes")
        refresh_proc_btn.clicked.connect(self.refresh_processes)

        self.spawn_app_btn = QPushButton(qta.icon('fa5s.rocket'), " Spawn App...")
        self.spawn_app_btn.setToolTip("Select an installed application to spawn")
        self.spawn_app_btn.clicked.connect(self.show_spawn_dialog)
        self.spawn_app_btn.setEnabled(False)

        self.frida_opts_btn = QPushButton(qta.icon('fa5s.cog'), " Frida Options")
        self.frida_opts_btn.setToolTip("Configure Frida spawn command line options")
        self.frida_opts_btn.clicked.connect(self.show_frida_options_dialog)
        self.frida_opts_btn.setEnabled(False)

        process_spawn_layout.addWidget(QLabel("Process:"))
        process_spawn_layout.addWidget(self.process_filter)
        process_spawn_layout.addWidget(self.process_combo, 1)
        process_spawn_layout.addWidget(refresh_proc_btn)
        process_spawn_layout.addWidget(self.spawn_app_btn)
        process_spawn_layout.addWidget(self.frida_opts_btn)

        frame_layout.addLayout(process_spawn_layout)
        layout.addWidget(frame)

        self.refresh_devices()

    def refresh_devices(self):
        self.device_combo.clear()
        try:
            devices = frida.enumerate_devices()
            for device in devices:
                if device.type == 'usb':
                    self.device_combo.addItem(f"{device.name} (USB)", device.id)
        except Exception as e:
            print(f"Error enumerating devices: {e}")
        finally:
            if self.device_combo.count() > 0:
                self.device_combo.setCurrentIndex(0)

    def on_device_changed(self, index):
        if index < 0:
            self.current_device = None
            self.applications = []
            self.spawn_app_btn.setEnabled(False)
            self.frida_opts_btn.setEnabled(False)
            self.refresh_processes()
            return

        device_id = self.device_combo.currentData()
        self.current_device = device_id
        self.refresh_applications()
        self.refresh_processes()
        self.spawn_app_btn.setEnabled(True)
        self.frida_opts_btn.setEnabled(True)

    def refresh_applications(self):
        self.applications = []
        if not self.current_device:
            self.spawn_app_btn.setEnabled(False)
            return

        print(f"[DeviceSelector] Refreshing applications for {self.current_device}...")
        try:
            device = frida.get_device(self.current_device)
            if device.type != 'usb':
                print(f"[DeviceSelector] Spawning only supported for USB devices.")
                self.spawn_app_btn.setEnabled(False)
                return

            raw_apps = device.enumerate_applications()
            user_apps = []
            for app in raw_apps:
                if app.identifier and '.' in app.identifier:
                    user_apps.append({'name': app.name, 'identifier': app.identifier})

            user_apps.sort(key=lambda x: x['name'].lower())
            self.applications = user_apps
            print(f"[DeviceSelector] Found {len(self.applications)} user applications.")
            self.spawn_app_btn.setEnabled(len(self.applications) > 0)

        except frida.ServerNotRunningError:
            QMessageBox.warning(self, "Server Error", f"Frida server not running on {self.current_device}.")
            self.spawn_app_btn.setEnabled(False)
        except frida.TransportError:
            QMessageBox.warning(self, "Device Error", f"Device {self.current_device} disconnected.")
            self.spawn_app_btn.setEnabled(False)
        except Exception as e:
            print(f"[DeviceSelector] Error refreshing applications: {e}")
            self.spawn_app_btn.setEnabled(False)

    def refresh_processes(self):
        self.process_combo.clear()
        self.process_list.clear()

        if not self.current_device:
            return

        try:
            device = frida.get_device(self.current_device)
            if device.type == 'usb':
                self.process_combo.addItem("Checking device status...")
                QApplication.processEvents()

                if not AndroidHelper.is_device_connected(self.current_device):
                    raise Exception(f"Device {self.current_device} not connected")

                if not AndroidHelper.is_frida_running(self.current_device):
                    QMessageBox.warning(self, "Server Error",
                                        f"Frida server is not running on {self.current_device}.")
                    self.process_combo.clear()
                    self.process_combo.addItem("Frida server not running")
                    return

                self.process_combo.clear()
                processes = device.enumerate_processes()
                processes.sort(key=lambda p: p.name.lower() if p.name else "")
                for process in processes:
                    if process.pid > 0 and process.name:
                        self.process_list.append({'name': process.name, 'pid': process.pid})

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to refresh processes: {e}")
            self.process_combo.clear()
            self.process_combo.addItem("Error loading processes")

        self.filter_processes(self.process_filter.text())

    def filter_processes(self, text):
        search_text = text.lower()
        self.process_combo.clear()
        if not self.current_device:
            return

        items_added = 0
        for process in self.process_list:
            if search_text in process['name'].lower():
                self.process_combo.addItem(f"{process['name']} (PID: {process['pid']})", process['pid'])
                items_added += 1

        if items_added == 0 and search_text:
            self.process_combo.setPlaceholderText("No matches found")
        elif not search_text:
            self.process_combo.setPlaceholderText("Attach to Process...")

    def on_process_changed(self, index):
        if index < 0:
            return
        try:
            device_id = self.device_combo.currentData()
            pid = self.process_combo.currentData()
            if pid is None:
                return
            pid = int(pid)
            if device_id and pid > 0:
                self.process_selected.emit(device_id, pid)
        except Exception as e:
            print(f"Error in process selection: {e}")

    def show_spawn_dialog(self):
        if not self.current_device:
            QMessageBox.warning(self, "No Device", "Please select a device first.")
            return
        if not self.applications:
            QMessageBox.information(self, "No Apps", "No user applications found. Refreshing...")
            self.refresh_applications()
            if not self.applications:
                QMessageBox.warning(self, "No Apps", "Could not find any user applications to spawn.")
                return

        # --- Application selector dialog ---
        dialog = QDialog(self)
        dialog.setWindowTitle("Select Application to Spawn")
        layout = QVBoxLayout(dialog)

        filter_edit = QLineEdit()
        filter_edit.setPlaceholderText("Filter applications...")
        list_widget = QListWidget()
        list_widget.setStyleSheet("QListWidget::item { padding: 5px; }")

        def populate_list(text=""):
            list_widget.clear()
            fl = text.lower()
            for app in self.applications:
                if fl in app['name'].lower() or fl in app['identifier'].lower():
                    item = QListWidgetItem(f"{app['name']} ({app['identifier']})")
                    item.setData(Qt.UserRole, app['identifier'])
                    list_widget.addItem(item)

        filter_edit.textChanged.connect(populate_list)
        populate_list()
        list_widget.itemDoubleClicked.connect(dialog.accept)

        btn_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        btn_box.accepted.connect(dialog.accept)
        btn_box.rejected.connect(dialog.reject)

        layout.addWidget(QLabel("Select an application:"))
        layout.addWidget(filter_edit)
        layout.addWidget(list_widget)
        layout.addWidget(btn_box)

        if dialog.exec_() != QDialog.Accepted:
            return

        selected = list_widget.currentItem()
        if not selected:
            return
        app_identifier = selected.data(Qt.UserRole)
        print(f"[DeviceSelector] Spawning app selected: {app_identifier}")

        # --- Script input dialog ---
        script_dialog = QDialog(self)
        script_dialog.setWindowTitle(f"Scripts for {app_identifier}")
        script_dialog.setMinimumSize(700, 500)
        dlg_layout = QVBoxLayout(script_dialog)

        # Top: Buttons
        btn_layout = QHBoxLayout()
        add_btn = QPushButton(qta.icon('fa5s.plus'), " Add Script")
        remove_btn = QPushButton(qta.icon('fa5s.trash'), " Remove")
        up_btn = QPushButton(qta.icon('fa5s.arrow-up'), "")
        down_btn = QPushButton(qta.icon('fa5s.arrow-down'), "")

        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(remove_btn)
        btn_layout.addWidget(up_btn)
        btn_layout.addWidget(down_btn)
        btn_layout.addStretch()

        # Script list
        script_list = QListWidget()
        script_list.setDragDropMode(QListWidget.InternalMove)
        script_list.setSelectionMode(QListWidget.SingleSelection)

        # Bottom: OK/Cancel
        btn_box2 = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        btn_box2.accepted.connect(script_dialog.accept)
        btn_box2.rejected.connect(script_dialog.reject)

        ok_btn = btn_box2.button(QDialogButtonBox.Ok)
        ok_btn.setEnabled(False)

        # --- Functions ---
        def update_ok_button():
            ok_btn.setEnabled(script_list.count() > 0)

        def add_script():
            paths, _ = QFileDialog.getOpenFileNames(
                script_dialog, "Select Frida Scripts", "",
                "JavaScript Files (*.js);;All Files (*.*)"
            )
            for path in paths:
                # Avoid duplicates
                if path not in [script_list.item(i).data(Qt.UserRole) for i in range(script_list.count())]:
                    item = QListWidgetItem(os.path.basename(path))
                    item.setData(Qt.UserRole, path)
                    item.setToolTip(path)
                    script_list.addItem(item)
            update_ok_button()

        def remove_script():
            for item in script_list.selectedItems():
                script_list.takeItem(script_list.row(item))
            update_ok_button()

        def move_up():
            row = script_list.currentRow()
            if row > 0:
                item = script_list.takeItem(row)
                script_list.insertItem(row - 1, item)
                script_list.setCurrentRow(row - 1)

        def move_down():
            row = script_list.currentRow()
            if row < script_list.count() - 1:
                item = script_list.takeItem(row)
                script_list.insertItem(row + 1, item)
                script_list.setCurrentRow(row + 1)

        # Connect signals
        add_btn.clicked.connect(add_script)
        remove_btn.clicked.connect(remove_script)
        up_btn.clicked.connect(move_up)
        down_btn.clicked.connect(move_down)
        script_list.itemSelectionChanged.connect(
            lambda: remove_btn.setEnabled(bool(script_list.selectedItems()))
        )

        # Layout
        dlg_layout.addLayout(btn_layout)
        dlg_layout.addWidget(QLabel("Scripts will run in order (top to bottom):"))
        dlg_layout.addWidget(script_list)
        dlg_layout.addWidget(btn_box2)

        if script_dialog.exec_() != QDialog.Accepted:
            print("[DeviceSelector] Script selection cancelled.")
            return

        if script_list.count() == 0:
            QMessageBox.warning(self, "No Scripts", "Please add at least one script.")
            return

        # Extract ordered script paths
        self.script_files = [
            script_list.item(i).data(Qt.UserRole)
            for i in range(script_list.count())
        ]

        spawn_opts = getattr(self, "frida_spawn_options", "")
        self.application_selected_for_spawn.emit(
            self.current_device, app_identifier, self.script_files, spawn_opts
        )
        print("[DeviceSelector] Script accepted and signal emitted.")

    def show_frida_options_dialog(self):
        dlg = QDialog(self)
        dlg.setWindowTitle("Frida Spawn Options")
        dlg.setMinimumWidth(580)
        layout = QVBoxLayout(dlg)

        # Common switches
        common_group = QGroupBox("Common switches")
        common_layout = QVBoxLayout(common_group)
        self.pause_chk = QCheckBox("--pause   (do not resume after spawn)")
        self.debug_chk = QCheckBox("-d        (enable debugging)")
        self.device_chk = QCheckBox("-D <id>   (specify device, auto-filled)")
        self.output_chk = QCheckBox("-O <file> (write output to file)")
        self.stdio_chk = QCheckBox("--stdio  (inherit stdin/stdout)")

        for chk in (self.pause_chk, self.debug_chk, self.device_chk, self.output_chk, self.stdio_chk):
            common_layout.addWidget(chk)
        layout.addWidget(common_group)

        # Custom flags
        extra_group = QGroupBox("Custom flags (order matters)")
        extra_layout = QFormLayout(extra_group)
        self.extra1_edit = QLineEdit()
        self.extra1_edit.setPlaceholderText("e.g. --runtime=v8")
        self.extra2_edit = QLineEdit()
        self.extra2_edit.setPlaceholderText("e.g. --no-pause")
        extra_layout.addRow("Extra flag 1:", self.extra1_edit)
        extra_layout.addRow("Extra flag 2:", self.extra2_edit)
        layout.addWidget(extra_group)

        # Known flags
        known_text = QTextEdit()
        known_text.setReadOnly(True)
        known_text.setMinimumHeight(180)
        known_text.setFont(QFont("Consolas", 9))

        if not hasattr(self, "_frida_help_cache"):
            try:
                self._frida_help_cache = subprocess.check_output(
                    ["frida", "--help"], stderr=subprocess.STDOUT, text=True
                )
            except Exception as e:
                self._frida_help_cache = f"Could not run `frida --help`: {e}"
        known_text.setPlainText(self._frida_help_cache)
        layout.addWidget(QLabel("<b>Known Frida CLI flags (from `frida --help`)</b>"))
        layout.addWidget(known_text)

        # Buttons
        btn_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        btn_box.accepted.connect(dlg.accept)
        btn_box.rejected.connect(dlg.reject)
        layout.addWidget(btn_box)

        # Restore previous options
        if self.frida_spawn_options:
            self._apply_options_to_widgets(self.frida_spawn_options)

        if dlg.exec_() != QDialog.Accepted:
            return

        opts = []
        if self.pause_chk.isChecked():   opts.append("--pause")
        if self.debug_chk.isChecked():   opts.append("-d")
        if self.device_chk.isChecked():  opts.append(f"-D {self.current_device}")
        if self.output_chk.isChecked():  opts.append("-O")
        if self.stdio_chk.isChecked():   opts.append("--stdio")
        if self.extra1_edit.text().strip(): opts.append(self.extra1_edit.text().strip())
        if self.extra2_edit.text().strip(): opts.append(self.extra2_edit.text().strip())

        self.frida_spawn_options = " ".join(opts)
        self.frida_opts_btn.setIcon(qta.icon('fa5s.cog'))
        self.frida_opts_btn.setText(f"Frida Options ({len(opts)})")
        print(f"[DeviceSelector] Frida spawn options set: {self.frida_spawn_options}")

        
    def _apply_options_to_widgets(self, option_str: str):
        parts = option_str.split()
        i = 0
        while i < len(parts):
            flag = parts[i]
            if flag == "--pause": self.pause_chk.setChecked(True)
            elif flag == "-d": self.debug_chk.setChecked(True)
            elif flag == "--stdio": self.stdio_chk.setChecked(True)
            elif flag.startswith("-D"): self.device_chk.setChecked(True); i += 1
            elif flag.startswith("-O"): self.output_chk.setChecked(True)
            else:
                if not self.extra1_edit.text(): self.extra1_edit.setText(flag)
                elif not self.extra2_edit.text(): self.extra2_edit.setText(flag)
            i += 1

    def get_selected_process_info(self):
        try:
            index = self.process_combo.currentIndex()
            if index >= 0:
                device_id = self.device_combo.currentData()
                pid = self.process_combo.currentData()
                name = self.process_combo.currentText().split('(')[0].strip()
                if device_id and pid:
                    return {'device_id': device_id, 'pid': pid, 'name': name}
        except Exception as e:
            print(f"Error getting process info: {e}")
        return None

    def select_device(self, device_id):
        index = self.device_combo.findData(device_id)
        if index >= 0:
            self.device_combo.setCurrentIndex(index)

    def select_process(self, pid):
        for i in range(self.process_combo.count()):
            item_data = self.process_combo.itemData(i)
            if item_data and int(item_data) == int(pid):
                self.process_combo.setCurrentIndex(i)
                break

    def cleanup(self):
        self.process_combo.clear()
        self.device_combo.clear()
        self.current_device = None
        self.process_list = []
        self.applications = []
        self.frida_spawn_options = "" 
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\history_page.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
                           QLabel, QTableWidget, QTableWidgetItem, QHeaderView,
                           QMenu, QMessageBox)
from PyQt5.QtCore import Qt, pyqtSignal
import qtawesome as qta
from datetime import datetime

class HistoryPage(QWidget):
    script_selected = pyqtSignal(str)  # For opening scripts in injector
    
    def __init__(self, history_manager):
        super().__init__()
        self.history_manager = history_manager
        self.setup_ui()
        
    def setup_ui(self):
        layout = QVBoxLayout(self)
        
        # Header with title and clear button
        header_layout = QHBoxLayout()
        title = QLabel("Action History")
        title.setStyleSheet("font-size: 18px; font-weight: bold; color: white;")
        
        clear_btn = QPushButton(qta.icon('fa5s.trash'), "Clear History")
        clear_btn.clicked.connect(self.clear_history)
        
        header_layout.addWidget(title)
        header_layout.addStretch()
        header_layout.addWidget(clear_btn)
        
        # History table
        self.table = QTableWidget()
        self.table.setColumnCount(4)
        self.table.setHorizontalHeaderLabels(["Time", "Action", "Details", "Actions"])
        
        # Style the table
        self.table.setStyleSheet("""
            QTableWidget {
                background-color: #36393f;
                border: none;
                border-radius: 8px;
            }
            QTableWidget::item {
                padding: 8px;
                border-bottom: 1px solid #2f3136;
            }
            QHeaderView::section {
                background-color: #2f3136;
                padding: 8px;
                border: none;
                color: white;
                font-weight: bold;
            }
        """)
        
        # Set column stretching
        table_header = self.table.horizontalHeader()
        table_header.setSectionResizeMode(0, QHeaderView.Fixed)    # Time
        table_header.setSectionResizeMode(1, QHeaderView.Fixed)    # Action
        table_header.setSectionResizeMode(2, QHeaderView.Stretch)  # Details
        table_header.setSectionResizeMode(3, QHeaderView.Fixed)    # Actions
        
        self.table.setColumnWidth(0, 180)  # Time
        self.table.setColumnWidth(1, 120)  # Action
        self.table.setColumnWidth(3, 100)  # Actions
        
        # Context menu
        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.show_context_menu)
        
        # Add components to layout
        layout.addLayout(header_layout)
        layout.addWidget(self.table)
        
        self.refresh_history()
        
    def refresh_history(self):
        self.table.setRowCount(0)
        
        for entry in self.history_manager.history:
            row = self.table.rowCount()
            self.table.insertRow(row)
            
            # Time
            time_item = QTableWidgetItem(
                datetime.fromisoformat(entry['timestamp']).strftime('%Y-%m-%d %H:%M:%S')
            )
            
            # Action
            action_item = QTableWidgetItem(entry['type'])
            
            # Details
            details = entry['details']
            if isinstance(details, dict):
                details_text = "\n".join(f"{k}: {v}" for k, v in details.items())
            else:
                details_text = str(details)
            details_item = QTableWidgetItem(details_text)
            
            # Action buttons
            action_widget = QWidget()
            action_layout = QHBoxLayout(action_widget)
            action_layout.setContentsMargins(4, 4, 4, 4)
            
            if 'script' in entry['details']:
                inject_btn = QPushButton(qta.icon('fa5s.syringe'), "")
                inject_btn.clicked.connect(
                    lambda x, s=entry['details']['script']: self.script_selected.emit(s)
                )
                action_layout.addWidget(inject_btn)
                
            action_layout.addStretch()
            
            # Add items to row
            self.table.setItem(row, 0, time_item)
            self.table.setItem(row, 1, action_item)
            self.table.setItem(row, 2, details_item)
            self.table.setCellWidget(row, 3, action_widget)
            
    def clear_history(self):
        reply = QMessageBox.question(
            self,
            "Clear History",
            "Are you sure you want to clear all history?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            self.history_manager.clear_history()
            self.refresh_history()
            
    def show_context_menu(self, position):
        menu = QMenu()
        
        copy_action = menu.addAction("Copy Details")
        copy_action.triggered.connect(
            lambda: self.copy_details(self.table.currentRow())
        )
        
        menu.exec_(self.table.viewport().mapToGlobal(position))
        
    def copy_details(self, row):
        if row >= 0:
            details_item = self.table.item(row, 2)
            if details_item:
                clipboard = QApplication.clipboard()
                clipboard.setText(details_item.text())  
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\injection_panel.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
                           QLabel, QProgressBar, QFrame, QMessageBox, QFileDialog,
                           QTextEdit, QApplication) # Added QApplication
from PyQt5.QtCore import Qt, pyqtSignal
import qtawesome as qta
import os # Added os import

class InjectionPanel(QWidget):
    # Signals remain the same
    injection_started = pyqtSignal(str, int)  # script, pid
    # This signal wasn't really used by MainWindow, keep for consistency or future use
    injection_completed = pyqtSignal(bool, str)
    injection_stopped = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.current_pid = None
        self.current_device_id = None
        # Reference to the actual QTextEdit from ScriptEditorPanel, set by MainWindow
        self.script_editor_widget = None # THIS WILL HOLD THE REFERENCE
        self.setup_ui()

    def setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 0, 5, 5) # Adjusted margins
        layout.setSpacing(8) # Added spacing

        # Status panel
        status_frame = QFrame()
        status_frame.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 8px;
                padding: 8px 12px; /* Adjusted padding */
            }
        """)
        status_layout = QHBoxLayout(status_frame)
        status_layout.setContentsMargins(0,0,0,0) # No internal margins for HBox

        self.status_icon = QLabel()
        self.status_icon.setPixmap(qta.icon('fa5s.circle', color='#99aab5').pixmap(14, 14)) # Slightly smaller icon
        self.status_label = QLabel("No process selected")
        self.status_label.setStyleSheet("color: #99aab5; margin-left: 5px;") # Add margin

        status_layout.addWidget(self.status_icon)
        status_layout.addWidget(self.status_label)
        status_layout.addStretch()

        # Action buttons layout
        button_layout = QHBoxLayout()
        button_layout.setSpacing(6) # Spacing between buttons

        # Load Script Button
        self.load_btn = QPushButton(qta.icon('fa5s.folder-open', color='white'), " Load")
        self.load_btn.clicked.connect(self.load_script_file)
        self.load_btn.setToolTip("Load script from .js file")
        self.load_btn.setStyleSheet("padding: 5px 10px; background-color: #5865f2; border: none; border-radius: 4px; color: white;")

        # Clear Button (Added)
        self.clear_btn = QPushButton(qta.icon('fa5s.trash-alt', color='white'), " Clear")
        self.clear_btn.clicked.connect(self.clear_script)
        self.clear_btn.setToolTip("Clear the script editor")
        self.clear_btn.setStyleSheet("padding: 5px 10px; background-color: #4f545c; border: none; border-radius: 4px; color: white;") # Greyish button

        # Inject Button (Modified name, Execute -> Inject)
        self.inject_btn = QPushButton(qta.icon('fa5s.syringe', color='white'), " Inject") # Changed icon too
        self.inject_btn.clicked.connect(self.execute_script) # Function remains execute_script
        self.inject_btn.setToolTip("Inject the current script into the selected process")
        self.inject_btn.setEnabled(False) # Disable initially
        self.inject_btn.setStyleSheet("""
            QPushButton { background-color: #43b581; color: white; padding: 5px 10px; border: none; border-radius: 4px; font-weight: bold; }
            QPushButton:hover { background-color: #3ca374; }
            QPushButton:disabled { background-color: #2f3136; color: #72767d; }
        """)

        # Stop Button
        self.stop_btn = QPushButton(qta.icon('fa5s.stop', color='white'), " Stop")
        self.stop_btn.clicked.connect(self.stop_injection)
        self.stop_btn.setToolTip("Stop the currently injected script")
        self.stop_btn.setEnabled(False) # Disable initially
        self.stop_btn.setStyleSheet("""
            QPushButton { background-color: #f04747; color: white; padding: 5px 10px; border: none; border-radius: 4px; font-weight: bold; }
            QPushButton:hover { background-color: #d84040; }
            QPushButton:disabled { background-color: #2f3136; color: #72767d; }
        """)

        button_layout.addWidget(self.load_btn)
        button_layout.addWidget(self.clear_btn)
        button_layout.addStretch() # Add stretch before inject/stop
        button_layout.addWidget(self.inject_btn)
        button_layout.addWidget(self.stop_btn)

        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setTextVisible(False)
        self.progress_bar.setFixedHeight(6) # Make it thinner
        self.progress_bar.setStyleSheet("""
            QProgressBar {
                border: none;
                background-color: #2f3136;
                border-radius: 3px; /* Match height */
                text-align: center;
            }
            QProgressBar::chunk {
                background-color: #7289da; /* Blue chunk */
                border-radius: 3px;
            }
        """)
        self.progress_bar.hide()

        # Add widgets to main layout
        layout.addWidget(status_frame)
        # Note: The actual script editor (from ScriptEditorPanel) is part of MainWindow's layout
        layout.addLayout(button_layout)
        layout.addWidget(self.progress_bar)

    def set_script_editor_widget(self, editor_widget: QTextEdit): # Added type hint
        """Sets the reference to the QTextEdit widget from ScriptEditorPanel."""
        self.script_editor_widget = editor_widget
        print("[InjectionPanel] Script editor widget reference set.")

    def clear_script(self):
        """Clears the script editor content."""
        if self.script_editor_widget:
            self.script_editor_widget.clear()
            print("[InjectionPanel] Script editor cleared.")
        else:
            print("[InjectionPanel] Error: Script editor reference not set.")
            QMessageBox.warning(self, "Internal Error", "Script editor reference not found.")

    def load_script_file(self):
        """Loads script content from a file into the editor."""
        if not self.script_editor_widget:
            QMessageBox.critical(self, "Internal Error", "Script editor reference not set.")
            return

        # Use os.path.expanduser('~') as a potential starting directory
        #start_dir = os.path.expanduser('~')
        start_dir = os.getcwd()
        file_name, _ = QFileDialog.getOpenFileName(
            self,
            "Load Frida Script",
            start_dir,
            "JavaScript Files (*.js);;All Files (*.*)"
        )

        if file_name:
            try:
                # Use UTF-8 encoding for broader compatibility
                with open(file_name, 'r', encoding='utf-8') as f:
                    script_content = f.read()
                self.script_editor_widget.setPlainText(script_content)
                self.status_label.setText(f"Loaded: {os.path.basename(file_name)}")
                self.status_icon.setPixmap(qta.icon('fa5s.circle', color='#99aab5').pixmap(14, 14)) # Grey
                print(f"[InjectionPanel] Loaded script: {file_name}")
            except Exception as e:
                error_msg = f"Failed to load script: {str(e)}"
                print(f"[InjectionPanel] {error_msg}")
                QMessageBox.critical(self, "File Load Error", error_msg)

    def execute_script(self):
        """Validates and emits signal to start script injection."""
        if not self.script_editor_widget:
             QMessageBox.critical(self, "Internal Error", "Script editor reference not set.")
             return

        script_content = self.script_editor_widget.toPlainText()
        if not script_content.strip(): # Check if script is just whitespace
            QMessageBox.warning(self, "Input Error", "Script is empty! Please load or enter a script.")
            return

        if not self.current_pid or not self.current_device_id:
            QMessageBox.warning(self, "Input Error", "No process selected. Please select a device and process first.")
            return

        print(f"[InjectionPanel] Attempting to inject script into PID: {self.current_pid} on device: {self.current_device_id}")

        # Update UI to indicate injection attempt
        self.status_icon.setPixmap(qta.icon('fa5s.spinner', color='#faa61a', animation=qta.Spin(self.status_icon)).pixmap(14, 14)) # Spinning Yellow
        self.status_label.setText(f"Injecting into PID: {self.current_pid}...")
        self._set_buttons_state(injecting=True)
        self.progress_bar.show()
        self.progress_bar.setRange(0, 0) # Indeterminate

        try:
            # Emit the signal for MainWindow to handle the actual Frida logic
            self.injection_started.emit(script_content, self.current_pid)
        except Exception as e:
            # Handle potential errors during signal emission itself (less likely)
            error_msg = f"Internal error starting injection process: {str(e)}"
            print(f"[InjectionPanel] {error_msg}")
            self.injection_failed(error_msg) # Update UI to failed state

    def stop_injection(self):
        """Emits signal to stop the current script."""
        if not self.current_pid or not self.current_device_id:
             # Should ideally not happen if button state is managed correctly, but check anyway
             print("[InjectionPanel] Stop clicked but no active PID/Device known.")
             self._set_buttons_state(process_selected=False) # Reset buttons if state is inconsistent
             return

        print(f"[InjectionPanel] Attempting to stop script for PID: {self.current_pid} on device: {self.current_device_id}")
        self.status_label.setText(f"Stopping script in PID: {self.current_pid}...")
        self.status_icon.setPixmap(qta.icon('fa5s.spinner', color='#faa61a', animation=qta.Spin(self.status_icon)).pixmap(14, 14)) # Spinning Yellow
        self._set_buttons_state(stopping=True) # Disable stop, keep others disabled
        self.progress_bar.show()
        self.progress_bar.setRange(0, 0)

        self.injection_stopped.emit() # Signal MainWindow to detach/unload

    #@pyqtSlot(str, int) # Add decorator for clarity
    def set_process(self, device_id, pid):
        """Updates the selected process and device ID. Called by MainWindow."""
        # Check if pid is None or invalid before trying int()
        if pid is None:
            print("[InjectionPanel] set_process called with PID=None. Resetting state.")
            self.current_pid = None
            self.current_device_id = device_id # Still keep device ID if provided
            self.status_label.setText("No process selected" if device_id else "No device or process selected")
            self.status_icon.setPixmap(qta.icon('fa5s.circle', color='#99aab5').pixmap(14, 14)) # Grey
            self._set_buttons_state(process_selected=False)
            return

        try:
            pid_int = int(pid)
            if pid_int <= 0:
                 raise ValueError("PID must be positive.")

            self.current_pid = pid_int
            self.current_device_id = device_id
            self.status_label.setText(f"Selected PID: {self.current_pid}") # Keep it concise
            self.status_icon.setPixmap(qta.icon('fa5s.circle', color='#43b581').pixmap(14, 14)) # Green
            self._set_buttons_state(process_selected=True)
            print(f"[InjectionPanel] Process set: PID={self.current_pid}, Device={self.current_device_id}")

        except (ValueError, TypeError) as e:
            print(f"[InjectionPanel] Error setting process: Invalid PID '{pid}'. {e}")
            self.current_pid = None
            self.current_device_id = device_id
            self.status_label.setText(f"Invalid PID")
            self.status_icon.setPixmap(qta.icon('fa5s.circle', color='#f04747').pixmap(14, 14)) # Red
            self._set_buttons_state(process_selected=False)

    # --- Methods called by MainWindow for feedback ---
    def injection_succeeded(self):
        """Updates UI when injection is confirmed successful."""
        print(f"[InjectionPanel] Injection succeeded for PID {self.current_pid}")
        self.status_icon.setPixmap(qta.icon('fa5s.check-circle', color='#43b581').pixmap(14, 14)) # Green Check
        self.status_label.setText(f"Script running in PID: {self.current_pid}")
        self._set_buttons_state(script_running=True)
        self.progress_bar.hide()
        self.progress_bar.setRange(0, 1)

    def injection_failed(self, error_message="Unknown error"):
        """Updates UI when injection fails."""
        print(f"[InjectionPanel] Injection failed for PID {self.current_pid}: {error_message}")
        self.status_icon.setPixmap(qta.icon('fa5s.times-circle', color='#f04747').pixmap(14, 14)) # Red X
        status_text = f"Injection failed"
        if self.current_pid:
            status_text += f": PID {self.current_pid}"
        self.status_label.setText(status_text)
        # Re-enable inject button only if a valid process is still technically selected
        self._set_buttons_state(process_selected=bool(self.current_pid))
        self.progress_bar.hide()
        self.progress_bar.setRange(0, 1)
        # MainWindow shows the popup, no need for one here

    def injection_stopped_update(self):
        """Updates UI after stop signal processing is complete (called by MainWindow)."""
        print(f"[InjectionPanel] Injection stopped confirmation received for PID {self.current_pid}")
        # Reset state, assuming process might still be selected
        self._set_buttons_state(process_selected=bool(self.current_pid))
        self.progress_bar.hide()
        self.progress_bar.setRange(0, 1)
        # Update status based on whether a process is still selected
        if self.current_pid:
             self.status_label.setText(f"Selected PID: {self.current_pid}") # Back to selected state
             self.status_icon.setPixmap(qta.icon('fa5s.circle', color='#43b581').pixmap(14, 14)) # Green
        else:
             self.status_label.setText("No process selected") # Or if process died
             self.status_icon.setPixmap(qta.icon('fa5s.circle', color='#99aab5').pixmap(14, 14)) # Grey

    def injection_stopped_externally(self):
        """Called by MainWindow if script stops or detaches unexpectedly."""
        pid_context = f"PID {self.current_pid}" if self.current_pid else "process"
        print(f"[InjectionPanel] Script detached/stopped externally for {pid_context}")
        self.status_label.setText(f"Script detached from {pid_context}")
        self.status_icon.setPixmap(qta.icon('fa5s.exclamation-circle', color='#faa61a').pixmap(14, 14)) # Yellow Warning
        # Reset buttons to non-running state, allow injection if process still selected
        self._set_buttons_state(process_selected=bool(self.current_pid))
        self.progress_bar.hide()
        self.progress_bar.setRange(0, 1)

    def _set_buttons_state(self, process_selected=False, injecting=False, script_running=False, stopping=False):
        """Centralized method to manage button enabled/disabled states."""
        can_inject = process_selected and not injecting and not script_running and not stopping
        can_stop = script_running and not stopping
        # Allow load/clear unless actively injecting or stopping
        can_load_clear = not injecting and not stopping

        self.inject_btn.setEnabled(can_inject)
        self.stop_btn.setEnabled(can_stop)
        self.load_btn.setEnabled(can_load_clear)
        self.clear_btn.setEnabled(can_load_clear)
 
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\OLDprocess_monitor.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
                           QLabel, QLineEdit, QTableWidget, QTableWidgetItem,
                           QMenu, QAction, QComboBox, QCheckBox, QFrame,
                           QHeaderView, QStyle, QStyledItemDelegate, QToolButton, QMessageBox)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer, QSize
from PyQt5.QtGui import QColor, QFont, QIcon
import frida
import re
import qtawesome as qta
from datetime import datetime
import subprocess

class ProcessInfoDelegate(QStyledItemDelegate):
    def paint(self, painter, option, index):
        if index.column() in [2, 3]:  # CPU and Memory columns
            value_str = index.data().replace('%', '').replace('MB', '').strip()
            if value_str and value_str != 'N/A':
                try:
                    value = float(value_str)
                    if value > 80:
                        option.backgroundBrush = QColor('#f04747')
                    elif value > 50:
                        option.backgroundBrush = QColor('#faa61a')
                except ValueError:
                    pass
        super().paint(painter, option, index)

class ProcessMonitor(QWidget):
    def __init__(self, main_window=None):
        QWidget.__init__(self)
        self.processes = []
        self.current_device = None
        self.main_window = main_window
        self.setup_ui()
        self.start_monitoring()

    def start_monitoring(self):
        self.update_timer = QTimer()
        self.update_timer.timeout.connect(self.refresh_processes)
        self.update_timer.start(3000)  # Update every 3 seconds

    def stop_monitoring(self):
        if hasattr(self, 'update_timer'):
            self.update_timer.stop()

    def setup_ui(self):
        layout = QVBoxLayout(self)

        # Device selection
        device_frame = QFrame()
        device_frame.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 8px;
                padding: 10px;
            }
        """)
        device_layout = QHBoxLayout(device_frame)

        self.device_combo = QComboBox()
        self.device_combo.currentIndexChanged.connect(self.on_device_changed)

        refresh_devices_btn = QPushButton(qta.icon('fa5s.sync'), "Refresh Devices")
        refresh_devices_btn.clicked.connect(self.refresh_devices)

        device_layout.addWidget(QLabel("Device:"))
        device_layout.addWidget(self.device_combo)
        device_layout.addWidget(refresh_devices_btn)

        # Search and Filter Bar
        filter_frame = QFrame()
        filter_frame.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 8px;
                padding: 10px;
            }
        """)
        filter_layout = QHBoxLayout(filter_frame)

        # Process search with regex toggle
        search_container = QFrame()
        search_layout = QHBoxLayout(search_container)

        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("🔍 Filter processes (supports regex)")
        self.search_input.textChanged.connect(self.apply_filters)

        self.regex_check = QCheckBox("Regex")
        self.regex_check.toggled.connect(self.apply_filters)

        search_layout.addWidget(self.search_input)
        search_layout.addWidget(self.regex_check)

        # Advanced filters
        self.filter_combo = QComboBox()
        self.filter_combo.addItems(['All', 'User Apps', 'System', 'Running', 'Debuggable'])
        self.filter_combo.currentTextChanged.connect(self.apply_filters)

        filter_layout.addWidget(search_container)
        filter_layout.addWidget(self.filter_combo)

        # Process Table
        self.process_table = QTableWidget()
        self.process_table.setColumnCount(6)
        self.process_table.setHorizontalHeaderLabels([
            "PID", "Name", "Package", "User", "Status", "Debuggable"
        ])

        # Set column widths
        header = self.process_table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Fixed)  # PID
        header.setSectionResizeMode(1, QHeaderView.Stretch)  # Name
        header.setSectionResizeMode(2, QHeaderView.Stretch)  # Package
        header.setSectionResizeMode(3, QHeaderView.Fixed)  # User
        header.setSectionResizeMode(4, QHeaderView.Fixed)  # Status
        header.setSectionResizeMode(5, QHeaderView.Fixed)  # Debuggable

        self.process_table.setColumnWidth(0, 80)
        self.process_table.setColumnWidth(3, 100)
        self.process_table.setColumnWidth(4, 100)
        self.process_table.setColumnWidth(5, 100)

        # Enable sorting
        self.process_table.setSortingEnabled(True)

        # Context menu
        self.process_table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.process_table.customContextMenuRequested.connect(self.show_context_menu)

        # Action buttons
        action_layout = QHBoxLayout()

        self.refresh_btn = QPushButton(qta.icon('fa5s.sync'), "Refresh")
        self.refresh_btn.clicked.connect(self.refresh_processes)

        self.kill_btn = QPushButton(qta.icon('fa5s.stop'), "Kill Process")
        self.kill_btn.clicked.connect(self.kill_selected_process)

        self.inject_btn = QPushButton(qta.icon('fa5s.syringe'), "Open in Injector")
        self.inject_btn.clicked.connect(self.open_in_injector_clicked)

        self.dump_btn = QPushButton(qta.icon('fa5s.download'), "Dump APK")
        self.dump_btn.clicked.connect(self.dump_apk)

        action_layout.addWidget(self.refresh_btn)
        action_layout.addWidget(self.kill_btn)
        action_layout.addWidget(self.inject_btn)
        action_layout.addWidget(self.dump_btn)
        action_layout.addStretch()

        # Status bar
        status_bar = QFrame()
        status_bar.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 4px;
                padding: 5px;
            }
        """)
        status_layout = QHBoxLayout(status_bar)

        self.process_count = QLabel("0 processes")
        self.status_label = QLabel("Ready")

        status_layout.addWidget(self.process_count)
        status_layout.addStretch()
        status_layout.addWidget(self.status_label)

        # Add all components
        layout.addWidget(device_frame)
        layout.addWidget(filter_frame)
        layout.addWidget(self.process_table)
        layout.addLayout(action_layout)
        layout.addWidget(status_bar)

        # Initial device scan
        self.refresh_devices()

    def refresh_devices(self):
        self.device_combo.clear()
        try:
            devices = frida.enumerate_devices()
            for device in devices:
                if device.type == 'usb':
                    self.device_combo.addItem(f"📱 {device.name} (USB)", device.id)
        except Exception as e:
            print(f"Error enumerating devices: {e}")

    def on_device_changed(self, index):
        if index >= 0:
            self.current_device = self.device_combo.currentData()
            self.refresh_processes()

    def show_context_menu(self, position):
        menu = QMenu()

        kill_action = QAction("Kill Process", self)
        kill_action.triggered.connect(self.kill_selected_process)

        inject_action = QAction("Open in Injector", self)
        inject_action.triggered.connect(self.open_in_injector_clicked)

        dump_action = QAction("Dump APK", self)
        dump_action.triggered.connect(self.dump_apk)

        details_action = QAction("Process Details", self)
        details_action.triggered.connect(self.show_process_details)

        menu.addAction(kill_action)
        menu.addAction(inject_action)
        menu.addAction(dump_action)
        menu.addSeparator()
        menu.addAction(details_action)
        menu.exec_(self.process_table.mapToGlobal(position))

    def open_in_injector_clicked(self):
        """Handle click on 'Open in Injector' button"""
        if not self.main_window:
            return

        selected = self.process_table.selectedItems()
        if selected:
            row = selected[0].row()
            try:
                pid = int(self.process_table.item(row, 0).text())
                if self.current_device:
                    self.main_window.open_in_injector(self.current_device, pid)
                else:
                    QMessageBox.warning(self, "Error", "No device selected!")
            except ValueError:
                QMessageBox.critical(self, "Error", "Invalid PID format.")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Error: {e}")

    def refresh_processes(self):
        """Refresh process list using ps command"""
        selected_pid = None
        if self.process_table.selectedItems():
            row = self.process_table.currentRow()
            if row != -1:
                selected_pid = self.process_table.item(row, 0).text()

        self.process_table.setSortingEnabled(False)
        self.process_table.setRowCount(0)
        self.processes.clear()

        if not self.current_device:
            return

        try:
            self.status_label.setText("Refreshing processes...")
            
            # Get process list using ps -A
            adb_output = subprocess.check_output(
                ['adb', '-s', self.current_device, 'shell', 'ps', '-A'],
                text=True,
                stderr=subprocess.DEVNULL
            ).strip().split('\n')

            # Get debuggable packages
            debuggable_pkgs = self.get_debuggable_packages()

            # Parse process list
            for line in adb_output[1:]:  # Skip header
                parts = line.split()
                if len(parts) >= 9:
                    try:
                        user = parts[0]
                        pid = parts[1]
                        # Remove leading 'S', 'R', 'D', etc. status indicators
                        name = parts[8] if len(parts) > 8 else parts[-1]
                        
                        # Clean up process name (remove status prefix if present)
                        if name and len(name) > 1 and name[0] in 'SDTRZX':
                            name = name[1:]
                        
                        status = parts[7] if len(parts) > 7 else 'Unknown'
                        
                        # Determine package name (for apps)
                        package = name if '.' in name else 'N/A'
                        
                        # Check if debuggable
                        is_debuggable = package in debuggable_pkgs
                        
                        process_info = {
                            'pid': pid,
                            'name': name,
                            'package': package,
                            'user': user,
                            'status': status,
                            'debuggable': is_debuggable
                        }
                        
                        self.processes.append(process_info)
                        
                    except (IndexError, ValueError) as e:
                        continue

            self.update_table()
            self.status_label.setText(f"Loaded {len(self.processes)} processes")

        except subprocess.CalledProcessError as e:
            print(f"ADB error: {e}")
            self.status_label.setText("Error: ADB command failed")
        except Exception as e:
            print(f"Error refreshing processes: {e}")
            self.status_label.setText(f"Error: {str(e)}")

        # Restore selection
        if selected_pid:
            for row in range(self.process_table.rowCount()):
                if self.process_table.item(row, 0).text() == selected_pid:
                    self.process_table.selectRow(row)
                    break

        self.process_table.setSortingEnabled(True)

    def get_debuggable_packages(self):
        """Get list of debuggable packages"""
        try:
            output = subprocess.check_output(
                ['adb', '-s', self.current_device, 'shell', 'pm', 'list', 'packages', '-d'],
                text=True,
                stderr=subprocess.DEVNULL
            )
            packages = set()
            for line in output.strip().split('\n'):
                if line.startswith('package:'):
                    packages.add(line.replace('package:', ''))
            return packages
        except:
            return set()

    def update_table(self):
        """Populate table with process data"""
        for process in self.processes:
            row = self.process_table.rowCount()
            self.process_table.insertRow(row)

            items = [
                QTableWidgetItem(process['pid']),
                QTableWidgetItem(process['name']),
                QTableWidgetItem(process['package']),
                QTableWidgetItem(process['user']),
                QTableWidgetItem(process['status']),
                QTableWidgetItem('✓ Yes' if process['debuggable'] else '✗ No')
            ]

            # Center align PID, User, Status, Debuggable
            items[0].setTextAlignment(Qt.AlignCenter)
            items[3].setTextAlignment(Qt.AlignCenter)
            items[4].setTextAlignment(Qt.AlignCenter)
            items[5].setTextAlignment(Qt.AlignCenter)

            # Color code debuggable apps
            if process['debuggable']:
                items[5].setForeground(QColor('#43b581'))

            # Add items to row
            for col, item in enumerate(items):
                self.process_table.setItem(row, col, item)

        self.apply_filters()
        self.process_count.setText(f"{self.process_table.rowCount()} processes")

    def apply_filters(self):
        """Apply search and filter criteria"""
        search_text = self.search_input.text().lower()
        filter_type = self.filter_combo.currentText()
        use_regex = self.regex_check.isChecked()

        visible_count = 0
        for row in range(self.process_table.rowCount()):
            show_row = True
            name_item = self.process_table.item(row, 1)
            package_item = self.process_table.item(row, 2)
            debuggable_item = self.process_table.item(row, 5)

            if not name_item:
                continue

            name = name_item.text().lower()
            package = package_item.text().lower() if package_item else ''

            # Apply text filter
            if search_text:
                if use_regex:
                    try:
                        if not (re.search(search_text, name) or re.search(search_text, package)):
                            show_row = False
                    except re.error:
                        show_row = False
                elif search_text not in name and search_text not in package:
                    show_row = False

            # Apply type filter
            if filter_type == 'User Apps' and '.' not in package:
                show_row = False
            elif filter_type == 'System' and '.' in package:
                show_row = False
            elif filter_type == 'Debuggable' and not debuggable_item.text().startswith('✓'):
                show_row = False

            self.process_table.setRowHidden(row, not show_row)
            if show_row:
                visible_count += 1

        self.process_count.setText(f"{visible_count} processes (of {self.process_table.rowCount()})")

    def kill_selected_process(self):
        """Kill the selected process"""
        selected = self.process_table.selectedItems()
        if selected:
            row = selected[0].row()
            pid = self.process_table.item(row, 0).text()
            name = self.process_table.item(row, 1).text()
            
            reply = QMessageBox.question(
                self, 
                "Kill Process",
                f"Are you sure you want to kill process:\n{name} (PID: {pid})?",
                QMessageBox.Yes | QMessageBox.No
            )
            
            if reply == QMessageBox.Yes:
                try:
                    subprocess.run(
                        ['adb', '-s', self.current_device, 'shell', 'kill', pid],
                        check=True
                    )
                    self.status_label.setText(f"Killed process {pid}")
                    self.refresh_processes()
                except Exception as e:
                    QMessageBox.critical(self, "Error", f"Failed to kill process: {e}")

    def dump_apk(self):
        """Dump APK of selected app"""
        selected = self.process_table.selectedItems()
        if selected:
            row = selected[0].row()
            package = self.process_table.item(row, 2).text()
            
            if package == 'N/A' or '.' not in package:
                QMessageBox.warning(self, "Error", "Not an app package")
                return
            
            try:
                # Get APK path
                path_output = subprocess.check_output(
                    ['adb', '-s', self.current_device, 'shell', 'pm', 'path', package],
                    text=True
                ).strip()
                
                if not path_output.startswith('package:'):
                    raise Exception("Could not find APK path")
                
                apk_path = path_output.replace('package:', '')
                
                # Pull APK
                output_path = f"{package}.apk"
                subprocess.run(
                    ['adb', '-s', self.current_device, 'pull', apk_path, output_path],
                    check=True
                )
                
                QMessageBox.information(self, "Success", f"APK dumped to: {output_path}")
                
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to dump APK: {e}")

    def show_process_details(self):
        """Show detailed info about selected process"""
        selected = self.process_table.selectedItems()
        if selected:
            row = selected[0].row()
            details = "\n".join([
                f"{self.process_table.horizontalHeaderItem(col).text()}: "
                f"{self.process_table.item(row, col).text()}"
                for col in range(self.process_table.columnCount())
            ])
            QMessageBox.information(self, "Process Details", details)
 
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\output_panel.py --- 
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QTextEdit
from datetime import datetime

class OutputPanel(QWidget):
    def __init__(self):
        super().__init__()
        self.setup_ui()

    def setup_ui(self):
        layout = QVBoxLayout(self)

        self.output_area = QTextEdit()
        self.output_area.setReadOnly(True)
        self.output_area.setPlaceholderText("Output will appear here...")

        layout.addWidget(self.output_area)

    def append_output(self, text):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.output_area.append(f"[{timestamp}] {text}")

    def clear_output(self):
        self.output_area.clear() 
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\process_manager.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, 
                           QLabel, QLineEdit, QTableWidget, QTableWidgetItem,
                           QMenu, QAction, QComboBox, QCheckBox, QFrame,
                           QTableWidgetSelectionRange, QHeaderView)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer
from PyQt5.QtGui import QColor, QFont
import qtawesome as qta
import re
import psutil

class ProcessManager(QWidget):
    process_selected = pyqtSignal(int)  # pid
    
    def __init__(self):
        super().__init__()
        self.processes = {}
        self.filters = {
            'name': '',
            'pid': '',
            'cpu': 0,
            'memory': 0,
            'show_system': False
        }
        self.setup_ui()
        self.start_monitoring()
        
    def setup_ui(self):
        layout = QVBoxLayout(self)
        
        # Filter bar
        filter_frame = QFrame()
        filter_frame.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 8px;
                padding: 10px;
            }
        """)
        filter_layout = QHBoxLayout(filter_frame)
        
        # Search with regex support
        search_container = QFrame()
        search_layout = QHBoxLayout(search_container)
        
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Filter processes (supports regex)")
        self.search_input.textChanged.connect(self.apply_filters)
        
        self.regex_check = QCheckBox("Regex")
        self.regex_check.toggled.connect(self.apply_filters)
        
        search_layout.addWidget(self.search_input)
        search_layout.addWidget(self.regex_check)
        
        # Advanced filters
        self.filter_combo = QComboBox()
        self.filter_combo.addItems(['All', 'User', 'System', 'Android Apps'])
        self.filter_combo.currentTextChanged.connect(self.apply_filters)
        
        # Resource thresholds
        self.cpu_threshold = QSpinBox()
        self.cpu_threshold.setSuffix("% CPU")
        self.cpu_threshold.valueChanged.connect(self.apply_filters)
        
        self.memory_threshold = QSpinBox()
        self.memory_threshold.setSuffix("MB")
        self.memory_threshold.setMaximum(32000)
        self.memory_threshold.valueChanged.connect(self.apply_filters)
        
        filter_layout.addWidget(search_container)
        filter_layout.addWidget(self.filter_combo)
        filter_layout.addWidget(self.cpu_threshold)
        filter_layout.addWidget(self.memory_threshold)
        
        # Process table
        self.process_table = QTableWidget()
        self.process_table.setColumnCount(6)
        self.process_table.setHorizontalHeaderLabels([
            "PID", "Name", "CPU %", "Memory", "Status", "Path"
        ])
        
        # Style the table
        self.process_table.setStyleSheet("""
            QTableWidget {
                background-color: #36393f;
                border: none;
                border-radius: 8px;
                gridline-color: #2f3136;
            }
            QTableWidget::item {
                padding: 5px;
                border-bottom: 1px solid #2f3136;
            }
            QTableWidget::item:selected {
                background-color: #7289da;
            }
        """)
        
        # Set column widths
        header = self.process_table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Fixed)  # PID
        header.setSectionResizeMode(1, QHeaderView.Stretch)  # Name
        header.setSectionResizeMode(2, QHeaderView.Fixed)  # CPU
        header.setSectionResizeMode(3, QHeaderView.Fixed)  # Memory
        header.setSectionResizeMode(4, QHeaderView.Fixed)  # Status
        header.setSectionResizeMode(5, QHeaderView.Stretch)  # Path
        
        self.process_table.setColumnWidth(0, 70)  # PID
        self.process_table.setColumnWidth(2, 80)  # CPU
        self.process_table.setColumnWidth(3, 100)  # Memory
        self.process_table.setColumnWidth(4, 100)  # Status
        
        # Context menu
        self.process_table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.process_table.customContextMenuRequested.connect(self.show_context_menu)
        
        # Quick action buttons
        action_layout = QHBoxLayout()
        
        self.refresh_btn = QPushButton(qta.icon('fa5s.sync'), "Refresh")
        self.refresh_btn.clicked.connect(self.refresh_processes)
        
        self.kill_btn = QPushButton(qta.icon('fa5s.stop'), "Kill")
        self.kill_btn.clicked.connect(self.kill_selected_process)
        
        self.inject_btn = QPushButton(qta.icon('fa5s.syringe'), "Inject")
        self.inject_btn.clicked.connect(self.inject_into_selected)
        
        action_layout.addWidget(self.refresh_btn)
        action_layout.addWidget(self.kill_btn)
        action_layout.addWidget(self.inject_btn)
        action_layout.addStretch()
        
        # Status bar
        status_bar = QFrame()
        status_bar.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 4px;
                padding: 5px;
            }
        """)
        status_layout = QHBoxLayout(status_bar)
        
        self.process_count = QLabel("0 processes")
        self.cpu_usage = QLabel("CPU: 0%")
        self.memory_usage = QLabel("Memory: 0 MB")
        
        status_layout.addWidget(self.process_count)
        status_layout.addStretch()
        status_layout.addWidget(self.cpu_usage)
        status_layout.addWidget(self.memory_usage)
        
        # Add all components
        layout.addWidget(filter_frame)
        layout.addWidget(self.process_table)
        layout.addLayout(action_layout)
        layout.addWidget(status_bar)
        
    def start_monitoring(self):
        self.update_timer = QTimer()
        self.update_timer.timeout.connect(self.refresh_processes)
        self.update_timer.start(2000)  # Update every 2 seconds
        
    def refresh_processes(self):
        self.processes.clear()
        total_cpu = 0
        total_memory = 0
        
        for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_info', 'status', 'exe']):
            try:
                info = proc.info
                memory_mb = info['memory_info'].rss / 1024 / 1024
                self.processes[info['pid']] = {
                    'name': info['name'],
                    'cpu': info['cpu_percent'],
                    'memory': memory_mb,
                    'status': info['status'],
                    'path': info['exe'] or ''
                }
                total_cpu += info['cpu_percent']
                total_memory += memory_mb
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
                
        self.update_table()
        self.update_stats(total_cpu, total_memory)
        
    def update_table(self):
        self.process_table.setSortingEnabled(False)
        self.process_table.setRowCount(0)
        
        filtered_processes = self.filter_processes()
        
        for pid, info in filtered_processes.items():
            row = self.process_table.rowCount()
            self.process_table.insertRow(row)
            
            # PID
            pid_item = QTableWidgetItem(str(pid))
            pid_item.setTextAlignment(Qt.AlignCenter)
            
            # Name
            name_item = QTableWidgetItem(info['name'])
            
            # CPU
            cpu_item = QTableWidgetItem(f"{info['cpu']:.1f}%")
            cpu_item.setTextAlignment(Qt.AlignCenter)
            
            # Memory
            memory_item = QTableWidgetItem(f"{info['memory']:.1f} MB")
            memory_item.setTextAlignment(Qt.AlignCenter)
            
            # Status
            status_item = QTableWidgetItem(info['status'])
            status_item.setTextAlignment(Qt.AlignCenter)
            
            # Path
            path_item = QTableWidgetItem(info['path'])
            
            # Set items
            self.process_table.setItem(row, 0, pid_item)
            self.process_table.setItem(row, 1, name_item)
            self.process_table.setItem(row, 2, cpu_item)
            self.process_table.setItem(row, 3, memory_item)
            self.process_table.setItem(row, 4, status_item)
            self.process_table.setItem(row, 5, path_item)
            
            # Color coding based on resource usage
            if info['cpu'] > 50:
                self.color_row(row, QColor(240, 71, 71, 50))  # Red
            elif info['memory'] > 1000:
                self.color_row(row, QColor(250, 166, 26, 50))  # Orange
                
        self.process_table.setSortingEnabled(True)
        
    def filter_processes(self):
        filtered = {}
        search_text = self.search_input.text().lower()
        
        for pid, info in self.processes.items():
            # Apply regex/text filter
            if self.regex_check.isChecked():
                try:
                    if not re.search(search_text, info['name'].lower()):
                        continue
                except re.error:
                    continue
            elif search_text and search_text not in info['name'].lower():
                continue
                
            # Apply type filter
            if self.filter_combo.currentText() == 'User' and pid < 1000:
                continue
            elif self.filter_combo.currentText() == 'System' and pid >= 1000:
                continue
            elif self.filter_combo.currentText() == 'Android Apps' and not info['name'].startswith('com.'):
                continue
                
            # Apply resource thresholds
            if info['cpu'] < self.cpu_threshold.value():
                continue
            if info['memory'] < self.memory_threshold.value():
                continue
                
            filtered[pid] = info
            
        return filtered
        
    def color_row(self, row, color):
        for col in range(self.process_table.columnCount()):
            item = self.process_table.item(row, col)
            item.setBackground(color)
            
    def update_stats(self, total_cpu, total_memory):
        self.process_count.setText(f"{len(self.processes)} processes")
        self.cpu_usage.setText(f"CPU: {total_cpu:.1f}%")
        self.memory_usage.setText(f"Memory: {total_memory:.0f} MB")
        
    def show_context_menu(self, position):
        menu = QMenu()
        
        kill_action = QAction("Kill Process", self)
        kill_action.triggered.connect(self.kill_selected_process)
        
        inject_action = QAction("Inject Script", self)
        inject_action.triggered.connect(self.inject_into_selected)
        
        menu.addAction(kill_action)
        menu.addAction(inject_action)
        menu.exec_(self.process_table.mapToGlobal(position))
        
    def kill_selected_process(self):
        selected = self.process_table.selectedItems()
        if selected:
            pid = int(self.process_table.item(selected[0].row(), 0).text())
            try:
                psutil.Process(pid).terminate()
                self.refresh_processes()
            except psutil.NoSuchProcess:
                pass
                
    def inject_into_selected(self):
        selected = self.process_table.selectedItems()
        if selected:
            pid = int(self.process_table.item(selected[0].row(), 0).text())
            self.process_selected.emit(pid)  
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\process_monitor.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
                           QLabel, QLineEdit, QTableWidget, QTableWidgetItem,
                           QMenu, QAction, QComboBox, QCheckBox, QFrame,
                           QHeaderView, QStyle, QStyledItemDelegate, QToolButton, QMessageBox)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer, QSize
from PyQt5.QtGui import QColor, QFont, QIcon
from PyQt5.QtCore import QThread, QObject, pyqtSignal
import frida
import re
import qtawesome as qta
from datetime import datetime
import subprocess


class KillProcessWorker(QObject):
    finished = pyqtSignal(str, str) # Signals success: pid, name
    error = pyqtSignal(str)         # Signals error message

    def __init__(self, device_id, pid, name, parent=None):
        super().__init__(parent)
        self._device_id = device_id
        self._pid = pid
        self._name = name

    def run(self):
        try:
            subprocess.run(
                ['adb', '-s', self._device_id, 'shell', 'am', 'force-stop', self._name],
                check=True,
                capture_output=True,
                text=True,
                # Add isolation and resource limits if possible (timeout is best)
                # Adding a timeout is crucial to prevent indefinite blocking
                timeout=10 
            )
            self.finished.emit(self._pid, self._name)
        except subprocess.CalledProcessError as e:
            # Handle non-zero exit code specifically
            self.error.emit(f"Command failed (Code: {e.returncode}): {e.stderr}")
        except subprocess.TimeoutExpired:
            # Handle command timing out
            self.error.emit("Process kill command timed out.")
        except Exception as e:
            # Crucial: Catch all other exceptions (e.g., adb disconnect)
            self.error.emit(f"Unhandled kill error: {type(e).__name__} - {str(e)}")

class ProcessInfoDelegate(QStyledItemDelegate):
    def paint(self, painter, option, index):
        if index.column() in [2, 3]:  # CPU and Memory columns
            value_str = index.data().replace('%', '').replace('MB', '').strip()
            if value_str and value_str != 'N/A':
                try:
                    value = float(value_str)
                    if value > 80:
                        option.backgroundBrush = QColor('#f04747')
                    elif value > 50:
                        option.backgroundBrush = QColor('#faa61a')
                except ValueError:
                    pass
        super().paint(painter, option, index)

class ProcessMonitor(QWidget):
    def __init__(self, main_window=None):
        QWidget.__init__(self)
        self.processes = []
        self.current_device = None
        self.main_window = main_window
        self.setup_ui()
        self.start_monitoring()

    def start_monitoring(self):
        self.update_timer = QTimer()
        self.update_timer.timeout.connect(self.refresh_processes)
        self.update_timer.start(3000)  # Update every 3 seconds

    def stop_monitoring(self):
        if hasattr(self, 'update_timer'):
            self.update_timer.stop()

    def setup_ui(self):
        layout = QVBoxLayout(self)

        # Device selection
        device_frame = QFrame()
        device_frame.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 8px;
                padding: 10px;
            }
        """)
        device_layout = QHBoxLayout(device_frame)

        self.device_combo = QComboBox()
        self.device_combo.currentIndexChanged.connect(self.on_device_changed)

        refresh_devices_btn = QPushButton(qta.icon('fa5s.sync'), "Refresh Devices")
        refresh_devices_btn.clicked.connect(self.refresh_devices)

        device_layout.addWidget(QLabel("Device:"))
        device_layout.addWidget(self.device_combo)
        device_layout.addWidget(refresh_devices_btn)

        # Search and Filter Bar
        filter_frame = QFrame()
        filter_frame.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 8px;
                padding: 10px;
            }
        """)
        filter_layout = QHBoxLayout(filter_frame)

        # Process search with regex toggle
        search_container = QFrame()
        search_layout = QHBoxLayout(search_container)

        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("🔍 Filter processes (supports regex)")
        self.search_input.textChanged.connect(self.apply_filters)

        self.regex_check = QCheckBox("Regex")
        self.regex_check.toggled.connect(self.apply_filters)

        search_layout.addWidget(self.search_input)
        search_layout.addWidget(self.regex_check)

        # Advanced filters
        self.filter_combo = QComboBox()
        self.filter_combo.addItems(['All', 'User Apps', 'System', 'Running', 'Debuggable'])
        self.filter_combo.currentTextChanged.connect(self.apply_filters)

        filter_layout.addWidget(search_container)
        filter_layout.addWidget(self.filter_combo)

        # Process Table
        self.process_table = QTableWidget()
        self.process_table.setColumnCount(6)
        self.process_table.setHorizontalHeaderLabels([
            "PID", "Name", "Package", "User", "Status", "Debuggable"
        ])

        # Set column widths
        header = self.process_table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Fixed)  # PID
        header.setSectionResizeMode(1, QHeaderView.Stretch)  # Name
        header.setSectionResizeMode(2, QHeaderView.Stretch)  # Package
        header.setSectionResizeMode(3, QHeaderView.Fixed)  # User
        header.setSectionResizeMode(4, QHeaderView.Fixed)  # Status
        header.setSectionResizeMode(5, QHeaderView.Fixed)  # Debuggable

        self.process_table.setColumnWidth(0, 80)
        self.process_table.setColumnWidth(3, 100)
        self.process_table.setColumnWidth(4, 100)
        self.process_table.setColumnWidth(5, 100)

        # Enable sorting
        self.process_table.setSortingEnabled(True)

        # Context menu
        self.process_table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.process_table.customContextMenuRequested.connect(self.show_context_menu)

        # Action buttons
        action_layout = QHBoxLayout()

        self.refresh_btn = QPushButton(qta.icon('fa5s.sync'), "Refresh")
        self.refresh_btn.clicked.connect(self.refresh_processes)

        self.kill_btn = QPushButton(qta.icon('fa5s.stop'), "Kill Process")
        self.kill_btn.clicked.connect(self.kill_selected_process)

        self.inject_btn = QPushButton(qta.icon('fa5s.syringe'), "Open in Injector")
        self.inject_btn.clicked.connect(self.open_in_injector_clicked)

        self.dump_btn = QPushButton(qta.icon('fa5s.download'), "Dump APK")
        self.dump_btn.clicked.connect(self.dump_apk)

        action_layout.addWidget(self.refresh_btn)
        action_layout.addWidget(self.kill_btn)
        action_layout.addWidget(self.inject_btn)
        action_layout.addWidget(self.dump_btn)
        action_layout.addStretch()

        # Status bar
        status_bar = QFrame()
        status_bar.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 4px;
                padding: 5px;
            }
        """)
        status_layout = QHBoxLayout(status_bar)

        self.process_count = QLabel("0 processes")
        self.status_label = QLabel("Ready")

        status_layout.addWidget(self.process_count)
        status_layout.addStretch()
        status_layout.addWidget(self.status_label)

        # Add all components
        layout.addWidget(device_frame)
        layout.addWidget(filter_frame)
        layout.addWidget(self.process_table)
        layout.addLayout(action_layout)
        layout.addWidget(status_bar)

        # Initial device scan
        self.refresh_devices()

    def refresh_devices(self):
        self.device_combo.clear()
        try:
            devices = frida.enumerate_devices()
            for device in devices:
                if device.type == 'usb':
                    self.device_combo.addItem(f"📱 {device.name} (USB)", device.id)
        except Exception as e:
            print(f"Error enumerating devices: {e}")

    def on_device_changed(self, index):
        if index >= 0:
            self.current_device = self.device_combo.currentData()
            self.refresh_processes()

    def show_context_menu(self, position):
        menu = QMenu()

        kill_action = QAction("Kill Process", self)
        kill_action.triggered.connect(self.kill_selected_process)

        inject_action = QAction("Open in Injector", self)
        inject_action.triggered.connect(self.open_in_injector_clicked)

        dump_action = QAction("Dump APK", self)
        dump_action.triggered.connect(self.dump_apk)

        details_action = QAction("Process Details", self)
        details_action.triggered.connect(self.show_process_details)

        menu.addAction(kill_action)
        menu.addAction(inject_action)
        menu.addAction(dump_action)
        menu.addSeparator()
        menu.addAction(details_action)
        menu.exec_(self.process_table.mapToGlobal(position))

    def open_in_injector_clicked(self):
        """Handle click on 'Open in Injector' button"""
        if not self.main_window:
            return

        selected = self.process_table.selectedItems()
        if selected:
            row = selected[0].row()
            try:
                pid = int(self.process_table.item(row, 0).text())
                if self.current_device:
                    self.main_window.open_in_injector(self.current_device, pid)
                else:
                    QMessageBox.warning(self, "Error", "No device selected!")
            except ValueError:
                QMessageBox.critical(self, "Error", "Invalid PID format.")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Error: {e}")

    def refresh_processes(self):
        """Refresh process list using ps command"""
        selected_pid = None
        if self.process_table.selectedItems():
            row = self.process_table.currentRow()
            if row != -1:
                selected_pid = self.process_table.item(row, 0).text()

        self.process_table.setSortingEnabled(False)
        self.process_table.setRowCount(0)
        self.processes.clear()

        if not self.current_device:
            return

        try:
            self.status_label.setText("Refreshing processes...")
            
            # Get process list using ps -A
            adb_output = subprocess.check_output(
                ['adb', '-s', self.current_device, 'shell', 'ps', '-A'],
                text=True,
                stderr=subprocess.DEVNULL
            ).strip().split('\n')

            # Get debuggable packages
            debuggable_pkgs = self.get_debuggable_packages()

            # Parse process list
            for line in adb_output[1:]:  # Skip header
                parts = line.split()
                if len(parts) >= 9:
                    try:
                        user = parts[0]
                        pid = parts[1]
                        # Remove leading 'S', 'R', 'D', etc. status indicators
                        name = parts[8] if len(parts) > 8 else parts[-1]
                        
                        # Clean up process name (remove status prefix if present)
                        if name and len(name) > 1 and name[0] in 'SDTRZX':
                            name = name[1:]
                        
                        status = parts[7] if len(parts) > 7 else 'Unknown'
                        
                        # Determine package name (for apps)
                        package = name if '.' in name else 'N/A'
                        
                        # Check if debuggable
                        is_debuggable = package in debuggable_pkgs
                        
                        process_info = {
                            'pid': pid,
                            'name': name,
                            'package': package,
                            'user': user,
                            'status': status,
                            'debuggable': is_debuggable
                        }
                        
                        self.processes.append(process_info)
                        
                    except (IndexError, ValueError) as e:
                        continue

            self.update_table()
            self.status_label.setText(f"Loaded {len(self.processes)} processes")

        except subprocess.CalledProcessError as e:
            print(f"ADB error: {e}")
            self.status_label.setText("Error: ADB command failed")
        except Exception as e:
            print(f"Error refreshing processes: {e}")
            self.status_label.setText(f"Error: {str(e)}")

        # Restore selection
        if selected_pid:
            for row in range(self.process_table.rowCount()):
                if self.process_table.item(row, 0).text() == selected_pid:
                    self.process_table.selectRow(row)
                    break

        self.process_table.setSortingEnabled(True)

    def get_debuggable_packages(self):
        """Get list of debuggable packages"""
        try:
            output = subprocess.check_output(
                ['adb', '-s', self.current_device, 'shell', 'pm', 'list', 'packages', '-d'],
                text=True,
                stderr=subprocess.DEVNULL
            )
            packages = set()
            for line in output.strip().split('\n'):
                if line.startswith('package:'):
                    packages.add(line.replace('package:', ''))
            return packages
        except:
            return set()

    def update_table(self):
        """Populate table with process data"""
        for process in self.processes:
            row = self.process_table.rowCount()
            self.process_table.insertRow(row)

            items = [
                QTableWidgetItem(process['pid']),
                QTableWidgetItem(process['name']),
                QTableWidgetItem(process['package']),
                QTableWidgetItem(process['user']),
                QTableWidgetItem(process['status']),
                QTableWidgetItem('✓ Yes' if process['debuggable'] else '✗ No')
            ]

            # Center align PID, User, Status, Debuggable
            items[0].setTextAlignment(Qt.AlignCenter)
            items[3].setTextAlignment(Qt.AlignCenter)
            items[4].setTextAlignment(Qt.AlignCenter)
            items[5].setTextAlignment(Qt.AlignCenter)

            # Color code debuggable apps
            if process['debuggable']:
                items[5].setForeground(QColor('#43b581'))

            # Add items to row
            for col, item in enumerate(items):
                self.process_table.setItem(row, col, item)

        self.apply_filters()
        self.process_count.setText(f"{self.process_table.rowCount()} processes")

    def apply_filters(self):
        """Apply search and filter criteria"""
        search_text = self.search_input.text().lower()
        filter_type = self.filter_combo.currentText()
        use_regex = self.regex_check.isChecked()

        visible_count = 0
        for row in range(self.process_table.rowCount()):
            show_row = True
            name_item = self.process_table.item(row, 1)
            package_item = self.process_table.item(row, 2)
            debuggable_item = self.process_table.item(row, 5)

            if not name_item:
                continue

            name = name_item.text().lower()
            package = package_item.text().lower() if package_item else ''

            # Apply text filter
            if search_text:
                if use_regex:
                    try:
                        if not (re.search(search_text, name) or re.search(search_text, package)):
                            show_row = False
                    except re.error:
                        show_row = False
                elif search_text not in name and search_text not in package:
                    show_row = False

            # Apply type filter
            if filter_type == 'User Apps' and '.' not in package:
                show_row = False
            elif filter_type == 'System' and '.' in package:
                show_row = False
            elif filter_type == 'Debuggable' and not debuggable_item.text().startswith('✓'):
                show_row = False

            self.process_table.setRowHidden(row, not show_row)
            if show_row:
                visible_count += 1

        self.process_count.setText(f"{visible_count} processes (of {self.process_table.rowCount()})")

    def kill_selected_process(self):
        """Kill the selected process (using a non-blocking thread)"""
        selected = self.process_table.selectedItems()
        if not selected:
            return

        row = selected[0].row()
        pid = self.process_table.item(row, 0).text()
        name = self.process_table.item(row, 1).text()
        
        reply = QMessageBox.question(
            self, 
            "Kill Process",
            f"Are you sure you want to kill process:\n{name} (PID: {pid})?",
            QMessageBox.Yes | QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            # 1. Create QThread instance
            self.thread = QThread()
            # 2. Create Worker instance
            self.worker = KillProcessWorker(self.current_device, pid, name)
            
            # 3. Move worker to the thread
            self.worker.moveToThread(self.thread)
            
            # 4. Connect signals to slots
            self.thread.started.connect(self.worker.run)
            self.worker.finished.connect(self._handle_kill_success)
            self.worker.error.connect(self._handle_kill_error)
            
            # 5. Clean up when finished/error (crucial!)
            self.worker.finished.connect(self.thread.quit)
            self.worker.error.connect(self.thread.quit)
            self.worker.finished.connect(self.worker.deleteLater)
            self.worker.error.connect(self.worker.deleteLater)
            self.thread.finished.connect(self.thread.deleteLater)
            
            # 6. Start the thread
            self.thread.start()

    def _handle_kill_success(self, pid, name):
        """Executed on the main thread after successful kill."""
        self.status_label.setText(f"Killed process {pid}: {name}")
        self.refresh_processes()

    def _handle_kill_error(self, error_msg):
        """Executed on the main thread after kill failure."""
        QMessageBox.critical(self, "Error", f"Failed to kill process:\n{error_msg}")

    def dump_apk(self):
        """Dump APK of selected app"""
        selected = self.process_table.selectedItems()
        if selected:
            row = selected[0].row()
            package = self.process_table.item(row, 2).text()
            
            if package == 'N/A' or '.' not in package:
                QMessageBox.warning(self, "Error", "Not an app package")
                return
            
            try:
                # Get APK path
                path_output = subprocess.check_output(
                    ['adb', '-s', self.current_device, 'shell', 'pm', 'path', package],
                    text=True
                ).strip()
                
                if not path_output.startswith('package:'):
                    raise Exception("Could not find APK path")
                
                apk_path = path_output.replace('package:', '')
                
                # Pull APK
                output_path = f"{package}.apk"
                subprocess.run(
                    ['adb', '-s', self.current_device, 'pull', apk_path, output_path],
                    check=True
                )
                
                QMessageBox.information(self, "Success", f"APK dumped to: {output_path}")
                
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to dump APK: {e}")

    def show_process_details(self):
        """Show detailed info about selected process"""
        selected = self.process_table.selectedItems()
        if selected:
            row = selected[0].row()
            details = "\n".join([
                f"{self.process_table.horizontalHeaderItem(col).text()}: "
                f"{self.process_table.item(row, col).text()}"
                for col in range(self.process_table.columnCount())
            ])
            QMessageBox.information(self, "Process Details", details) 
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\process_panel.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, 
                           QComboBox, QPushButton, QLabel)
import frida
import subprocess

class ProcessPanel(QWidget):
    def __init__(self):
        super().__init__()
        self.setup_ui()
        self.current_device_id = None
        
    def setup_ui(self):
        layout = QHBoxLayout(self)
        
        self.process_combo = QComboBox()
        self.refresh_button = QPushButton("Refresh Processes")
        
        layout.addWidget(QLabel("Select Process:"))
        layout.addWidget(self.process_combo)
        layout.addWidget(self.refresh_button)
        
        self.refresh_button.clicked.connect(self.refresh_processes)
        
    def update_device(self, device_id):
        self.current_device_id = device_id
        self.refresh_processes()
        
    def refresh_processes(self):
        if not self.current_device_id:
            return
            
        self.process_combo.clear()
        try:
            device = frida.get_device(self.current_device_id)
            if device.type == 'local':
                processes = device.enumerate_processes()
                for process in processes:
                    self.process_combo.addItem(
                        f"{process.name} (PID: {process.pid})", 
                        process.pid
                    )
            else:
                # For ADB devices
                output = subprocess.check_output(
                    ['adb', '-s', self.current_device_id, 'shell', 'ps'],
                    text=True
                ).strip().split('\n')
                
                for line in output[1:]:  # Skip header
                    parts = line.split()
                    if len(parts) >= 9:
                        pid = parts[1]
                        process_name = parts[-1]
                        self.process_combo.addItem(
                            f"{process_name} (PID: {pid})", 
                            pid
                        )
        except Exception as e:
            print(f"Error refreshing processes: {str(e)}")  
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\script_editor.py --- 
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QTextEdit
# Removed unused imports: QFont, Qt

class ScriptEditorPanel(QWidget):
    def __init__(self):
        super().__init__()
        self.setup_ui()

    def setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0) # Remove margins if desired

        self.editor = QTextEdit()
        self.editor.setPlaceholderText("Enter your Frida script here...")
        # self.editor.setLineWrap(True) # Removed: Line wrap often not desired for code
        self.editor.setFontFamily("Consolas") # Keep monospace font
        self.editor.setStyleSheet("font-size: 11pt;") # Example: Set font size via stylesheet

        # Set default script template
        self.editor.setPlainText('''Java.perform(function() {
    console.log("Script loaded!");
});''')

        layout.addWidget(self.editor)

    def get_script(self):
        return self.editor.toPlainText()

    def set_script(self, script):
        self.editor.setPlainText(script)

    # Added: Method to clear the editor (called by InjectionPanel)
    def clear(self):
        self.editor.clear()

    # Added: Method to paste into the editor (called by InjectionPanel, if needed)
    def paste(self):
        self.editor.paste()

    # Added: Method to get the actual QTextEdit widget (used by MainWindow)
    def get_editor_widget(self):
        return self.editor 
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\__init__.py --- 
# Empty file to make the directory a Python package  
--- File: D:\ANDROID\FridaGUI\src\utils\themes.py --- 
from PyQt5.QtWidgets import QStyleFactory
from PyQt5.QtGui import QPalette, QColor
from PyQt5.QtCore import Qt

# Discord-inspired color scheme
DISCORD_COLORS = {
    'background': '#36393f',
    'secondary_bg': '#2f3136',
    'tertiary_bg': '#202225',
    'text': '#dcddde',
    'secondary_text': '#96989d',
    'accent': '#ec695c',
    'accent_hover': '#4752c4',
    'red': '#ed4245',
    'green': '#3ba55c'
}

STYLE_SHEET = """
QMainWindow, QWidget {
    background-color: """ + DISCORD_COLORS['background'] + """;
    color: """ + DISCORD_COLORS['text'] + """;
    font-family: 'Segoe UI', Arial, sans-serif;
}

QTabWidget::pane {
    border: none;
    background-color: """ + DISCORD_COLORS['background'] + """;
}

QTabWidget::tab-bar {
    alignment: left;
}

QTabBar::tab {
    background-color: """ + DISCORD_COLORS['tertiary_bg'] + """;
    color: """ + DISCORD_COLORS['secondary_text'] + """;
    padding: 8px 16px;
    border: none;
    min-width: 100px;
}

QTabBar::tab:selected {
    background-color: """ + DISCORD_COLORS['background'] + """;
    color: """ + DISCORD_COLORS['text'] + """;
}

QTabBar::tab:hover:!selected {
    background-color: """ + DISCORD_COLORS['secondary_bg'] + """;
}

QPushButton {
    background-color: """ + DISCORD_COLORS['accent'] + """;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    font-weight: bold;
}

QPushButton:hover {
    background-color: """ + DISCORD_COLORS['accent_hover'] + """;
}

QPushButton:pressed {
    background-color: """ + DISCORD_COLORS['accent'] + """;
}

QComboBox {
    background-color: """ + DISCORD_COLORS['tertiary_bg'] + """;
    border: none;
    border-radius: 4px;
    padding: 6px 12px;
    color: """ + DISCORD_COLORS['text'] + """;
    min-width: 150px;
}

QComboBox::drop-down {
    border: none;
    width: 20px;
}

QComboBox::down-arrow {
    image: none;
    border-left: 4px solid transparent;
    border-right: 4px solid transparent;
    border-top: 4px solid """ + DISCORD_COLORS['text'] + """;
    margin-right: 8px;
}

QTextEdit {
    background-color: """ + DISCORD_COLORS['tertiary_bg'] + """;
    border: none;
    border-radius: 4px;
    padding: 8px;
    color: """ + DISCORD_COLORS['text'] + """;
    font-family: 'Consolas', 'Courier New', monospace;
}

QLabel {
    color: """ + DISCORD_COLORS['text'] + """;
    font-weight: bold;
}

QScrollBar:vertical {
    border: none;
    background-color: #2f3136;
    width: 14px;
    margin: 0;
}

QScrollBar::handle:vertical {
    background-color: """ + DISCORD_COLORS['secondary_bg'] + """;
    min-height: 30px;
    border-radius: 7px;
}

QScrollBar::handle:vertical:hover {
    background-color: """ + DISCORD_COLORS['accent'] + """;
}

QScrollBar::up-arrow:vertical, QScrollBar::down-arrow:vertical,
QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
    border: none;
    background: none;
    color: none;
}

QListWidget {
    background-color: """ + DISCORD_COLORS['tertiary_bg'] + """;
    border: none;
    border-radius: 4px;
    padding: 4px;
}

QListWidget::item {
    padding: 8px;
    border-radius: 4px;
}

QListWidget::item:hover {
    background-color: """ + DISCORD_COLORS['secondary_bg'] + """;
}

QListWidget::item:selected {
    background-color: """ + DISCORD_COLORS['accent'] + """;
    color: white;
}
"""

def set_application_style(app):
    app.setStyle(QStyleFactory.create("Fusion"))
    
    # Set the custom style sheet
    app.setStyleSheet(STYLE_SHEET)
    
    # Set up dark palette for system dialogs
    dark_palette = QPalette()
    dark_palette.setColor(QPalette.Window, QColor(DISCORD_COLORS['background']))
    dark_palette.setColor(QPalette.WindowText, QColor(DISCORD_COLORS['text']))
    dark_palette.setColor(QPalette.Base, QColor(DISCORD_COLORS['tertiary_bg']))
    dark_palette.setColor(QPalette.AlternateBase, QColor(DISCORD_COLORS['secondary_bg']))
    dark_palette.setColor(QPalette.ToolTipBase, QColor(DISCORD_COLORS['text']))
    dark_palette.setColor(QPalette.ToolTipText, QColor(DISCORD_COLORS['text']))
    dark_palette.setColor(QPalette.Text, QColor(DISCORD_COLORS['text']))
    dark_palette.setColor(QPalette.Button, QColor(DISCORD_COLORS['accent']))
    dark_palette.setColor(QPalette.ButtonText, Qt.white)
    dark_palette.setColor(QPalette.BrightText, Qt.red)
    dark_palette.setColor(QPalette.Link, QColor(DISCORD_COLORS['accent']))
    dark_palette.setColor(QPalette.Highlight, QColor(DISCORD_COLORS['accent']))
    dark_palette.setColor(QPalette.HighlightedText, Qt.white)
    
    app.setPalette(dark_palette)  
