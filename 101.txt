 
--- File: D:\ANDROID\FridaGUI\src\main.py --- 
import sys
import os
from pathlib import Path

def setup_qt_environment():
    """Setup Qt environment variables and paths"""
    try:
        # Get the PyQt5 location
        import PyQt5
        pyqt_path = Path(PyQt5.__file__).parent
        
        # Set environment variables
        os.environ['QT_DEBUG_PLUGINS'] = '1'
        os.environ['QT_QPA_PLATFORM_PLUGIN_PATH'] = str(pyqt_path / 'Qt5' / 'plugins')
        
        # Print debug info
        print(f"PyQt5 path: {pyqt_path}")
        print(f"Plugin path: {os.environ['QT_QPA_PLATFORM_PLUGIN_PATH']}")
        
        # Verify plugin exists
        cocoa_path = pyqt_path / 'Qt5' / 'plugins' / 'platforms' / 'libqcocoa.dylib'
        if cocoa_path.exists():
            print(f"Found cocoa plugin at: {cocoa_path}")
        else:
            print(f"Warning: Could not find cocoa plugin at: {cocoa_path}")
            
            # Try alternate locations
            alt_paths = [
                pyqt_path / 'Qt' / 'plugins' / 'platforms' / 'libqcocoa.dylib',
                Path('/opt/anaconda3/plugins/platforms/libqcocoa.dylib'),
                Path('/opt/anaconda3/lib/python3.11/site-packages/PyQt5/Qt/plugins/platforms/libqcocoa.dylib')
            ]
            
            for path in alt_paths:
                if path.exists():
                    print(f"Found cocoa plugin in alternate location: {path}")
                    os.environ['QT_QPA_PLATFORM_PLUGIN_PATH'] = str(path.parent.parent)
                    break
            
    except Exception as e:
        print(f"Error setting up Qt environment: {e}")

# Add project root to Python path
project_root = Path(__file__).parent
sys.path.append(str(project_root))

# Setup Qt environment before importing PyQt
setup_qt_environment()

from PyQt5.QtWidgets import QApplication, QMessageBox
from gui.main_window import FridaInjectorMainWindow
from utils.themes import set_application_style

def main():
    try:
        # Create application
        app = QApplication(sys.argv)
        set_application_style(app)
        
        window = FridaInjectorMainWindow()
        window.show()
        
        sys.exit(app.exec_())
    except Exception as e:
        print(f"Error starting application: {e}")
        QMessageBox.critical(None, "Error", f"Application failed to start: {str(e)}")
        sys.exit(1)

if __name__ == '__main__':
    main()  
--- File: D:\ANDROID\FridaGUI\src\core\android_helper.py --- 
import subprocess
import os
import time
import requests
import platform

class AndroidHelper:
    FRIDA_SERVER_URL = "https://github.com/frida/frida/releases/download/16.1.4/frida-server-16.1.4-android-arm64.xz"
    
    @staticmethod
    def get_adb_path():
        """Get the ADB executable path"""
        if platform.system() == "Windows":
            return "adb.exe"
        return "adb"
        
    @staticmethod
    def is_device_connected(device_id):
        """Check if device is connected"""
        try:
            output = subprocess.check_output([AndroidHelper.get_adb_path(), 'devices'], text=True)
            return device_id in output
        except:
            return False
            
    @staticmethod
    def get_device_arch(device_id):
        """Get device architecture"""
        try:
            output = subprocess.check_output([
                AndroidHelper.get_adb_path(), '-s', device_id, 'shell', 'getprop ro.product.cpu.abi'
            ], text=True).strip()
            
            if 'arm64' in output:
                return 'arm64'
            elif 'arm' in output:
                return 'arm'
            elif 'x86_64' in output:
                return 'x86_64'
            elif 'x86' in output:
                return 'x86'
            return 'arm64'  # Default to arm64
        except:
            return 'arm64'

    @staticmethod
    def start_frida_server(device_id):
        """Start frida-server on device"""
        try:
            adb = AndroidHelper.get_adb_path()
            
            # Get device architecture
            arch = AndroidHelper.get_device_arch(device_id)
            #server_url = f"https://github.com/frida/frida/releases/download/16.1.4/frida-server-16.1.4-android-{arch}.xz"
            server_url = f"https://github.com/frida/frida/releases/download/15.2.2/frida-server-15.2.2-android-{arch}.xz"
            
            # First, try to get root access
            print(f"[ADB] Attempting to gain root access on device {device_id}")
            subprocess.run([adb, '-s', device_id, 'root'], check=True, capture_output=True, text=True)
            time.sleep(1)  # Wait for root to take effect
            
            # Remount system as read-write
            print(f"[ADB] Remounting system as read-write on device {device_id}")
            subprocess.run([adb, '-s', device_id, 'remount'], check=True, capture_output=True, text=True)
            
            # Download and push frida-server (always get fresh copy)
            print(f"Downloading frida-server for {arch}...")
            response = requests.get(server_url, stream=True)
            response.raise_for_status()  # Raise HTTPError for bad responses (4xx or 5xx)
            server_path = os.path.join(os.getcwd(), 'frida_data', f'frida-server-{arch}')
            
            # Create directory if it doesn't exist
            os.makedirs(os.path.dirname(server_path), exist_ok=True)
            
            # Save and extract
            with open(server_path + '.xz', 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            
            try:
                print(f"Extracting frida-server archive...")
                subprocess.run(['xz', '-d', '-f', server_path + '.xz'], check=True, capture_output=True, text=True)  # Force extraction
            except subprocess.CalledProcessError as e:
                print(f"Error extracting with xz: {e}. Trying alternative method...")
                import lzma
                try:
                    with lzma.open(server_path + '.xz') as f:
                        with open(server_path, 'wb') as out:
                            out.write(f.read())
                    print("Successfully extracted using lzma.")
                except Exception as e2:
                    print(f"Error extracting with lzma: {e2}.  Failed to extract frida-server.")
                    return False
            
            # Push to device
            print("Pushing frida-server to device...")
            subprocess.run([
                adb, '-s', device_id, 'push',
                server_path, '/data/local/tmp/frida-server'
            ], check=True, capture_output=True, text=True)
            
            # Kill any existing frida-server processes
            print("Killing existing frida-server processes...")
            kill_commands = [
                'pkill -f frida-server',
                'killall -9 frida-server',
                'kill $(pidof frida-server)',
            ]
            
            for cmd in kill_commands:
                try:
                    subprocess.run([adb, '-s', device_id, 'shell', cmd], check=False, capture_output=True, text=True)
                except Exception as e:
                    print(f"Error killing frida-server with command '{cmd}': {e}")
            
            # Set permissions and start server
            start_commands = [
                'chmod 755 /data/local/tmp/frida-server',
                'su -c "chmod 755 /data/local/tmp/frida-server"',
                'su -c "setenforce 0"',
                'su -c "/data/local/tmp/frida-server -D"',  # Run in daemon mode
                '/data/local/tmp/frida-server -D'  # Fallback without su
            ]
            
            for cmd in start_commands:
                try:
                    print(f"Executing command: {cmd}")
                    subprocess.run([adb, '-s', device_id, 'shell', cmd], check=False, capture_output=True, text=True, timeout=5)
                    time.sleep(1)
                    if AndroidHelper.is_frida_running(device_id):
                        print("Frida server started successfully")
                        return True
                except subprocess.TimeoutExpired:
                    print("Timeout while starting frida-server.  Server may be running.")
                    if AndroidHelper.is_frida_running(device_id):
                        print("Frida server started successfully")
                        return True
                except Exception as e:
                    print(f"Error starting frida-server with command '{cmd}': {e}")
                    continue
            
            print("Failed to start frida-server")
            return False
            
        except requests.exceptions.RequestException as e:
            print(f"Error downloading frida-server: {e}")
            return False
        except subprocess.CalledProcessError as e:
            print(f"ADB error: {e.stderr}")
            return False
        except Exception as e:
            print(f"Error starting frida-server: {e}")
            return False

    @staticmethod
    def is_frida_running(device_id):
        """Check if frida-server is running on device"""
        try:
            # Try different ps commands as they vary by Android version
            commands = [
                'ps -A | grep frida-server',
                'ps -ef | grep frida-server',
                'ps | grep frida-server',
                'top -n 1 | grep frida-server',
                'pidof frida-server'
            ]
            
            for cmd in commands:
                try:
                    output = subprocess.check_output(
                        [AndroidHelper.get_adb_path(), '-s', device_id, 'shell', cmd],
                        text=True,
                        stderr=subprocess.PIPE,
                        timeout=2
                    )
                    if ('frida-server' in output and 'grep' not in output) or output.strip().isdigit():
                        return True
                except:
                    continue
            
            # Try netstat as last resort
            try:
                output = subprocess.check_output(
                    [AndroidHelper.get_adb_path(), '-s', device_id, 'shell', 'netstat -tlnp'],
                    text=True,
                    stderr=subprocess.PIPE,
                    timeout=2
                )
                if ':27042' in output:  # Default frida port
                    return True
            except:
                pass
                
            return False
        except:
            return False  
--- File: D:\ANDROID\FridaGUI\src\core\history_manager.py --- 
from datetime import datetime
import json
import os
from collections import deque
import weakref

class HistoryManager:
    def __init__(self):
        self.history_file = os.path.join(os.getcwd(), 'frida_data', 'history.json')
        self._history = deque(maxlen=1000)  # Limit history size
        self.load_history()
        
    def load_history(self):
        try:
            if os.path.exists(self.history_file):
                with open(self.history_file, 'r') as f:
                    # Load directly into deque with max size
                    data = json.load(f)
                    self._history.extend(data[-1000:])  # Only keep last 1000 entries
        except Exception as e:
            print(f"Error loading history: {e}")
            
    def save_history(self):
        try:
            os.makedirs(os.path.dirname(self.history_file), exist_ok=True)
            with open(self.history_file, 'w') as f:
                # Convert deque to list for JSON serialization
                json.dump(list(self._history), f, indent=2)
        except Exception as e:
            print(f"Error saving history: {e}")
            
    def add_entry(self, action_type, details):
        entry = {
            'timestamp': datetime.now().isoformat(),
            'type': action_type,
            'details': details
        }
        self._history.appendleft(entry)  # Use deque's appendleft
        
        # Periodically save to prevent memory buildup
        if len(self._history) % 10 == 0:  # Save every 10 entries
            self.save_history()
            
    def clear_history(self):
        self._history.clear()
        self.save_history()
        
    @property
    def history(self):
        return list(self._history)  # Return a copy to prevent memory leaks
        
    def __del__(self):
        self.save_history() 
--- File: D:\ANDROID\FridaGUI\src\core\process_monitor.py --- 
from PyQt5.QtCore import QObject, pyqtSignal, QTimer
#import psutil
import frida
import weakref

class ProcessMonitor(QObject):
    process_started = pyqtSignal(str, int)  # name, pid
    process_ended = pyqtSignal(str, int)    # name, pid
    # Removed memory_updated signal as psutil is removed
    # memory_updated = pyqtSignal(str, float) # pid, memory_usage
    
    def __init__(self, refresh_rate=2000):
        super().__init__()
        self.refresh_rate = refresh_rate
        self.monitored_processes = {}
        self.timer = QTimer()
        self.timer.timeout.connect(self.check_processes)
        self._stopped = False
        self.device_id = None # Added: Store the ID of the device to monitor
        
    def set_device(self, device_id):
        """Sets the device ID to monitor and resets state."""
        self.device_id = device_id
        # Clear monitored processes when device changes
        self.monitored_processes.clear()
        # Optionally, trigger an immediate check
        self.check_processes()

    def start_monitoring(self):
        self._stopped = False
        # Only start the timer if a device is set, or adjust logic as needed
        if self.device_id:
            self.timer.start(self.refresh_rate)

    def stop_monitoring(self):
        self._stopped = True
        self.timer.stop()
        self.monitored_processes.clear()  # Clear the dictionary
        self.device_id = None # Reset device ID on stop

    
    
    def check_processes(self):
        if self._stopped or not self.device_id: # Modified: Don't run if stopped or no device ID
            return

        current_processes = {}

        try:
            # Modified: Get the specific device using the stored ID
            device = frida.get_device(self.device_id)

            # Ensure the device is still available (e.g., USB connected)
            # Simple check by trying to enumerate processes
            processes = device.enumerate_processes()

            for process in processes:
                if self._stopped:
                    return

                # Only include processes with a valid PID and name
                if process.pid > 0 and process.name:
                    current_processes[process.pid] = process.name

                    # New process detected
                    if process.pid not in self.monitored_processes:
                        self.process_started.emit(process.name, process.pid)

                # Removed memory usage update via psutil, as it's not applicable directly to remote devices
                # try:
                #     p = psutil.Process(process.pid)
                #     memory_mb = p.memory_info().rss / 1024 / 1024
                #     self.memory_updated.emit(str(process.pid), memory_mb)
                # except (psutil.NoSuchProcess, psutil.AccessDenied):
                #     continue

            # Check for ended processes
            ended_pids = list(self.monitored_processes.keys() - current_processes.keys())
            for pid in ended_pids:
                name = self.monitored_processes.get(pid, "Unknown") # Get name safely
                self.process_ended.emit(name, pid)

            self.monitored_processes = current_processes

        except frida.ServerNotRunningError:
             print(f"Frida server not running on device {self.device_id}. Stopping monitor for this device.")
             # Handle case where server stops - maybe emit a signal?
             self.stop_monitoring() # Stop timer if server isn't running
        except frida.TransportError as e:
             print(f"Transport error with device {self.device_id}: {e}. Stopping monitor.")
             # Handle case where device disconnects
             self.stop_monitoring() # Stop timer if device disconnects
        except Exception as e:
            print(f"Error monitoring processes on device {self.device_id}: {str(e)}")
            # Consider stopping or pausing timer on repeated errors

    def __del__(self):
        self.stop_monitoring() 
--- File: D:\ANDROID\FridaGUI\src\core\script_history.py --- 
import json
import os
from datetime import datetime

class ScriptHistory:
    def __init__(self):
        self.base_dir = os.path.join(os.getcwd(), 'frida_data')
        self.history_file = os.path.join(self.base_dir, 'script_history.json')
        self.favorites_file = os.path.join(self.base_dir, 'favorites.json')
        self.ensure_dirs()
        self.load_history()
        
    def ensure_dirs(self):
        os.makedirs(self.base_dir, exist_ok=True)
        
    def load_history(self):
        try:
            if os.path.exists(self.history_file):
                with open(self.history_file, 'r') as f:
                    self.history = json.load(f)
            else:
                self.history = {
                    'local': [],
                    'codeshare': [],
                    'favorites': []
                }
        except Exception as e:
            print(f"Error loading history: {e}")
            self.history = {'local': [], 'codeshare': [], 'favorites': []}
            
    def save_history(self):
        try:
            with open(self.history_file, 'w') as f:
                json.dump(self.history, f, indent=2)
        except Exception as e:
            print(f"Error saving history: {e}")
            
    def add_to_history(self, script_type, script_info):
        """Add script to history with timestamp"""
        entry = {
            'timestamp': datetime.now().isoformat(),
            'info': script_info
        }
        
        # Keep only last 50 entries
        self.history[script_type] = ([entry] + 
                                   [x for x in self.history[script_type] 
                                    if x['info'].get('id') != script_info.get('id')])[:50]
        self.save_history()
        
    def add_to_favorites(self, script_info):
        """Add script to favorites"""
        if script_info not in self.history['favorites']:
            self.history['favorites'].append(script_info)
            self.save_history()
            
    def remove_from_favorites(self, script_id):
        """Remove script from favorites"""
        self.history['favorites'] = [
            x for x in self.history['favorites'] 
            if x.get('id') != script_id
        ]
        self.save_history()
        
    def get_recent_scripts(self, script_type, limit=10):
        """Get recent scripts of specified type"""
        return self.history[script_type][:limit]
        
    def get_favorites(self):
        """Get all favorite scripts"""
        return self.history['favorites']
        
    def is_favorite(self, script_id):
        """Check if script is in favorites"""
        return any(x.get('id') == script_id 
                  for x in self.history['favorites'])  
--- File: D:\ANDROID\FridaGUI\src\core\script_manager.py --- 
from PyQt5.QtCore import QObject, pyqtSignal
from pygments import highlight
from pygments.lexers import JavascriptLexer
from pygments.formatters import HtmlFormatter
from cryptography.fernet import Fernet
import json
import os

class ScriptManager(QObject):
    script_loaded = pyqtSignal(str, str)  # name, content
    script_saved = pyqtSignal(str)  # name
    
    def __init__(self):
        super().__init__()
        self.scripts_dir = os.path.join(os.getcwd(), 'frida_data', 'scripts')
        self.key = Fernet.generate_key()
        self.cipher_suite = Fernet(self.key)
        self._ensure_dirs()
        
    def _ensure_dirs(self):
        os.makedirs(self.scripts_dir, exist_ok=True)
        
    
    def save_script(self, name, content, encrypt=False):
        """Save script with optional encryption"""
        script_path = os.path.join(self.scripts_dir, f"{name}.js")
        metadata_path = f"{script_path}.meta"
        
        try:
            with open(script_path, 'w') as f:
                f.write(content)
            print(f"[ScriptManager] Script '{name}' saved to {script_path}")
        except Exception as e:
            print(f"[ScriptManager] Error saving script '{name}': {e}")
            
        try:
            metadata = {
                'name': name,
                'encrypted': encrypt,
                'tags': [],
                'description': '',
                'version': '1.0'
            }
            with open(metadata_path, 'w') as f:
                json.dump(metadata, f)
            print(f"[ScriptManager] Metadata saved for '{name}' to {metadata_path}")
        except Exception as e:
            print(f"[ScriptManager] Error saving metadata for '{name}': {e}")
        
        self.script_saved.emit(name)
        
    def load_script(self, name):
        """Load script and handle decryption if needed"""
        script_path = os.path.join(self.scripts_dir, f"{name}.js")
        metadata_path = f"{script_path}.meta"
        
        try:
            with open(metadata_path, 'r') as f:
                metadata = json.load(f)
                
            with open(script_path, 'r') as f:
                content = f.read()
                
            if metadata.get('encrypted', False):
                content = self.cipher_suite.decrypt(content.encode()).decode()
                
            self.script_loaded.emit(name, content)
            return content
        except Exception as e:
            print(f"Error loading script: {str(e)}")
            return None
            
    def get_highlighted_script(self, content):
        """Return HTML-formatted highlighted script"""
        return highlight(
            content,
            JavascriptLexer(),
            HtmlFormatter(style='monokai')
        )  
--- File: D:\ANDROID\FridaGUI\src\core\script_templates.py --- 
SCRIPT_TEMPLATES = {
    'API_LOGGING': '''
Java.perform(function() {
    // Common Android API hooks
    var HttpURLConnection = Java.use('java.net.HttpURLConnection');
    var OkHttpClient = Java.use('okhttp3.OkHttpClient');
    var Retrofit = Java.use('retrofit2.Retrofit');
    
    // HTTP URL Connection
    HttpURLConnection.connect.implementation = function() {
        console.log('[+] HttpURLConnection.connect() called');
        console.log('URL: ' + this.getURL().toString());
        console.log('Method: ' + this.getRequestMethod());
        this.connect();
    };
    
    // OkHttp
    OkHttpClient.newCall.implementation = function(request) {
        console.log('[+] OkHttpClient.newCall() intercepted');
        console.log('URL: ' + request.url().toString());
        console.log('Method: ' + request.method());
        console.log('Headers: ' + request.headers().toString());
        return this.newCall(request);
    };
    
    // Retrofit
    Retrofit.create.implementation = function(service) {
        console.log('[+] Retrofit API Service created');
        console.log('Service: ' + service.toString());
        return this.create(service);
    };
});
''',

    'SSL_PINNING_BYPASS': '''
Java.perform(function() {
    var TrustManager = Java.registerClass({
        name: 'com.custom.TrustManager',
        implements: [Java.use('javax.net.ssl.X509TrustManager')],
        methods: {
            checkClientTrusted: function(chain, authType) {},
            checkServerTrusted: function(chain, authType) {},
            getAcceptedIssuers: function() { return []; }
        }
    });

    var SSLContext = Java.use('javax.net.ssl.SSLContext');
    SSLContext.init.implementation = function(keyManager, trustManager, secureRandom) {
        console.log('[+] Bypassing SSL Pinning');
        var trustManagers = [TrustManager.$new()];
        this.init(keyManager, trustManagers, secureRandom);
    };
});
''',

    'APP_INFO': '''
Java.perform(function() {
    var ActivityThread = Java.use('android.app.ActivityThread');
    var Context = Java.use('android.content.Context');
    
    var currentApplication = ActivityThread.currentApplication();
    var context = currentApplication.getApplicationContext();
    
    console.log('\\n[App Information]');
    console.log('Package Name:', context.getPackageName());
    console.log('Process Name:', ActivityThread.currentProcessName());
    console.log('App Version:', context.getPackageManager().getPackageInfo(context.getPackageName(), 0).versionName.value);
    console.log('Target SDK:', context.getApplicationInfo().targetSdkVersion.value);
    
    // List all activities
    var packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 
                     Java.use('android.content.pm.PackageManager').GET_ACTIVITIES.value);
    console.log('\\n[Activities]');
    packageInfo.activities.value.forEach(function(activity) {
        console.log(activity.name.value);
    });
});
''',

    'CUSTOM_API_LOGGER': '''
Java.perform(function() {
    // Add your custom API class/method hooks here
    var targetClass = Java.use('com.example.api.ServiceClass');
    
    targetClass.apiMethod.implementation = function() {
        console.log('[+] API Call Intercepted');
        console.log('Arguments:', arguments);
        var result = this.apiMethod.apply(this, arguments);
        console.log('Result:', result);
        return result;
    };
});
'''
}  
--- File: D:\ANDROID\FridaGUI\src\gui\main_window.py --- 
from PyQt5.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
                           QPushButton, QStackedWidget, QLabel, QListWidget, QTableWidget,
                           QGroupBox, QCheckBox, QSpinBox, QMessageBox, QScrollArea,
                           QGridLayout, QLineEdit, QTextEdit, QFrame, QDialog, QFileDialog,
                           QSplitter, QApplication, QSizePolicy)
from PyQt5.QtCore import Qt, QSize, pyqtSlot, QTimer, QThread, QObject, pyqtSignal
from PyQt5.QtGui import QFont
import qtawesome as qta
from .widgets.device_panel import DevicePanel
from .widgets.process_panel import ProcessPanel
from .widgets.script_editor import ScriptEditorPanel
from .widgets.output_panel import OutputPanel
from .widgets.codeshare_browser import CodeShareBrowser
from .widgets.app_launcher import AppLauncher
from .widgets.process_monitor import ProcessMonitor as ProcessMonitorWidget
from .widgets.injection_panel import InjectionPanel
from .widgets.device_selector import DeviceSelector
from .widgets.history_page import HistoryPage
from core.history_manager import HistoryManager
from core.android_helper import AndroidHelper
from core.script_manager import ScriptManager
import frida
import subprocess
import os
import json
import requests
import sys

SETTINGS_DIR = os.path.join(os.getcwd(), 'frida_data')
FAVORITES_FILE = os.path.join(SETTINGS_DIR, 'favorites.json')

class StopScriptWorker(QObject):
    finished = pyqtSignal(bool, str)

    def __init__(self, scripts, session, pid_context, process_ended=False, parent=None):
        super().__init__(parent)
        self.scripts = scripts
        self.session = session
        self.pid_context = pid_context
        self.process_ended = process_ended

    def run(self):
        for script in self.scripts:
            if script:
                try:
                    script.unload()
                except Exception as e:
                    print(f"[StopScriptWorker] Error unloading script: {e}")
        
        if self.session and not self.session.is_detached:
            try:
                self.session.detach()
            except Exception as e:
                print(f"[StopScriptWorker] Error detaching: {e}")
                
        self.finished.emit(self.process_ended, self.pid_context)


class FridaInjectorMainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Oliver Stankiewicz's | Frida Script Manager")
        self.setMinimumSize(1400, 800)
        self.history_manager = HistoryManager()
        self.script_manager = ScriptManager()
        self.favorites = []
        self.load_favorites()
        self.current_device = None
        self.current_pid = None
        self.spawn_target = None
        self.current_session = None
        self.current_scripts = []
        self.pages = {}
        self.setup_ui()
        self.init_pages()
        
        if hasattr(self, 'codeshare_browser'):
            self.codeshare_browser.favorites_updated.connect(self.refresh_favorites)
        
        self.refresh_sidebar_recalls()

    def load_favorites(self):
        """Loads favorites list from the JSON file."""
        try:
            if os.path.exists(FAVORITES_FILE):
                with open(FAVORITES_FILE, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    loaded_scripts = data.get('scripts', [])
                    self.favorites = loaded_scripts if isinstance(loaded_scripts, list) else []
                    print(f"[Favorites] Loaded {len(self.favorites)} favorites.")
            else:
                self.favorites = []
                print("[Favorites] No favorites file found, starting empty.")
        except Exception as e:
            print(f"[Favorites] Error loading favorites: {e}. Starting empty.")
            self.favorites = []

    def save_favorites(self):
        """Saves favorites list to the JSON file."""
        try:
            os.makedirs(SETTINGS_DIR, exist_ok=True)
            with open(FAVORITES_FILE, 'w', encoding='utf-8') as f:
                json.dump({'scripts': self.favorites}, f, indent=2)
            print(f"[Favorites] Saved {len(self.favorites)} favorites.")
        except Exception as e:
            print(f"[Favorites] Error saving favorites: {e}")

    def setup_ui(self):
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QHBoxLayout(central_widget)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        sidebar = self.create_sidebar()
        layout.addWidget(sidebar)
        self.stack = QStackedWidget()
        layout.addWidget(self.stack)
        layout.setStretch(0, 1)
        layout.setStretch(1, 4)
        
        


    def create_sidebar(self):
        sidebar = QWidget()
        sidebar.setObjectName("sidebar")
        sidebar.setStyleSheet("""
            QWidget#sidebar {
                background-color: #2f3136;
                border-right: 1px solid #202225;
                min-width: 180px;
                max-width: 180px;
            }
            QPushButton {
                text-align: left; padding: 6px 8px; border: none;
                border-radius: 4px; margin: 1px 4px;
                min-height: 32px; max-height: 32px; font-size: 13px;
                color: #b9bbbe; background-color: transparent;
            }
            QPushButton:hover { background-color: #36393f; color: #ffffff; }
            QPushButton:checked { background-color: #404249; color: #ffffff; }
        """)
        layout = QVBoxLayout(sidebar)
        layout.setSpacing(1); layout.setContentsMargins(0, 5, 0, 5)
        self.nav_buttons = {}
        nav_items = [
            ("home", "Home", "fa5s.home"),
            ("inject", "Script Injection", "fa5s.syringe"),
            ("codeshare", "CodeShare", "fa5s.cloud-download-alt"),
            ("favorites", "Favorites", "fa5s.star"),
            ("history", "History", "fa5s.history"),
            ("monitor", "Process Monitor", "fa5s.desktop"),
            ("settings", "Settings", "fa5s.cog")
        ]
        for id_, text, icon in nav_items:
            btn = QPushButton(qta.icon(icon, color='#b9bbbe'), f" {text}")
            btn.setCheckable(True)
            btn.clicked.connect(lambda checked, page_id=id_: self.switch_page(page_id))
            btn.setIconSize(QSize(14, 14))
            self.nav_buttons[id_] = btn
            layout.addWidget(btn)

        self.scripts_group = QGroupBox("Recent Actions")
        self.scripts_group.setObjectName("RecentActionsGroup")
        self.scripts_group.setStyleSheet("""
            QGroupBox#RecentActionsGroup {
                border: 1px solid #4f545c;
                border-radius: 4px;
                margin-top: 10px;
                padding-top: 15px;
                font-size: 11px;
                color: #b9bbbe;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 3px 0 3px;
            }
            QLabel {
                font-size: 11px;
                color: #96989d;
                padding: 4px;
            }
            QPushButton {
                background-color: #4f545c;
                color: white;
                margin: 2px 4px;
            }
            QPushButton:hover { background-color: #5865f2; }
        """)
        
        scripts_layout = QVBoxLayout(self.scripts_group) 
        scripts_layout.setContentsMargins(5, 10, 5, 5)
        scripts_layout.setSpacing(1)

        layout.addStretch()
        layout.addWidget(self.scripts_group)
        status_layout = QHBoxLayout(); status_layout.setContentsMargins(8, 4, 8, 4)
        self.status_icon = QLabel(); self.status_icon.setPixmap(qta.icon('fa5s.circle', color='#43b581').pixmap(8, 8))
        self.status_text = QLabel("Ready"); self.status_text.setStyleSheet("color: #b9bbbe; font-size: 12px;")
        status_layout.addWidget(self.status_icon); status_layout.addWidget(self.status_text)
        layout.addLayout(status_layout)
        return sidebar
        
    def refresh_sidebar_recalls(self):
        """Refreshes the dynamic content of the sidebar's Recent Actions group."""
        if not hasattr(self, 'scripts_group'): return

        scripts_layout = self.scripts_group.layout()
        while scripts_layout.count() > 0:
            item = scripts_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

        scripts_layout.addWidget(QLabel("Saved Scripts (2 most recent):"))
        self._add_recent_saved_scripts(scripts_layout)

        scripts_layout.addWidget(QLabel("Recent Injection (History):"))
        self._add_recent_history_script(scripts_layout)


    def _add_recent_saved_scripts(self, layout: QVBoxLayout):
        """Helper to add buttons for the most recently saved scripts."""
        scripts_dir = self.script_manager.scripts_dir
        
        script_files = []
        if os.path.exists(scripts_dir):
            for file_name in os.listdir(scripts_dir):
                if file_name.endswith('.js'):
                    file_path = os.path.join(scripts_dir, file_name)
                    mtime = os.path.getmtime(file_path)
                    script_files.append((file_name, file_path, mtime))

        script_files.sort(key=lambda x: x[2], reverse=True)
        
        found_count = 0
        for name, path, _ in script_files[:2]:
            display_name = os.path.splitext(name)[0] 
            button = QPushButton(qta.icon('fa5s.file-code', color='#7289da'), f" {display_name}")
            button.setCheckable(False)
            button.clicked.connect(lambda checked, p=path: self._load_and_open_script(p)) 
            button.setToolTip(path)
            layout.addWidget(button)
            found_count += 1
            
        if found_count == 0:
            layout.addWidget(QLabel("No saved scripts.").setStyleSheet("margin-left: 5px;"))

    def _add_recent_history_script(self, layout: QVBoxLayout):
        """Helper to add a button for the most recent injected script from history."""
        recent_injections = [
            e for e in self.history_manager.history 
            if e['type'] == 'script_injection' and 'script' in e['details']
        ]
        
        if recent_injections:
            script_content = recent_injections[0]['details']['script']
            
            snippet = script_content.split('\n')[0][:30].strip().replace('"', '').replace("'", "")
            display_name = f"Last: {snippet}..." if len(snippet) > 5 else "Last Injected Script"
            
            button = QPushButton(qta.icon('fa5s.history', color='#faa61a'), f" {display_name}")
            button.setCheckable(False)
            button.clicked.connect(lambda checked, content=script_content: self.open_script_in_injector(content))
            button.setToolTip(f"Re-load script injected at {recent_injections[0]['timestamp']}")
            layout.addWidget(button)
        else:
            layout.addWidget(QLabel("No recent injections.").setStyleSheet("margin-left: 5px;"))

    def _load_and_open_script(self, file_path):
        """Loads script content from a given file path and opens it in the injector."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                script_content = f.read()
            self.open_script_in_injector(script_content)
        except Exception as e:
            QMessageBox.critical(self, "Load Error", f"Failed to load script from disk: {str(e)}")
            self.log_panel.append_output(f"[-] Failed to load script from {file_path}: {e}")

    def init_pages(self):
        self.pages = {
            'home': None, 'inject': None, 'codeshare': None, 
            'favorites': None, 'history': None, 'monitor': None, 'settings': None
        }

        try: self.pages['home'] = self.create_home_page()
        except Exception as e: print(f"Error creating home page: {e}")
        
        try: self.pages['inject'] = self.create_injection_page()
        except Exception as e: print(f"Error creating injection page: {e}")
        
        try: self.pages['codeshare'] = self.create_codeshare_page()
        except Exception as e: print(f"Error creating codeshare page: {e}")
        
        try: self.pages['favorites'] = self.create_favorites_page()
        except Exception as e: print(f"Error creating favorites page: {e}")
        
        try: self.pages['history'] = self.create_history_page()
        except Exception as e: print(f"Error creating history page: {e}")
        
        try: self.pages['monitor'] = self.create_monitor_page()
        except Exception as e: print(f"Error creating monitor page: {e}")
        
        try: self.pages['settings'] = self.create_settings_page()
        except Exception as e: print(f"Error creating settings page: {e}")

        for page_id, page_widget in self.pages.items():
            if page_widget:
                self.stack.addWidget(page_widget)
            else:
                if page_id in self.nav_buttons:
                    self.nav_buttons[page_id].setEnabled(False)
                    print(f"Disabled nav button for failed page: {page_id}")

        initial_page = 'home'
        if initial_page in self.pages and self.pages[initial_page]:
            self.stack.setCurrentWidget(self.pages[initial_page])
            if initial_page in self.nav_buttons:
                self.nav_buttons[initial_page].setChecked(True)
        elif any(self.pages.values()):
            valid_page_ids = [pid for pid in self.nav_buttons if pid in self.pages and self.pages[pid]]
            if valid_page_ids:
                first_page_id = valid_page_ids[0]
                self.stack.setCurrentWidget(self.pages[first_page_id])
                if first_page_id in self.nav_buttons:
                    self.nav_buttons[first_page_id].setChecked(True)

    def switch_page(self, page_id):
        if page_id not in self.pages or not self.pages[page_id]:
            print(f"Error: Cannot switch to non-existent page '{page_id}'.")
            return
        target_widget = self.pages[page_id]
        if self.stack.currentWidget() == target_widget: return
        for id_, btn in self.nav_buttons.items():
            if btn: btn.setChecked(id_ == page_id)
        self.stack.setCurrentWidget(target_widget)
        print(f"[MainWindow] Switched to page: {page_id}")

    def create_home_page(self):
        page = QWidget(); layout = QVBoxLayout(page); layout.setSpacing(20); layout.setContentsMargins(20, 20, 20, 20)
        header = QFrame(); header.setStyleSheet("QFrame { background-color: #2f3136; border-radius: 10px; padding: 20px; } QLabel { color: white; }")
        header_layout = QVBoxLayout(header)
        title = QLabel("Welcome to Frida Script Manager"); title.setStyleSheet("font-size: 24px; font-weight: bold;")
        subtitle = QLabel("A powerful GUI tool for Frida script management and injection"); subtitle.setStyleSheet("font-size: 16px; color: #b9bbbe;")
        author = QLabel("Created by Oliver Stankiewicz"); author.setStyleSheet("font-size: 14px; color: #7289da;")
        header_layout.addWidget(title); header_layout.addWidget(subtitle); header_layout.addWidget(author)
        actions = QFrame(); actions.setStyleSheet("QFrame { background-color: #2f3136; border-radius: 10px; padding: 20px; } QLabel { color: white; } QPushButton { background-color: #7289da; border-radius: 5px; padding: 10px; color: white; text-align: left; font-size: 14px; } QPushButton:hover { background-color: #677bc4; }")
        actions_layout = QVBoxLayout(actions); actions_title = QLabel("Quick Actions"); actions_title.setStyleSheet("font-size: 18px; font-weight: bold; margin-bottom: 10px;")
        inject_btn = QPushButton(qta.icon('fa5s.syringe'), " Script Injection"); inject_btn.clicked.connect(lambda: self.switch_page('inject'))
        browse_btn = QPushButton(qta.icon('fa5s.cloud-download-alt'), " Browse CodeShare"); browse_btn.clicked.connect(lambda: self.switch_page('codeshare'))
        favorites_btn = QPushButton(qta.icon('fa5s.star'), " View Favorites"); favorites_btn.clicked.connect(lambda: self.switch_page('favorites'))
        monitor_btn = QPushButton(qta.icon('fa5s.desktop'), " Process Monitor"); monitor_btn.clicked.connect(lambda: self.switch_page('monitor'))
        actions_layout.addWidget(actions_title); actions_layout.addWidget(inject_btn); actions_layout.addWidget(browse_btn); actions_layout.addWidget(favorites_btn); actions_layout.addWidget(monitor_btn)
        layout.addWidget(header); layout.addWidget(actions); layout.addStretch()
        return page

    def create_injection_page(self):
        page = QWidget()
        layout = QVBoxLayout(page)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)
        try:
            self.device_selector = DeviceSelector()
            self.script_editor = ScriptEditorPanel()
            self.injection_panel = InjectionPanel()
            
            
            self.script_output_panel = OutputPanel()
            self.script_output_panel.set_title("Script Output (console.log / send)") 
            self.script_output_panel.output_area.setPlaceholderText("Script output (from send() and console.log()) will appear here...")

            self.log_panel = OutputPanel()
            self.log_panel.set_title("Application Logs / Status") 
            self.log_panel.output_area.setPlaceholderText("Application logs (e.g., 'Attached', 'Script loaded', 'Error') will appear here...")
            
        except NameError as ne:
            print(f"Error instantiating injection widgets: {ne}. Check imports.")
            QMessageBox.critical(self, "Init Error", f"Failed to create injection UI component: {ne}")
            return None
            
        self.injection_panel.injection_started.connect(self.handle_injection_request)
        self.injection_panel.injection_stopped.connect(self.stop_injection)
        self.injection_panel.message_posted.connect(self.post_message_to_script)
        self.injection_panel.script_save_requested.connect(self.handle_save_script_request)

        editor_widget = self.script_editor.get_editor_widget()
        if editor_widget:
            if hasattr(self.injection_panel, 'set_script_editor_widget'):
                self.injection_panel.set_script_editor_widget(editor_widget)
                print("[MainWindow] Linked InjectionPanel to ScriptEditorPanel's editor.")
            else:
                print("CRITICAL ERROR: InjectionPanel has no 'set_script_editor_widget' method!")
                QMessageBox.critical(self, "Code Error", "InjectionPanel is missing 'set_script_editor_widget'. Cannot link editor.")
                return None
        else:
            print("CRITICAL ERROR: Could not get editor widget from ScriptEditorPanel!")
            QMessageBox.critical(self, "Init Error", "Failed to get script editor widget.")
            return None

        editor_vs_outputs_splitter = QSplitter(Qt.Vertical)
        editor_vs_outputs_splitter.addWidget(self.script_editor)

        outputs_splitter = QSplitter(Qt.Vertical)
        outputs_splitter.addWidget(self.script_output_panel)
        outputs_splitter.addWidget(self.log_panel)
        outputs_splitter.setSizes([250, 100])

        editor_vs_outputs_splitter.addWidget(outputs_splitter)
        editor_vs_outputs_splitter.setSizes([400, 350])

        layout.addWidget(self.device_selector)
        layout.addWidget(editor_vs_outputs_splitter)
        layout.addWidget(self.injection_panel)
        
        try:
            self.device_selector.process_selected.connect(self._update_current_selection)
            self.device_selector.application_selected_for_spawn.connect(self._update_spawn_target)
            self.device_selector.process_selected.connect(self.injection_panel.set_process)

        except TypeError as te:
            print(f"SIGNAL/SLOT TYPE ERROR during connection: {te}")
            QMessageBox.critical(self, "Signal/Slot Error", f"Connection failed due to type mismatch: {te}\nCheck @pyqtSlot decorators and signal definitions.")
            return None
        return page

    def handle_save_script_request(self, name, content):
        """Saves script using ScriptManager, updates history, and provides user feedback."""
        try:
            self.script_manager.save_script(name, content)
            
            script_file_path = os.path.join(self.script_manager.scripts_dir, f"{name}.js")
            
            self.history_manager.add_entry('script_save', {
                'name': f"{name}.js",
                'path': script_file_path,
                'size': len(content),
                'snippet': content[:50] + "..."
            })
            
            QMessageBox.information(self, "Save Success", 
                                    f"Script '{name}.js' saved permanently to:\n{script_file_path}")
                                    
            if hasattr(self.injection_panel, 'save_name_input'):
                self.injection_panel.save_name_input.clear()
            
            self.refresh_sidebar_recalls()

        except Exception as e:
            QMessageBox.critical(self, "Save Error", f"Failed to save script: {str(e)}")
            self.log_panel.append_output(f"[-] Error saving script: {e}")

    def _update_current_selection(self, device_id, pid):
        pid_int = None
        if pid is not None:
            try:
                pid_int = int(pid)
                if pid_int <= 0: pid_int = None
            except (ValueError, TypeError):
                pid_int = None
        else: pid_int = None
        
        self.current_device = device_id
        self.current_pid = pid_int
        self.spawn_target = None
        
        status_text = "Ready"; icon_color = '#99aab5'
        if self.current_device and self.current_pid:
            status_text = f"PID: {self.current_pid} @ {self.current_device}"; icon_color = '#43b581'
        elif self.current_device:
            status_text = f"Device: {self.current_device} | No process"; icon_color = '#faa61a'
        else:
            status_text = "No device selected"
        self.status_text.setText(status_text)
        self.status_icon.setPixmap(qta.icon('fa5s.circle', color=icon_color).pixmap(10, 10))
        print(f"[MainWindow] Selection Updated: Device={self.current_device}, PID={self.current_pid}")

    def _update_spawn_target(self, device_id, app_identifier, script_paths, frida_options):
        self.current_device = device_id
        self.spawn_target = app_identifier
        self.current_pid = None

        status_text = f"Spawn: {self.spawn_target} @ {self.current_device}"
        self.status_text.setText(status_text)
        self.status_icon.setPixmap(qta.icon('fa5s.circle', color='#7289da').pixmap(10, 10))

        print(f"[MainWindow] Spawn Target Set: {app_identifier} on {device_id}")
        print(f"    Scripts: {len(script_paths)}")
        print(f"    Options: {frida_options}")

        self.switch_page('inject')

        self._start_multi_script_spawn(device_id, app_identifier, script_paths, frida_options)

    def _force_stop_application(self, device_id, app_identifier):
        """Force stops the Android application using ADB."""
        cmd = ["adb", "-s", device_id, "shell", "am", "force-stop", app_identifier]
        try:
            result = subprocess.run(cmd, check=True, capture_output=True, text=True)
            self.log_panel.append_output(f"[*] Force stopped app: {app_identifier}")
            print(f"[Force Stop] Success: {result.stdout.strip()}")
        except subprocess.CalledProcessError as e:
            error_msg = e.stderr.strip() if e.stderr else "Unknown ADB error"
            self.log_panel.append_output(f"[-] Failed to force stop: {error_msg}")
            print(f"[Force Stop] Failed: {error_msg}")
            raise Exception(f"Force stop failed: {error_msg}")

    def _start_multi_script_spawn(self, device_id, app_identifier, script_paths, frida_options):
        """Launches app and injects scripts one by one."""
        try:
            device = frida.get_device(device_id)
            if device.type == 'usb' and not AndroidHelper.is_frida_running(device_id):
                raise Exception("Frida server not running on device.")

            self._force_stop_application(device_id, app_identifier)
            
            import time
            time.sleep(0.011)
            self.log_panel.append_output(f"[*] Proceeding with spawn after delay...")

            self.log_panel.append_output(f"[*] Spawning '{app_identifier}'...")
            print(f"[Spawn] Spawning {app_identifier}...")
            pid = device.spawn([app_identifier])

            self._update_current_selection(device_id, pid)
            self.log_panel.append_output(f"[+] Spawned PID: {pid}")

            session = device.attach(pid)
            self.current_session = session

            def on_detached(reason, crash):
                if self.current_session is not None:
                    print(f"[Inject] Session detached! Reason: {reason}")
                    self.log_panel.append_output(f"[!] Session detached: {reason}" + (" (App Crashed)" if crash else "")) 
                    self.stop_injection(process_ended=crash is not None)
                    if hasattr(self, 'injection_panel'):
                        self.injection_panel.injection_stopped_externally()

            session.on('detached', on_detached)

            self.current_scripts = []

            def on_message(message, data):
                try:
                    msg_type = message.get('type') if isinstance(message, dict) else 'unknown'
                    
                    if msg_type == 'send':
                        payload = message.get('payload', '')
                        if isinstance(payload, dict):
                            log_type = payload.get('type', 'data').upper()
                            log_msg = payload.get('message', str(payload))
                            log_entry = f"[{log_type}] {log_msg}"
                        else:
                            log_entry = f"[SCRIPT SEND] {payload}"
                    elif msg_type == 'log':
                        level = message.get('level', 'info').upper()
                        payload = message.get('payload', '')
                        log_entry = f"[CONSOLE.{level}] {payload}"
                    elif msg_type == 'error':
                        description = message.get('description', 'Unknown Error')
                        stack = message.get('stack', 'No stack trace')
                        log_entry = f"[SCRIPT ERROR] {description}\n{stack}"
                    else:
                        log_entry = f"[{msg_type.upper()}] {message}"
                    
                    if hasattr(self, 'script_output_panel'):
                        self.script_output_panel.append_output(log_entry)

                except Exception as msg_e:
                    if hasattr(self, 'log_panel'):
                        self.log_panel.append_output(f"[APP ERROR] Error processing Frida message: {msg_e}")

            for i, script_path in enumerate(script_paths):
                self.log_panel.append_output(f"[*] Loading script {i+1}/{len(script_paths)}: {os.path.basename(script_path)}")
                print(f"   Loading script {i+1}: {script_path}")

                with open(script_path, 'r', encoding='utf-8') as f:
                    script_content = f.read()

                script = session.create_script(script_content)
                script.on('message', on_message)
                script.load()
                self.current_scripts.append(script)
                self.log_panel.append_output(f"[+] Script {i+1} loaded.")

            print(f"[Spawn] Resuming PID {pid}...")
            device.resume(pid)
            self.log_panel.append_output(f"[*] Resumed PID: {pid}")
            self.log_panel.append_output("[+] All scripts injected and app resumed.")

            if hasattr(self, 'injection_panel'):
                self.injection_panel.injection_succeeded()

        except Exception as e:
            import sys
            ex_type, ex_value, ex_traceback = sys.exc_info()
            error_msg = str(ex_value) if ex_value else "Unknown Spawn Error (No Exception Value)"
            
            self.log_panel.append_output(f"[-] Spawn failed: {error_msg}")
            print(f"[Spawn] Failed: {error_msg}")
            if hasattr(self, 'injection_panel'):
                self.injection_panel.injection_failed(error_msg)



    def create_codeshare_page(self):
            page = QWidget(); layout = QVBoxLayout(page); layout.setContentsMargins(0,0,0,0)
            self.codeshare_browser = CodeShareBrowser()
            self.codeshare_browser.open_in_injector.connect(self.open_script_in_injector)
            layout.addWidget(self.codeshare_browser)
            return page

    def create_favorites_page(self):
        page = QWidget(); layout = QVBoxLayout(page); layout.setContentsMargins(10, 10, 10, 10); layout.setSpacing(10)
        toolbar = QHBoxLayout(); search_input = QLineEdit(); search_input.setPlaceholderText("Search favorites..."); search_input.textChanged.connect(self.filter_favorites)
        upload_btn = QPushButton(qta.icon('fa5s.file-upload'), "Upload Script"); upload_btn.clicked.connect(self.upload_script)
        toolbar.addWidget(search_input); toolbar.addWidget(upload_btn)
        scroll = QScrollArea(); scroll.setWidgetResizable(True); scroll.setStyleSheet("QScrollArea { border: none; background-color: #36393f; }")
        self.favorites_grid = QWidget(); self.favorites_grid.setStyleSheet("QWidget { background-color: #36393f; }")
        self.favorites_grid_layout = QGridLayout(self.favorites_grid); self.favorites_grid_layout.setSpacing(10); self.favorites_grid_layout.setContentsMargins(15, 15, 15, 15)
        scroll.setWidget(self.favorites_grid); layout.addLayout(toolbar); layout.addWidget(scroll)
        self.refresh_favorites()
        return page

    def create_history_page(self):
        page = QWidget(); layout = QVBoxLayout(page); layout.setContentsMargins(10, 10, 10, 10)
        self.history_page = HistoryPage(self.history_manager)
        self.history_page.script_selected.connect(self.open_script_in_injector)
        layout.addWidget(self.history_page)
        return page

    def create_monitor_page(self):
        page = QWidget(); layout = QVBoxLayout(page); layout.setContentsMargins(10, 10, 10, 10)
        self.process_monitor_widget = ProcessMonitorWidget(main_window=self)
        layout.addWidget(self.process_monitor_widget)
        return page

    def create_settings_page(self):
        page = QWidget(); layout = QVBoxLayout(page); layout.setContentsMargins(20, 20, 20, 20); layout.setSpacing(15)
        settings_categories = [
            ("General", [("Auto-inject on launch", "checkbox"), ("Save script history", "checkbox"), ("Dark theme", "checkbox")]),
            ("Script Editor", [("Font size", "spinbox"), ("Show line numbers", "checkbox"), ("Auto-completion", "checkbox")]),
            ("Monitoring", [("Update interval", "spinbox"), ("Show memory usage", "checkbox"), ("Log to file", "checkbox")])
        ]
        for category, settings in settings_categories:
            group = QGroupBox(category); group_layout = QVBoxLayout()
            for setting_name, setting_type in settings:
                setting_layout = QHBoxLayout(); setting_layout.addWidget(QLabel(setting_name))
                widget = QCheckBox() if setting_type == "checkbox" else QSpinBox()
                setting_layout.addWidget(widget); group_layout.addLayout(setting_layout)
            group.setLayout(group_layout); layout.addWidget(group)
        layout.addStretch()
        return page

    def handle_injection_request(self, script_content, pid):
        """Unified injection handler for both attaching to a running process and spawning a new one."""
        device = None
        session = None
        
        is_attach_mode = self.current_pid is not None and self.current_pid == pid
        is_spawn_mode = self.spawn_target is not None and not is_attach_mode

        try:
            if is_attach_mode:
                print(f"[Inject] Handling ATTACH request for PID: {self.current_pid}")
                device_id = self.current_device
                attach_target = self.current_pid
                
                device = frida.get_device(device_id)
                if device.type == 'usb' and not AndroidHelper.is_frida_running(device_id):
                    raise Exception(f"Frida server not running on {device_id}.")
                
                print(f"[Inject] Attaching to PID: {attach_target}...")
                session = device.attach(attach_target)
                self.log_panel.append_output(f"[+] Attached to PID: {attach_target}")

            elif is_spawn_mode:
                print(f"[Inject] Handling SPAWN request for App: {self.spawn_target}")
                device_id = self.current_device
                app_identifier = self.spawn_target

                device = frida.get_device(device_id)
                if device.type == 'usb' and not AndroidHelper.is_frida_running(device_id):
                    raise Exception(f"Frida server not running on {device_id}.")
                
                print(f"[Inject] Spawning '{app_identifier}'...")
                self.log_panel.append_output(f"[*] Spawning '{app_identifier}'...")
                new_pid = device.spawn([app_identifier])
                
                self._update_current_selection(device_id, new_pid)
                
                print(f"[Inject] Attaching to newly spawned PID: {new_pid}...")
                session = device.attach(new_pid)
                self.log_panel.append_output(f"[+] Attached to spawned PID: {new_pid}")
            
            else:
                raise Exception("Injection target mismatch. Re-select the process or app.")
            
            if not session or session.is_detached:
                raise Exception("Failed to establish a Frida session.")
            
            self.current_session = session
            
            def on_detached(reason, crash):
                if self.current_session is not None:
                    print(f"[Inject] Session detached! Reason: {reason}")
                    self.log_panel.append_output(f"[!] Session detached: {reason}" + (" (App Crashed)" if crash else "")) 
                    self.stop_injection(process_ended=crash is not None)
                    if hasattr(self, 'injection_panel'):
                        self.injection_panel.injection_stopped_externally()

            session.on('detached', on_detached)
            
            print("[Inject] Creating script object...")
            script = session.create_script(script_content)
            self.current_scripts = [script]
            
            def on_message(message, data):
                try:
                    msg_type = message.get('type') if isinstance(message, dict) else 'unknown'
                    
                    if msg_type == 'send':
                        payload = message.get('payload', '')
                        if isinstance(payload, dict):
                            log_type = payload.get('type', 'data').upper()
                            log_msg = payload.get('message', str(payload))
                            log_entry = f"[{log_type}] {log_msg}"
                        else:
                            log_entry = f"[SCRIPT SEND] {payload}"
                    elif msg_type == 'log':
                        level = message.get('level', 'info').upper()
                        payload = message.get('payload', '')
                        log_entry = f"[CONSOLE.{level}] {payload}"
                    elif msg_type == 'error':
                        description = message.get('description', 'Unknown Error')
                        stack = message.get('stack', 'No stack trace')
                        log_entry = f"[SCRIPT ERROR] {description}\n{stack}"
                    else:
                        log_entry = f"[{msg_type.upper()}] {message}"
                    
                    if hasattr(self, 'script_output_panel'):
                        self.script_output_panel.append_output(log_entry)

                except Exception as msg_e:
                    if hasattr(self, 'log_panel'):
                        self.log_panel.append_output(f"[APP ERROR] Error processing Frida message: {msg_e}")

            script.on('message', on_message)
            
            print("[Inject] Loading script...")
            script.load()
            print("[Inject] Script loaded.")
            self.log_panel.append_output("[+] Script loaded successfully.")
            
            if is_spawn_mode:
                print(f"[Inject] Resuming PID: {self.current_pid}")
                device.resume(self.current_pid)
                self.log_panel.append_output(f"[*] Resumed PID: {self.current_pid}")
            
            if hasattr(self, 'injection_panel'):
                self.injection_panel.injection_succeeded()
            
            self.history_manager.add_entry('script_injection', {
                'script': script_content,
                'pid': self.current_pid, 'device': self.current_device, 'status': 'success'
            })

        except Exception as e:
            error_msg = f"{str(e)}"
            print(f"[Inject] Injection process failed: {error_msg}")
            self.log_panel.append_output(f"[-] Injection Error: {error_msg}")
            if hasattr(self, 'injection_panel'):
                self.injection_panel.injection_failed(error_msg)
            self.stop_injection()
            self.history_manager.add_entry('script_injection', {
                'script': script_content, 'pid': pid, 'device': self.current_device, 'status': 'failed', 'error': error_msg
            })


    def stop_injection(self, process_ended=False):
        """Stop the current injection and clean up state."""
        pid_context = str(self.current_pid) if self.current_pid else "N/A"
        if getattr(self, '_stopping', False): return
        
        if not self.current_scripts and not self.current_session:
            self._finish_cleanup(pid_context, process_ended)
            return

        self._stopping = True
        self.log_panel.append_output(f"[*] Attempting to stop script for PID: {pid_context}")

        self.stop_thread = QThread()
        self.stop_worker = StopScriptWorker(
            self.current_scripts, 
            self.current_session, 
            pid_context, 
            process_ended
        )
        
        self.stop_worker.moveToThread(self.stop_thread)
        
        self.stop_thread.started.connect(self.stop_worker.run)
        self.stop_worker.finished.connect(self._finish_cleanup_from_worker)
        
        self.stop_worker.finished.connect(self.stop_thread.quit)
        self.stop_worker.finished.connect(self.stop_worker.deleteLater)
        self.stop_thread.finished.connect(self.stop_thread.deleteLater)
        
        self.current_scripts = []
        self.current_session = None

        self.stop_thread.start()

    def _finish_cleanup_from_worker(self, process_ended, pid_context):
        self._finish_cleanup(pid_context, process_ended)

    def _finish_cleanup(self, pid_context, process_ended):
        was_running = pid_context != "N/A"
        self.spawn_target = None

        if process_ended:
            self.log_panel.append_output(f"[*] Target process {pid_context} ended.")
            self.current_pid = None
        elif was_running:
            self.log_panel.append_output("[*] Script injection stopped.")

        if hasattr(self, 'injection_panel'):
            self.injection_panel.injection_stopped_update()

        self._update_current_selection(self.current_device, self.current_pid)
        self._stopping = False

    def on_process_selected(self, device_id, pid):
        pass

    def open_in_injector(self, device_id, pid):
        print(f"[MainWindow] Opening Injector for: {pid}@{device_id}")
        self.switch_page('inject')
        if hasattr(self, 'device_selector'):
            self.device_selector.select_device(device_id)
            QTimer.singleShot(100, lambda: self.device_selector.select_process(pid))
        else: print("Error: device_selector not found")

    def open_script_in_injector(self, code):
        print("[MainWindow] Opening script in injector editor.")
        self.switch_page('inject')
        if hasattr(self, 'script_editor'):
            self.script_editor.set_script(code)
            editor_widget = self.script_editor.get_editor_widget()
            if editor_widget: editor_widget.setFocus()
        else: print("Error: script_editor panel not found")

    def post_message_to_script(self, message):
        """Posts a message from the REPL input to the running script."""
        if self.current_scripts and self.current_session and not self.current_session.is_detached:
            try:
                # Post to the last script, assuming it handles REPL
                self.current_scripts[-1].post({'type': 'input', 'payload': message})
                self.script_output_panel.append_output(f"[APP -> SCRIPT] {message}")
            except Exception as e:
                self.log_panel.append_output(f"[APP ERROR] Failed to post message: {e}")
        else:
            self.log_panel.append_output("[APP ERROR] Cannot send message: no active script session.")

    def fetch_scripts(self):
        """Fetch scripts from API"""
        try:
            response = requests.get(self.api_url, timeout=15)
            response.raise_for_status()
            scripts = response.json()
            
            sort_option = self.sort_combo.currentText()
            if sort_option == ' Most Popular':
                scripts.sort(key=lambda x: x.get('likes', 0), reverse=True)
            elif sort_option == ' Most Viewed':
                scripts.sort(key=lambda x: x.get('seen', 0), reverse=True)
            
            return scripts
        except requests.exceptions.RequestException as e:
            print(f"Error fetching scripts (RequestException): {e}")
            QMessageBox.warning(self, "Network Error", f"Failed to fetch CodeShare scripts: {e}. Check internet connection.")
            return []
        except Exception as e:
            print(f"Error fetching scripts: {e}")
            return []

    def refresh_favorites(self):
        """Refresh the favorites grid"""
        for i in reversed(range(self.favorites_grid_layout.count())): 
            widget = self.favorites_grid_layout.itemAt(i).widget()
            if widget:
                widget.setParent(None)
            
        try:
            all_scripts = self.fetch_scripts()
            
            favorite_scripts = [s for s in all_scripts if s['id'] in self.favorites]
            
            if favorite_scripts:
                for idx, script_info in enumerate(favorite_scripts):
                    row = idx // 3
                    col = idx % 3
                    card = self.create_script_card(script_info)
                    self.favorites_grid_layout.addWidget(card, row, col)
            else:
                msg = QLabel("No favorite scripts yet.\nBrowse scripts and click the  to add favorites!")
                msg.setAlignment(Qt.AlignCenter)
                msg.setStyleSheet("""
                    color: #b9bbbe;
                    font-size: 14px;
                    padding: 20px;
                """)
                self.favorites_grid_layout.addWidget(msg, 0, 0, 1, 3)
                
        except Exception as e:
            print(f"Error refreshing favorites: {e}")
            error_msg = QLabel(f"Error loading favorites: {str(e)}")
            error_msg.setStyleSheet("color: #ff4444;")
            self.favorites_grid_layout.addWidget(error_msg, 0, 0, 1, 3)

    def filter_favorites(self, text):
        search_text = text.lower()
        layout = getattr(self, 'favorites_grid_layout', None)
        if not layout: return
        no_fav_label = None
        has_visible_card = False
      
        for i in range(layout.count()):
            widget = layout.itemAt(i).widget()
            if widget and isinstance(widget, QFrame):
                labels = widget.findChildren(QLabel)
                title_label = labels[0] if labels else None
                desc_label = labels[2] if len(labels) > 2 else None
 
                if title_label and desc_label:
                     title_matches = search_text in title_label.text().lower()
                     desc_matches = search_text in desc_label.text().lower()
                     is_visible = not search_text or title_matches or desc_matches
    
                     widget.setVisible(is_visible)
                     if is_visible: has_visible_card = True
            elif widget and isinstance(widget, QLabel): 
                no_fav_label = widget
        if no_fav_label: 
            no_fav_label.setVisible(not has_visible_card and not search_text)

    def upload_script(self):
        start_dir = os.getcwd()
        file_path, _ = QFileDialog.getOpenFileName(self, "Upload Script", start_dir, "JavaScript Files (*.js);;All Files (*.*)")
        if file_path:
            try:
                with open(file_path, 'r', encoding='utf-8') as f: 
                    script_content = f.read()
                script_name = os.path.basename(file_path)
                script_info = {
                    'id': f"custom/{script_name}",
                    'title': script_name,
                    'author': 'Custom Script',
                    'description': 'Uploaded custom script',
                    'likes': 0,
                    'seen': 0,
                    'content': script_content
                }
                self.add_to_favorites(script_info)
            except Exception as e: 
                QMessageBox.critical(self, "Error", f"Failed to upload script: {str(e)}")

    def add_to_favorites(self, script_info):
        if not any(isinstance(s, dict) and s.get('id') == script_info.get('id') for s in self.favorites):
            self.favorites.append(script_info)
            self.save_favorites()
        card = self.create_favorite_card(script_info)
        layout = getattr(self, 'favorites_grid_layout', None)
        if card and layout: 
            count = layout.count()
            row, col = divmod(count, 3)
            layout.addWidget(card, row, col)

    def create_favorite_card(self, script_info):
        card = QFrame()
        card.setStyleSheet("QFrame { background-color: #2f3136; border-radius: 8px; padding: 10px; } QFrame:hover { background-color: #40444b; }")
        layout = QVBoxLayout(card)
        title = QLabel(script_info.get('title', 'N/A'))
        title.setStyleSheet("font-size: 14px; font-weight: bold; color: white;")
        author = QLabel(f"by {script_info.get('author', 'N/A')}")
        author.setStyleSheet("color: #b9bbbe;")
        desc_text = script_info.get('description', '')
        desc = QLabel(desc_text[:100] + ('...' if len(desc_text) > 100 else ''))
        desc.setWordWrap(True)
        desc.setStyleSheet("color: #b9bbbe;")
        buttons = QHBoxLayout()
        view_btn = QPushButton("View")
        view_btn.clicked.connect(lambda checked, si=script_info: self.view_favorite(si))
        inject_btn = QPushButton("Inject")
        inject_btn.clicked.connect(lambda checked, si=script_info: self.open_script_in_injector(si.get('content', '')))
        remove_btn = QPushButton("Remove")
        remove_btn.clicked.connect(lambda checked, si=script_info, c=card: self.remove_from_favorites(si, c))
        buttons.addWidget(view_btn)
        buttons.addWidget(inject_btn)
        buttons.addWidget(remove_btn)
        buttons.addStretch()
        layout.addWidget(title)
        layout.addWidget(author)
        layout.addWidget(desc)
        layout.addLayout(buttons)
        return card

    def view_favorite(self, script_info):
        dialog = QDialog(self)
        dialog.setWindowTitle(f"View Script - {script_info.get('title', 'N/A')}")
        dialog.resize(800, 600)
        layout = QVBoxLayout(dialog)
        content = QTextEdit()
        content.setReadOnly(True)
        try: content.setFont(QFont('Consolas', 15))
        except: pass
        content.setText(script_info.get('content', 'Script content not available'))
        buttons = QHBoxLayout()
        copy_btn = QPushButton(" Copy")
        copy_btn.clicked.connect(lambda: self.copy_to_clipboard(content.toPlainText()))
        inject_btn = QPushButton("Inject")
        inject_btn.clicked.connect(lambda: self.open_script_in_injector(content.toPlainText()))
        buttons.addWidget(copy_btn)
        buttons.addWidget(inject_btn)
        buttons.addStretch()
        layout.addWidget(content)
        layout.addLayout(buttons)
        dialog.exec_()

    def remove_from_favorites(self, script_info, card):
        script_id = script_info.get('id')
        if not script_id: return
        reply = QMessageBox.question(self, "Remove Favorite", f"Remove {script_info.get('title', 'N/A')} from favorites?", QMessageBox.Yes | QMessageBox.No)
        if reply == QMessageBox.Yes:
            card.setParent(None)
            if script_id.startswith('custom/'):
                self.favorites = [s for s in self.favorites if not (isinstance(s, dict) and s.get('id') == script_id)]
                self.save_favorites()
            elif hasattr(self, 'codeshare_browser') and hasattr(self.codeshare_browser, 'favorites'):
                 try: 
                     self.codeshare_browser.favorites.remove(script_id)
                     self.codeshare_browser.save_favorites()
                 except: pass
            self.refresh_favorites()

    def copy_to_clipboard(self, text):
        QApplication.clipboard().setText(text)
        QMessageBox.information(self, "Success", "Copied to clipboard!")

    def cleanup(self):
        """Cleanup resources before closing."""
        if hasattr(self, 'device_selector') and hasattr(self.device_selector, 'cleanup'):
            self.device_selector.cleanup()

    def closeEvent(self, event):
        """Handle window close event."""
        self.cleanup()
        event.accept() 
--- File: D:\ANDROID\FridaGUI\src\gui\__init__.py --- 
# Empty file to make the directory a Python package  
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\app_launcher.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, 
                           QLineEdit, QComboBox, QLabel, QTableWidget, 
                           QTableWidgetItem, QMenu, QAction, QCheckBox,
                           QFileDialog, QGroupBox)
from PyQt5.QtCore import pyqtSignal, Qt
import subprocess
import json
import os
import qtawesome as qta
import sys

class AppLauncher(QWidget):
    app_launched = pyqtSignal(str, int)  # package_name, pid
    script_selected = pyqtSignal(str)  # script content
    
    def __init__(self):
        super().__init__()
        self.favorites_file = os.path.join(os.getcwd(), 'frida_data', 'favorites.json')
        self.scripts_dir = os.path.join(os.getcwd(), 'frida_data', 'scripts')
        self.load_favorites()
        self.setup_ui()
        
    def setup_ui(self):
        layout = QVBoxLayout(self)
        
        # Quick Launch Section
        quick_launch_group = QGroupBox("Quick Launch")
        quick_launch_layout = QVBoxLayout()
        
        # Package input
        package_layout = QHBoxLayout()
        self.package_input = QLineEdit()
        self.package_input.setPlaceholderText("Enter package name or path...")
        self.launch_button = QPushButton("Launch")
        self.launch_button.setIcon(qta.icon('fa5s.play'))
        self.launch_button.clicked.connect(self.launch_app)
        package_layout.addWidget(self.package_input)
        package_layout.addWidget(self.launch_button)
        
        # Script Selection
        script_layout = QHBoxLayout()
        self.script_input = QLineEdit()
        self.script_input.setPlaceholderText("Select Frida script file...")
        self.script_input.setReadOnly(True)
        
        self.browse_script_btn = QPushButton("Browse")
        self.browse_script_btn.setIcon(qta.icon('fa5s.folder-open'))
        self.browse_script_btn.clicked.connect(self.browse_script)
        
        self.edit_script_btn = QPushButton("Edit")
        self.edit_script_btn.setIcon(qta.icon('fa5s.edit'))
        self.edit_script_btn.clicked.connect(self.edit_script)
        self.edit_script_btn.setEnabled(False)
        
        script_layout.addWidget(self.script_input)
        script_layout.addWidget(self.browse_script_btn)
        script_layout.addWidget(self.edit_script_btn)
        
        # Launch Options
        options_layout = QHBoxLayout()
        self.debug_check = QCheckBox("Debug Mode")
        self.wait_check = QCheckBox("Wait for Debugger")
        self.inject_check = QCheckBox("Auto-Inject Script")
        self.inject_check.toggled.connect(self.toggle_script_selection)
        
        options_layout.addWidget(self.debug_check)
        options_layout.addWidget(self.wait_check)
        options_layout.addWidget(self.inject_check)
        
        quick_launch_layout.addLayout(package_layout)
        quick_launch_layout.addLayout(script_layout)
        quick_launch_layout.addLayout(options_layout)
        quick_launch_group.setLayout(quick_launch_layout)
        
        # Favorites Section
        favorites_group = QGroupBox("Favorites")
        favorites_layout = QVBoxLayout()
        
        self.favorites_table = QTableWidget(0, 4)  # Added column for script
        self.favorites_table.setHorizontalHeaderLabels(["Name", "Package", "Script", "Actions"])
        self.favorites_table.horizontalHeader().setStretchLastSection(True)
        self.favorites_table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.favorites_table.customContextMenuRequested.connect(self.show_context_menu)
        
        favorites_layout.addWidget(self.favorites_table)
        favorites_group.setLayout(favorites_layout)
        
        # Recent Apps Section
        recent_group = QGroupBox("Recent Apps")
        recent_layout = QHBoxLayout()
        self.recent_combo = QComboBox()
        self.recent_combo.setPlaceholderText("Recent Apps")
        recent_launch_btn = QPushButton("Launch Recent")
        recent_launch_btn.clicked.connect(self.launch_recent)
        
        recent_layout.addWidget(self.recent_combo)
        recent_layout.addWidget(recent_launch_btn)
        recent_group.setLayout(recent_layout)
        
        # Add all sections to main layout
        layout.addWidget(quick_launch_group)
        layout.addWidget(favorites_group)
        layout.addWidget(recent_group)
        
        # Populate favorites
        self.update_favorites_table()
        
    def browse_script(self):
        file_name, _ = QFileDialog.getOpenFileName(
            self,
            "Select Frida Script",
            self.scripts_dir,
            "JavaScript Files (*.js);;All Files (*.*)"
        )
        
        if file_name:
            self.script_input.setText(file_name)
            self.edit_script_btn.setEnabled(True)
            
            # Read script content
            try:
                with open(file_name, 'r') as f:
                    script_content = f.read()
                self.script_selected.emit(script_content)
            except Exception as e:
                print(f"Error reading script: {str(e)}")
                
    def edit_script(self):
        script_path = self.script_input.text()
        if script_path and os.path.exists(script_path):
            # You can implement your own script editor or use system default
            if sys.platform == 'win32':
                os.startfile(script_path)
            elif sys.platform == 'darwin':
                subprocess.run(['open', script_path])
            else:
                subprocess.run(['xdg-open', script_path])
                
    def toggle_script_selection(self, enabled):
        self.script_input.setEnabled(enabled)
        self.browse_script_btn.setEnabled(enabled)
        self.edit_script_btn.setEnabled(enabled and bool(self.script_input.text()))
        
    def add_to_favorites(self, name, package, script_path=None):
        self.favorites[name] = {
            'package': package,
            'script': script_path
        }
        self.save_favorites()
        self.update_favorites_table()
        
    def update_favorites_table(self):
        self.favorites_table.setRowCount(0)
        for name, data in self.favorites.items():
            row = self.favorites_table.rowCount()
            self.favorites_table.insertRow(row)
            
            name_item = QTableWidgetItem(name)
            package_item = QTableWidgetItem(data['package'])
            script_item = QTableWidgetItem(data.get('script', ''))
            
            launch_btn = QPushButton("Launch")
            launch_btn.clicked.connect(
                lambda checked, p=data['package'], s=data.get('script'): 
                self.launch_favorite(p, s)
            )
            
            self.favorites_table.setItem(row, 0, name_item)
            self.favorites_table.setItem(row, 1, package_item)
            self.favorites_table.setItem(row, 2, script_item)
            self.favorites_table.setCellWidget(row, 3, launch_btn)
            
    def launch_favorite(self, package, script_path=None):
        if script_path:
            try:
                with open(script_path, 'r') as f:
                    script_content = f.read()
                self.script_selected.emit(script_content)
            except Exception as e:
                print(f"Error reading script: {str(e)}")
        self.launch_app(package)
        
    def show_context_menu(self, position):
        menu = QMenu()
        remove_action = QAction("Remove from Favorites", self)
        remove_action.triggered.connect(self.remove_selected_favorite)
        
        edit_script_action = QAction("Edit Script", self)
        edit_script_action.triggered.connect(self.edit_selected_script)
        
        menu.addAction(remove_action)
        menu.addAction(edit_script_action)
        menu.exec_(self.favorites_table.mapToGlobal(position))
        
    def edit_selected_script(self):
        current_row = self.favorites_table.currentRow()
        if current_row >= 0:
            script_path = self.favorites_table.item(current_row, 2).text()
            if script_path:
                if sys.platform == 'win32':
                    os.startfile(script_path)
                elif sys.platform == 'darwin':
                    subprocess.run(['open', script_path])
                else:
                    subprocess.run(['xdg-open', script_path])
                
    def launch_app(self, package_name=None):
        if not package_name:
            package_name = self.package_input.text()
            
        try:
            cmd = ['adb', 'shell', 'am', 'start']
            
            if self.debug_check.isChecked():
                cmd.extend(['-D'])
                
            if self.wait_check.isChecked():
                cmd.extend(['-W'])
                
            cmd.extend(['-n', f'{package_name}/{package_name}.MainActivity'])
            
            process = subprocess.Popen(cmd, 
                                    stdout=subprocess.PIPE, 
                                    stderr=subprocess.PIPE)
            
            stdout, stderr = process.communicate()
            
            if process.returncode == 0:
                self.add_to_recent(package_name)
                # Get PID of launched app
                pid_cmd = ['adb', 'shell', 'pidof', package_name]
                pid = subprocess.check_output(pid_cmd).decode().strip()
                if pid:
                    self.app_launched.emit(package_name, int(pid))
            else:
                raise Exception(stderr.decode())
                
        except Exception as e:
            print(f"Error launching app: {str(e)}")
            
    def add_to_favorites(self, name, package):
        self.favorites[name] = package
        self.save_favorites()
        self.update_favorites_table()
        
    def remove_from_favorites(self, name):
        if name in self.favorites:
            del self.favorites[name]
            self.save_favorites()
            self.update_favorites_table()
            
    def load_favorites(self):
        try:
            if os.path.exists(self.favorites_file):
                with open(self.favorites_file, 'r') as f:
                    self.favorites = json.load(f)
            else:
                self.favorites = {}
        except:
            self.favorites = {}
            
    def save_favorites(self):
        os.makedirs(os.path.dirname(self.favorites_file), exist_ok=True)
        with open(self.favorites_file, 'w') as f:
            json.dump(self.favorites, f)
            
    def update_favorites_table(self):
        self.favorites_table.setRowCount(0)
        for name, package in self.favorites.items():
            row = self.favorites_table.rowCount()
            self.favorites_table.insertRow(row)
            
            name_item = QTableWidgetItem(name)
            package_item = QTableWidgetItem(package)
            
            launch_btn = QPushButton("Launch")
            launch_btn.clicked.connect(lambda checked, p=package: self.launch_app(p))
            
            self.favorites_table.setItem(row, 0, name_item)
            self.favorites_table.setItem(row, 1, package_item)
            self.favorites_table.setCellWidget(row, 2, launch_btn)
            
    def show_context_menu(self, position):
        menu = QMenu()
        remove_action = QAction("Remove from Favorites", self)
        remove_action.triggered.connect(lambda: self.remove_selected_favorite())
        menu.addAction(remove_action)
        menu.exec_(self.favorites_table.mapToGlobal(position))
        
    def remove_selected_favorite(self):
        current_row = self.favorites_table.currentRow()
        if current_row >= 0:
            name = self.favorites_table.item(current_row, 0).text()
            self.remove_from_favorites(name)
            
    def add_to_recent(self, package_name):
        current_text = self.recent_combo.currentText()
        if current_text != package_name:
            self.recent_combo.insertItem(0, package_name)
            if self.recent_combo.count() > 10:
                self.recent_combo.removeItem(10)
                
    def launch_recent(self):
        package_name = self.recent_combo.currentText()
        if package_name:
            self.launch_app(package_name)  
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\codeshare_browser.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, 
                           QLineEdit, QPushButton, QListWidget, 
                           QTextBrowser, QSplitter, QComboBox,
                           QLabel, QProgressBar, QMessageBox, QGroupBox, QDialog, QTabWidget, QMenu, QFrame, QTableWidget, QHeaderView, QFileDialog, QScrollArea, QGridLayout, QTextEdit)
from PyQt5.QtCore import pyqtSignal, Qt, QThread, QUrl
from PyQt5.QtGui import QFont, QDesktopServices, QIcon
import aiohttp
import asyncio
import qtawesome as qta
import json
import os
from bs4 import BeautifulSoup
from core.script_templates import SCRIPT_TEMPLATES
from core.script_history import ScriptHistory
import time
import requests
import threading
import re

class CodeFetcher(QThread):
    code_fetched = pyqtSignal(str)
    error_occurred = pyqtSignal(str)
    
    def __init__(self, url):
        super().__init__()
        self.url = url
        
    def run(self):
        try:
            response = requests.get(self.url)
            if response.status_code != 200:
                self.error_occurred.emit(f"HTTP Error: {response.status_code}")
                return
                
            # Find the script content in the Vue.js data
            script_match = re.search(r'projectSource: "(.*?)",', response.text, re.DOTALL)
            if script_match:
                # Unescape the JavaScript string
                code = script_match.group(1).encode().decode('unicode_escape')
                self.code_fetched.emit(code)
            else:
                # Try alternative method - look for the editor content
                soup = BeautifulSoup(response.text, 'html.parser')
                editor_div = soup.find('div', {'id': 'editor'})
                if editor_div and editor_div.string:
                    self.code_fetched.emit(editor_div.string)
                else:
                    self.error_occurred.emit("Could not find script content")
                
        except Exception as e:
            self.error_occurred.emit(f"Error fetching script: {str(e)}")

class CodeShareBrowser(QWidget):
    script_selected = pyqtSignal(str)  # For injector
    open_in_injector = pyqtSignal(str)  # New signal for opening in injector
    favorites_updated = pyqtSignal()    # New signal for favorites updates
    
    def __init__(self):
        super().__init__()
        self.scripts_cache = {}
        self.api_url = "https://konsumer.js.org/frida-codeshare/codeshare.json"
        self.favorites = []  # Initialize as empty list
        self.load_favorites()
        self.setup_ui()
        
    def load_favorites(self):
        """Load favorites from file"""
        try:
            favorites_file = os.path.join(os.path.expanduser('~'), '.frida_gui', 'favorites.json')
            if os.path.exists(favorites_file):
                with open(favorites_file, 'r') as f:
                    data = json.load(f)
                    # Make sure we get a list, even if loading from a dict
                    if isinstance(data, dict):
                        self.favorites = data.get('favorites', [])
                    else:
                        self.favorites = data if isinstance(data, list) else []
            else:
                self.favorites = []
        except Exception as e:
            print(f"Error loading favorites: {e}")
            self.favorites = []
        
    def save_favorites(self):
        """Save favorites to file"""
        try:
            favorites_file = os.path.join(os.path.expanduser('~'), '.frida_gui', 'favorites.json')
            os.makedirs(os.path.dirname(favorites_file), exist_ok=True)
            with open(favorites_file, 'w') as f:
                # Save as a simple list
                json.dump(self.favorites, f)
        except Exception as e:
            print(f"Error saving favorites: {e}")
            
    def is_favorite(self, script_id):
        """Check if script is favorited"""
        return script_id in self.favorites
        
    def toggle_favorite(self, script_info):
        """Toggle favorite status of script"""
        script_id = script_info['id']
        if script_id in self.favorites:
            self.favorites.remove(script_id)
        else:
            self.favorites.append(script_id)
        self.save_favorites()
        self.refresh_favorites()
        self.favorites_updated.emit()  # Emit signal when favorites change
        
    def setup_ui(self):
        layout = QVBoxLayout(self)
        
        # Create tab widget
        self.tab_widget = QTabWidget()
        
        # Create tabs
        self.browse_tab = QWidget()
        self.favorites_tab = QWidget()
        
        self.setup_browse_tab()
        self.setup_favorites_tab()
        
        # Add tabs
        self.tab_widget.addTab(self.browse_tab, "Browse")
        self.tab_widget.addTab(self.favorites_tab, " Favorites")
        
        layout.addWidget(self.tab_widget)
        
        self.refresh_scripts()
        
    def setup_browse_tab(self):
        """Setup the browse tab (existing functionality)"""
        layout = QVBoxLayout(self.browse_tab)
        
        # Move existing toolbar and grid here
        toolbar = QHBoxLayout()
        
        # Search bar
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText(" Search scripts...")
        self.search_input.textChanged.connect(self.filter_scripts)
        
        # Category filter
        self.category_combo = QComboBox()
        self.category_combo.addItems(['All', 'Android', 'iOS', 'Windows', 'Linux', 'macOS'])
        self.category_combo.currentTextChanged.connect(self.filter_scripts)
        
        # Sort options
        self.sort_combo = QComboBox()
        self.sort_combo.addItems([' Most Popular', ' Most Viewed', ' Latest'])
        self.sort_combo.currentTextChanged.connect(self.refresh_scripts)
        
        toolbar.addWidget(self.search_input)
        toolbar.addWidget(self.category_combo)
        toolbar.addWidget(self.sort_combo)
        
        # Grid layout for scripts
        self.grid_widget = QWidget()
        self.grid_layout = QGridLayout(self.grid_widget)
        self.grid_layout.setSpacing(10)
        
        # Scroll area for grid
        scroll = QScrollArea()
        scroll.setWidget(self.grid_widget)
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("""
            QScrollArea {
                border: none;
                background-color: #36393f;
            }
        """)
        
        # Add all components
        layout.addLayout(toolbar)
        layout.addWidget(scroll)
        
    def setup_favorites_tab(self):
        """Setup the favorites tab"""
        layout = QVBoxLayout(self.favorites_tab)
        
        # Create grid for favorite scripts
        self.favorites_grid = QWidget()
        self.favorites_grid_layout = QGridLayout(self.favorites_grid)
        self.favorites_grid_layout.setSpacing(10)
        
        # Scroll area for favorites
        scroll = QScrollArea()
        scroll.setWidget(self.favorites_grid)
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("""
            QScrollArea {
                border: none;
                background-color: #36393f;
            }
        """)
        
        # Add to layout
        layout.addWidget(scroll)
        
        # Initial population of favorites
        self.refresh_favorites()
        
    def refresh_favorites(self):
        """Refresh the favorites grid"""
        # Clear existing favorites grid
        for i in reversed(range(self.favorites_grid_layout.count())): 
            widget = self.favorites_grid_layout.itemAt(i).widget()
            if widget:
                widget.setParent(None)
            
        # Get favorite scripts
        try:
            # Get all scripts
            response = requests.get(self.api_url)
            all_scripts = response.json()
            
            # Filter to only favorited scripts
            favorite_scripts = [s for s in all_scripts if s['id'] in self.favorites]
            
            if favorite_scripts:
                # Add scripts to grid
                for idx, script_info in enumerate(favorite_scripts):
                    row = idx // 3
                    col = idx % 3
                    card = self.create_script_card(script_info)
                    self.favorites_grid_layout.addWidget(card, row, col)
            else:
                # Show message if no favorites
                msg = QLabel("No favorite scripts yet.\nBrowse scripts and click the  to add favorites!")
                msg.setAlignment(Qt.AlignCenter)
                msg.setStyleSheet("""
                    color: #b9bbbe;
                    font-size: 14px;
                    padding: 20px;
                """)
                self.favorites_grid_layout.addWidget(msg, 0, 0, 1, 3)
                
        except Exception as e:
            print(f"Error refreshing favorites: {e}")
            error_msg = QLabel(f"Error loading favorites: {str(e)}")
            error_msg.setStyleSheet("color: #ff4444;")
            self.favorites_grid_layout.addWidget(error_msg, 0, 0, 1, 3)

    def fetch_scripts(self):
        """Fetch scripts from API"""
        try:
            response = requests.get(self.api_url)
            scripts = response.json()
            
            # Sort scripts
            sort_option = self.sort_combo.currentText()
            if sort_option == 'Most Popular':
                scripts.sort(key=lambda x: x.get('likes', 0), reverse=True)
            elif sort_option == 'Most Viewed':
                scripts.sort(key=lambda x: x.get('seen', 0), reverse=True)
            
            return scripts
        except Exception as e:
            print(f"Error fetching scripts: {e}")
            return []
            
    def create_script_card(self, script_info):
        """Create a card widget for a script"""
        card = QFrame()
        card.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 8px;
                padding: 10px;
            }
            QFrame:hover {
                background-color: #40444b;
            }
            QLabel {
                color: white;
            }
        """)
        
        layout = QVBoxLayout(card)
        
        # Title
        title = QLabel(script_info['title'])
        title.setStyleSheet("font-size: 14px; font-weight: bold;")
        title.setWordWrap(True)
        
        # Author
        author = QLabel(f"by {script_info['author']}")
        author.setStyleSheet("color: #b9bbbe;")
        
        # Stats
        stats = QHBoxLayout()
        stars = QLabel(f" {script_info.get('likes', 0)}")
        views = QLabel(f" {script_info.get('seen', 0)}")
        stats.addWidget(stars)
        stats.addWidget(views)
        
        # Description
        desc = QLabel(script_info.get('description', '')[:100] + '...')
        desc.setWordWrap(True)
        desc.setStyleSheet("color: #b9bbbe;")
        
        # Action buttons
        buttons = QHBoxLayout()
        
        view_btn = QPushButton("View")
        view_btn.clicked.connect(lambda: self.fetch_script_code(script_info))
        
        fav_btn = QPushButton()
        if self.is_favorite(script_info['id']):
            fav_btn.setIcon(QIcon())
            fav_btn.setText("")
        else:
            fav_btn.setIcon(QIcon())
            fav_btn.setText("")
            fav_btn.setStyleSheet("color: #b9bbbe;")
        fav_btn.clicked.connect(lambda: self.toggle_favorite_ui(script_info, fav_btn))
        
        buttons.addWidget(view_btn)
        buttons.addWidget(fav_btn)
        buttons.addStretch()
        
        layout.addWidget(title)
        layout.addWidget(author)
        layout.addLayout(stats)
        layout.addWidget(desc)
        layout.addLayout(buttons)
        
        return card
        
    def fetch_script_code(self, script_info):
        """Fetch and show script code"""
        # Remove author name from ID if it's included
        script_id = script_info['id'].replace(f"{script_info['author']}/", "")
        url = f"https://codeshare.frida.re/@{script_info['author']}/{script_id}"
        print(f"Fetching script from: {url}")  # Debug print
        
        # Create preview dialog
        dialog = QDialog(self)
        dialog.setWindowTitle(f"Frida CodeShare - {script_info['title']}")
        dialog.resize(1000, 800)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #2f3136;
            }
            QLabel {
                color: white;
            }
            QPushButton {
                background-color: #7289da;
                color: white;
                padding: 8px 16px;
                border-radius: 4px;
                min-width: 100px;
            }
            QPushButton:hover {
                background-color: #677bc4;
            }
            QTextEdit {
                background-color: #36393f;
                color: #dcddde;
                border: none;
                border-radius: 4px;
                padding: 10px;
                font-family: 'Consolas', monospace;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        layout.setSpacing(15)
        
        # Header
        header = QHBoxLayout()
        title = QLabel(script_info['title'])
        title.setStyleSheet("font-size: 18px; font-weight: bold;")
        author = QLabel(f"by {script_info['author']}")
        author.setStyleSheet("color: #b9bbbe;")
        header.addWidget(title)
        header.addWidget(author)
        header.addStretch()
        
        # Stats
        stats = QHBoxLayout()
        likes = QLabel(f" {script_info.get('likes', 0)}")
        views = QLabel(f" {script_info.get('seen', 0)}")
        stats.addWidget(likes)
        stats.addWidget(views)
        stats.addStretch()
        
        # Description
        desc = QLabel(script_info.get('description', ''))
        desc.setWordWrap(True)
        desc.setStyleSheet("color: #b9bbbe; padding: 10px;")
        
        # Code preview
        code_view = QTextEdit()
        code_view.setReadOnly(True)
        code_view.setFont(QFont('Consolas', 11))
        code_view.setLineWrapMode(QTextEdit.NoWrap)
        code_view.setText("Loading script...")
        
        # Usage instructions
        usage = QLabel(f"Try this code out by running:\n$ frida --codeshare {script_info['author']}/{script_info['id']} -f YOUR_BINARY")
        usage.setStyleSheet("""
            background-color: #202225;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
        """)
        
        # Action buttons
        buttons = QHBoxLayout()
        
        copy_btn = QPushButton(qta.icon('fa5s.copy'), " Copy Code")
        copy_btn.clicked.connect(lambda: self.copy_to_clipboard(code_view.toPlainText()))
        
        inject_btn = QPushButton(qta.icon('fa5s.syringe'), " Open in Injector")
        inject_btn.clicked.connect(lambda: self.open_in_injector_page(code_view.toPlainText(), dialog))
        
        download_btn = QPushButton(qta.icon('fa5s.download'), " Download")
        download_btn.clicked.connect(lambda: self.download_script(script_info['title'], code_view.toPlainText()))
        
        open_btn = QPushButton(qta.icon('fa5s.external-link-alt'), " Open in Browser")
        open_btn.clicked.connect(lambda: QDesktopServices.openUrl(QUrl(url)))
        
        buttons.addWidget(copy_btn)
        buttons.addWidget(inject_btn)
        buttons.addWidget(download_btn)
        buttons.addWidget(open_btn)
        buttons.addStretch()
        
        # Add all components
        layout.addLayout(header)
        layout.addLayout(stats)
        layout.addWidget(desc)
        layout.addWidget(usage)
        layout.addWidget(code_view)
        layout.addLayout(buttons)
        
        dialog.show()
        
        # Create and start the code fetcher thread
        self.code_fetcher = CodeFetcher(url)
        self.code_fetcher.code_fetched.connect(code_view.setText)
        self.code_fetcher.error_occurred.connect(lambda err: code_view.setText(f"Error loading script: {err}"))
        self.code_fetcher.start()

    def refresh_scripts(self):
        """Refresh scripts from API"""
        # Clear existing grid
        for i in reversed(range(self.grid_layout.count())): 
            self.grid_layout.itemAt(i).widget().setParent(None)
            
        # Fetch and sort scripts
        scripts = self.fetch_scripts()
        
        # Add all scripts to grid
        for idx, script_info in enumerate(scripts):
            row = idx // 3
            col = idx % 3
            card = self.create_script_card(script_info)
            self.grid_layout.addWidget(card, row, col)
            
        # Refresh favorites tab
        self.refresh_favorites()

    def add_script(self, script_info):
        """Add a script card to the grid"""
        # Calculate grid position
        count = self.grid_layout.count()
        row = count // 3
        col = count % 3
        
        # Create and add card
        card = self.create_script_card(script_info)
        self.grid_layout.addWidget(card, row, col)
        
        # Cache the script
        self.scripts_cache[script_info['id']] = script_info

    def filter_scripts(self):
        """Filter visible scripts based on search and category"""
        search_text = self.search_input.text().lower()
        category = self.category_combo.currentText()
        
        # Show/hide cards based on filters
        for i in range(self.grid_layout.count()):
            widget = self.grid_layout.itemAt(i).widget()
            if widget:
                title = widget.findChild(QLabel).text().lower()
                desc = widget.findChildren(QLabel)[-2].text().lower()  # Description label
                
                show = True
                if search_text and search_text not in title and search_text not in desc:
                    show = False
                if category != 'All' and category not in desc:
                    show = False
                    
                widget.setVisible(show)

    def copy_to_clipboard(self, text):
        """Copy text to clipboard"""
        clipboard = QApplication.clipboard()
        clipboard.setText(text)
        QMessageBox.information(self, " Success", " Copied to clipboard!")

    def download_script(self, title, code):
        """Download script to file"""
        filename = f"{title.lower().replace(' ', '_')}.js"
        file_path, _ = QFileDialog.getSaveFileName(
            self, " Save Script", filename, "JavaScript Files (*.js)"
        )
        
        if file_path:
            try:
                with open(file_path, 'w') as f:
                    f.write(code)
                QMessageBox.information(self, " Success", " Script downloaded successfully!")
            except Exception as e:
                QMessageBox.critical(self, " Error", f"Failed to save script: {str(e)}")

    def toggle_favorite_ui(self, script_info, button):
        """Toggle favorite status and update UI"""
        self.toggle_favorite(script_info)
        if self.is_favorite(script_info['id']):
            button.setIcon(QIcon())
            button.setText("")
        else:
            button.setIcon(QIcon())
            button.setText("")
            button.setStyleSheet("color: #b9bbbe;")
            
        # Refresh favorites tab when status changes
        self.refresh_favorites()

    def open_in_injector_page(self, code, dialog=None):
        """Open the script in the injector page"""
        self.open_in_injector.emit(code)  # Emit signal to main window
        if dialog:
            dialog.close()  # Close the preview dialog 
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\data_visualizer.py --- 
from PyQt5.QtWidgets import QWidget, QVBoxLayout
from PyQt5.QtChart import QChart, QChartView, QLineSeries
from PyQt5.QtCore import Qt, QTimer
import json

class DataVisualizer(QWidget):
    def __init__(self):
        super().__init__()
        self.setup_ui()
        self.api_calls = []
        self.setup_timer()
        
    def setup_ui(self):
        layout = QVBoxLayout(self)
        
        # Create chart
        self.chart = QChart()
        self.chart.setTitle("API Calls Over Time")
        self.chart.setAnimationOptions(QChart.SeriesAnimations)
        
        self.series = QLineSeries()
        self.chart.addSeries(self.series)
        
        chart_view = QChartView(self.chart)
        chart_view.setRenderHint(QPainter.Antialiasing)
        
        layout.addWidget(chart_view)
        
    def setup_timer(self):
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_chart)
        self.timer.start(1000)  # Update every second
        
    def add_api_call(self, call_data):
        self.api_calls.append({
            'timestamp': time.time(),
            'data': call_data
        })
        
    def update_chart(self):
        # Update chart with new data
        self.series.clear()
        for i, call in enumerate(self.api_calls[-50:]):  # Show last 50 calls
            self.series.append(i, len(call['data']))  
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\device_panel.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, 
                           QComboBox, QPushButton, QLabel)
from PyQt5.QtCore import pyqtSignal
import frida

class DevicePanel(QWidget):
    device_selected = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.setup_ui()
        
    def setup_ui(self):
        layout = QHBoxLayout(self)
        
        # Device selection combo box
        self.device_combo = QComboBox()
        self.scan_button = QPushButton("Scan Devices")
        
        layout.addWidget(QLabel("Select Device:"))
        layout.addWidget(self.device_combo)
        layout.addWidget(self.scan_button)
        
        # Connect signals
        self.scan_button.clicked.connect(self.scan_devices)
        self.device_combo.currentIndexChanged.connect(self._on_device_selected)
        
        # Initial scan
        self.scan_devices()
        
    def scan_devices(self):
        try:
            self.device_combo.clear()
            devices = frida.enumerate_devices()
            for device in devices:
                if device.type in ['usb', 'remote']:
                    self.device_combo.addItem(f"{device.name} (ADB - {device.type})", device.id)
                elif device.type == 'local':
                    self.device_combo.addItem(f"{device.name} (Local)", device.id)
        except Exception as e:
            print(f"Error scanning devices: {str(e)}")
            
    def _on_device_selected(self):
        device_id = self.device_combo.currentData()
        if device_id:
            self.device_selected.emit(device_id)  
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\device_selector.py --- 
import frida
import subprocess
import qtawesome as qta
import sys
from pathlib import Path
import os
import time
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QComboBox,
                           QPushButton, QLabel, QFrame, QLineEdit, QMessageBox,
                           QApplication, QDialog, QListWidget, QListWidgetItem,
                           QDialogButtonBox, QFileDialog, QTextEdit, QCheckBox,
                           # MODIFICATION: Added QInputDialog for renaming and QSizePolicy
                           QFormLayout, QGroupBox, QInputDialog, QSizePolicy)
# MODIFICATION: Added QTimer for delayed selection
from PyQt5.QtCore import pyqtSignal, Qt, QTimer
from PyQt5.QtGui import QFont
from core.android_helper import AndroidHelper
# MODIFICATION: Added deque for history
from collections import deque


class DeviceSelector(QWidget):
    process_selected = pyqtSignal(str, int)  # device_id, pid
    application_selected_for_spawn = pyqtSignal(str, str, list, str)  # device, pkg, [scripts], options

    def __init__(self):
        super().__init__()
        self.current_device = None
        self.process_list = []
        self.applications = []
        self.script_files = []
        self.frida_spawn_options = ""
        self._temp_files = [] 
        # MODIFICATION: Add default script dir for saving/loading
        self.default_script_dir = os.path.join(os.getcwd(), 'frida_data', 'scripts')
        os.makedirs(self.default_script_dir, exist_ok=True) # Ensure it exists
        # MODIFICATION: Add history for recent processes
        self.recent_processes_history = deque(maxlen=5)
        # MODIFICATION: Store a reference to the spawn script list for renaming
        self.spawn_script_list = None
        self.setup_ui()


    def _get_temp_dir(self):
        """Gets the dedicated temp directory for spawned scripts."""
        temp_dir = os.path.join(os.getcwd(), 'frida_data', 'spawn_scripts')
        os.makedirs(temp_dir, exist_ok=True)
        return temp_dir

    def _save_temp_script(self, content):
        """Saves content to a temporary file and returns the path."""
        temp_dir = self._get_temp_dir()
        # Create a unique filename based on timestamp
        unique_id = int(time.time() * 1000)
        file_name = f"pasted_script_{unique_id}.js"
        file_path = os.path.join(temp_dir, file_name)
        
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            self._temp_files.append(file_path) # Add to tracking list
            print(f"[DeviceSelector] Saved temp script: {file_path}")
            return file_path
        except Exception as e:
            QMessageBox.critical(self, "Save Error", f"Failed to save temporary script: {e}")
            return None

    def show_paste_dialog(self, script_list_widget, update_ok_button_func): # -- Unchanged
        dlg = QDialog(self)
        dlg.setWindowTitle("Paste and Save Script (Temp)")
        dlg.resize(600, 400)
        layout = QVBoxLayout(dlg)

        editor = QTextEdit()
        # Get clipboard content
        clipboard = QApplication.clipboard()
        editor.setPlainText(clipboard.text())
        editor.setFont(QFont('Consolas', 10))

        layout.addWidget(QLabel("Paste your **Frida script content** below (saves to temp location):"))
        layout.addWidget(editor)

        btn_box = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel)
        btn_box.button(QDialogButtonBox.Save).clicked.connect(lambda: self._handle_paste_save(editor.toPlainText(), script_list_widget, update_ok_button_func, dlg))
        btn_box.rejected.connect(dlg.reject)
        layout.addWidget(btn_box)

        dlg.exec_()
        
    # MODIFICATION: Added the missing _handle_paste_save method
    def _handle_paste_save(self, content, script_list_widget, update_ok_button_func, dialog):
        """Handles saving pasted content and updating the script list."""
        if not content.strip():
            QMessageBox.warning(dialog, "Empty Script", "Cannot save an empty script.")
            return

        temp_path = self._save_temp_script(content)
        if temp_path:
            # Add to list widget with a special prefix
            item = QListWidgetItem(f"[PASTED] {os.path.basename(temp_path)}")
            item.setData(Qt.UserRole, temp_path)
            item.setToolTip(temp_path)
            script_list_widget.addItem(item)
            update_ok_button_func()
            dialog.accept() # Close the dialog
        
    def setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        frame = QFrame()
        frame.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 8px;
                padding: 10px;
            }
            QComboBox {
                background-color: #36393f;
                border: none;
                border-radius: 4px;
                padding: 8px;
                color: white;
                min-width: 200px;
            }
            QComboBox::drop-down {
                border: none;
                padding-right: 10px;
            }
        """)
        frame_layout = QVBoxLayout(frame)

        # Device selection
        device_layout = QHBoxLayout()
        self.device_combo = QComboBox()
        self.device_combo.setPlaceholderText("Select Device...")
        self.device_combo.currentIndexChanged.connect(self.on_device_changed)

        refresh_btn = QPushButton(qta.icon('fa5s.sync'), "")
        refresh_btn.setToolTip("Refresh Devices")
        refresh_btn.clicked.connect(self.refresh_devices)

        device_layout.addWidget(QLabel("Device:"))
        device_layout.addWidget(self.device_combo, 1)
        device_layout.addWidget(refresh_btn)
        frame_layout.addLayout(device_layout)

        # Process / Spawn row
        process_spawn_layout = QHBoxLayout()

        self.process_filter = QLineEdit()
        self.process_filter.setPlaceholderText("Filter running processes...")
        self.process_filter.textChanged.connect(self.filter_processes)

        self.process_combo = QComboBox()
        self.process_combo.setPlaceholderText("Attach to Process...")
        self.process_combo.currentIndexChanged.connect(self.on_process_changed)
        self.process_combo.setMaxVisibleItems(20)
        self.process_combo.setStyleSheet("QComboBox QListView { min-width: 300px; }")

        refresh_proc_btn = QPushButton(qta.icon('fa5s.sync'), "")
        refresh_proc_btn.setToolTip("Refresh Running Processes")
        refresh_proc_btn.clicked.connect(self.refresh_processes)

        self.spawn_app_btn = QPushButton(qta.icon('fa5s.rocket'), " Spawn App...")
        self.spawn_app_btn.setToolTip("Select an installed application to spawn")
        self.spawn_app_btn.clicked.connect(self.show_spawn_dialog)
        self.spawn_app_btn.setEnabled(False)

        self.frida_opts_btn = QPushButton(qta.icon('fa5s.cog'), " Frida Options")
        self.frida_opts_btn.setToolTip("Configure Frida spawn command line options")
        self.frida_opts_btn.clicked.connect(self.show_frida_options_dialog)
        self.frida_opts_btn.setEnabled(False)

        process_spawn_layout.addWidget(QLabel("Process:"))
        process_spawn_layout.addWidget(self.process_filter)
        process_spawn_layout.addWidget(self.process_combo, 1)
        process_spawn_layout.addWidget(refresh_proc_btn)
        process_spawn_layout.addWidget(self.spawn_app_btn)
        process_spawn_layout.addWidget(self.frida_opts_btn)

        frame_layout.addLayout(process_spawn_layout)
        
        # MODIFICATION: Add Recent Processes List
        recent_label = QLabel("Recent Targets:")
        recent_label.setStyleSheet("font-size: 11px; color: #96989d; margin-top: 5px;")
        frame_layout.addWidget(recent_label)
        
        self.recent_processes_list = QListWidget()
        self.recent_processes_list.setFixedHeight(100) # Keep it constrained
        self.recent_processes_list.setStyleSheet("""
            QListWidget {
                background-color: #36393f;
                border: 1px solid #202225;
                border-radius: 4px;
                padding: 4px;
            }
            QListWidget::item {
                padding: 5px;
                border-radius: 4px;
                color: #dcddde;
            }
            QListWidget::item:hover {
                background-color: #40444b;
            }
            QListWidget::item:selected {
                background-color: #5865f2;
                color: white;
            }
        """)
        self.recent_processes_list.itemClicked.connect(self._on_recent_process_clicked)
        frame_layout.addWidget(self.recent_processes_list)
        
        layout.addWidget(frame)

        self.refresh_devices()


    def refresh_devices(self):
        self.device_combo.clear()
        try:
            devices = frida.enumerate_devices()
            for device in devices:
                if device.type == 'usb':
                    self.device_combo.addItem(f"{device.name} (USB)", device.id)
        except Exception as e:
            print(f"Error enumerating devices: {e}")
        finally:
            if self.device_combo.count() > 0:
                self.device_combo.setCurrentIndex(0)

    def on_device_changed(self, index):
        if index < 0:
            self.current_device = None
            self.applications = []
            self.spawn_app_btn.setEnabled(False)
            self.frida_opts_btn.setEnabled(False)
            self.refresh_processes()
            return

        device_id = self.device_combo.currentData()
        self.current_device = device_id
        self.refresh_applications()
        self.refresh_processes()
        self.spawn_app_btn.setEnabled(True)
        self.frida_opts_btn.setEnabled(True)

    def refresh_applications(self):
        self.applications = []
        if not self.current_device:
            self.spawn_app_btn.setEnabled(False)
            return

        print(f"[DeviceSelector] Refreshing applications for {self.current_device}...")
        try:
            device = frida.get_device(self.current_device)
            if device.type != 'usb':
                print(f"[DeviceSelector] Spawning only supported for USB devices.")
                self.spawn_app_btn.setEnabled(False)
                return

            raw_apps = device.enumerate_applications()
            user_apps = []
            for app in raw_apps:
                if app.identifier and '.' in app.identifier:
                    user_apps.append({'name': app.name, 'identifier': app.identifier})

            user_apps.sort(key=lambda x: x['name'].lower())
            self.applications = user_apps
            print(f"[DeviceSelector] Found {len(self.applications)} user applications.")
            self.spawn_app_btn.setEnabled(len(self.applications) > 0)

        except frida.ServerNotRunningError:
            QMessageBox.warning(self, "Server Error", f"Frida server not running on {self.current_device}.")
            self.spawn_app_btn.setEnabled(False)
        except frida.TransportError:
            QMessageBox.warning(self, "Device Error", f"Device {self.current_device} disconnected.")
            self.spawn_app_btn.setEnabled(False)
        except Exception as e:
            print(f"[DeviceSelector] Error refreshing applications: {e}")
            self.spawn_app_btn.setEnabled(False)

    def refresh_processes(self):
        self.process_combo.clear()
        self.process_list.clear()

        if not self.current_device:
            return

        try:
            device = frida.get_device(self.current_device)
            if device.type == 'usb':
                self.process_combo.addItem("Checking device status...")
                QApplication.processEvents()

                if not AndroidHelper.is_device_connected(self.current_device):
                    raise Exception(f"Device {self.current_device} not connected")

                if not AndroidHelper.is_frida_running(self.current_device):
                    QMessageBox.warning(self, "Server Error",
                                        f"Frida server is not running on {self.current_device}.")
                    self.process_combo.clear()
                    self.process_combo.addItem("Frida server not running")
                    return

                self.process_combo.clear()
                processes = device.enumerate_processes()
                processes.sort(key=lambda p: p.name.lower() if p.name else "")
                for process in processes:
                    if process.pid > 0 and process.name:
                        self.process_list.append({'name': process.name, 'pid': process.pid})

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to refresh processes: {e}")
            self.process_combo.clear()
            self.process_combo.addItem("Error loading processes")

        self.filter_processes(self.process_filter.text())

    def filter_processes(self, text):
        search_text = text.lower()
        self.process_combo.clear()
        if not self.current_device:
            return

        items_added = 0
        for process in self.process_list:
            if search_text in process['name'].lower():
                self.process_combo.addItem(f"{process['name']} (PID: {process['pid']})", process['pid'])
                items_added += 1

        if items_added == 0 and search_text:
            self.process_combo.setPlaceholderText("No matches found")
        elif not search_text:
            self.process_combo.setPlaceholderText("Attach to Process...")

    def on_process_changed(self, index):
        if index < 0:
            return
        try:
            device_id = self.device_combo.currentData()
            pid = self.process_combo.currentData()
            if pid is None:
                return
            pid = int(pid)
            if device_id and pid > 0:
                self.process_selected.emit(device_id, pid)
                # MODIFICATION: Add to recent list on attach
                name = self.process_combo.currentText().split(' (PID:')[0].strip()
                self._add_to_recent_processes(device_id, pid, name)
        except Exception as e:
            print(f"Error in process selection: {e}")

    def show_spawn_dialog(self):
        if not self.current_device:
            QMessageBox.warning(self, "No Device", "Please select a device first.")
            return
        if not self.applications:
            QMessageBox.information(self, "No Apps", "No user applications found. Refreshing...")
            self.refresh_applications()
            if not self.applications:
                QMessageBox.warning(self, "No Apps", "Could not find any user applications to spawn.")
                return

        # --- Application selector dialog (unchanged) ---
        dialog = QDialog(self)
        dialog.setWindowTitle("Select Application to Spawn")
        layout = QVBoxLayout(dialog)

        filter_edit = QLineEdit()
        filter_edit.setPlaceholderText("Filter applications...")
        list_widget = QListWidget()
        list_widget.setStyleSheet("QListWidget::item { padding: 5px; }")

        def populate_list(text=""):
            list_widget.clear()
            fl = text.lower()
            for app in self.applications:
                if fl in app['name'].lower() or fl in app['identifier'].lower():
                    item = QListWidgetItem(f"{app['name']} ({app['identifier']})")
                    item.setData(Qt.UserRole, app['identifier'])
                    list_widget.addItem(item)

        filter_edit.textChanged.connect(populate_list)
        populate_list()
        list_widget.itemDoubleClicked.connect(dialog.accept)

        btn_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        btn_box.accepted.connect(dialog.accept)
        btn_box.rejected.connect(dialog.reject)

        layout.addWidget(QLabel("Select an application:"))
        layout.addWidget(filter_edit)
        layout.addWidget(list_widget)
        layout.addWidget(btn_box)

        if dialog.exec_() != QDialog.Accepted:
            return

        selected = list_widget.currentItem()
        if not selected:
            return
        app_identifier = selected.data(Qt.UserRole)
        print(f"[DeviceSelector] Spawning app selected: {app_identifier}")

        # --- Script input dialog ---
        script_dialog = QDialog(self)
        script_dialog.setWindowTitle(f"Scripts for {app_identifier}")
        script_dialog.setMinimumSize(700, 500)
        dlg_layout = QVBoxLayout(script_dialog)

        # Top: Buttons
        btn_layout = QHBoxLayout()
        
        paste_btn = QPushButton(qta.icon('fa5s.clipboard', color='white'), " Paste & Save") 
        paste_btn.setToolTip("Paste script from clipboard and save as a temporary file for injection")
        
        add_btn = QPushButton(qta.icon('fa5s.plus'), " Add Script File...") 
        remove_btn = QPushButton(qta.icon('fa5s.trash'), " Remove")
        up_btn = QPushButton(qta.icon('fa5s.arrow-up'), "")
        down_btn = QPushButton(qta.icon('fa5s.arrow-down'), "")

        btn_layout.addWidget(paste_btn) 
        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(remove_btn)
        btn_layout.addWidget(up_btn)
        btn_layout.addWidget(down_btn)
        btn_layout.addStretch()

        # Script list
        # MODIFICATION: Use self.spawn_script_list to allow access from rename slots
        self.spawn_script_list = QListWidget()
        self.spawn_script_list.setDragDropMode(QListWidget.InternalMove)
        self.spawn_script_list.setSelectionMode(QListWidget.SingleSelection)
        # MODIFICATION: Connect signals for renaming
        self.spawn_script_list.itemDoubleClicked.connect(self._handle_script_item_double_clicked)
        # We will use QInputDialog, so itemChanged is not the right signal.


        # Bottom: OK/Cancel
        btn_box2 = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        btn_box2.accepted.connect(script_dialog.accept)
        btn_box2.rejected.connect(script_dialog.reject)

        ok_btn = btn_box2.button(QDialogButtonBox.Ok)
        ok_btn.setEnabled(False)

        # --- Functions ---
        def update_ok_button():
            ok_btn.setEnabled(self.spawn_script_list.count() > 0)

        def add_script():
            # MODIFICATION: Start file dialog in default script directory
            start_dir = self.default_script_dir
            
            paths, _ = QFileDialog.getOpenFileNames(
                script_dialog, "Select Frida Scripts", start_dir,
                "JavaScript Files (*.js);;All Files (*.*)"
            )
            for path in paths:
                # Avoid duplicates
                if path not in [self.spawn_script_list.item(i).data(Qt.UserRole) for i in range(self.spawn_script_list.count())]:
                    item = QListWidgetItem(os.path.basename(path))
                    item.setData(Qt.UserRole, path)
                    item.setToolTip(path)
                    self.spawn_script_list.addItem(item)
            update_ok_button()

        def remove_script():
            for item in self.spawn_script_list.selectedItems():
                self.spawn_script_list.takeItem(self.spawn_script_list.row(item))
            update_ok_button()

        def move_up():
            row = self.spawn_script_list.currentRow()
            if row > 0:
                item = self.spawn_script_list.takeItem(row)
                self.spawn_script_list.insertItem(row - 1, item)
                self.spawn_script_list.setCurrentRow(row - 1)

        def move_down():
            row = self.spawn_script_list.currentRow()
            if row < self.spawn_script_list.count() - 1:
                item = self.spawn_script_list.takeItem(row)
                self.spawn_script_list.insertItem(row + 1, item)
                self.spawn_script_list.setCurrentRow(row + 1)

        # Connect signals
        paste_btn.clicked.connect(lambda: self.show_paste_dialog(self.spawn_script_list, update_ok_button)) 
        add_btn.clicked.connect(add_script)
        remove_btn.clicked.connect(remove_script)
        up_btn.clicked.connect(move_up)
        down_btn.clicked.connect(move_down)
        self.spawn_script_list.itemSelectionChanged.connect(
            lambda: remove_btn.setEnabled(bool(self.spawn_script_list.selectedItems()))
        )
        
        # Populate script list if self.script_files is already set (e.g., re-opening dialog)
        for path in self.script_files:
            item_text = f"[PASTED] {os.path.basename(path)}" if path in self._temp_files else os.path.basename(path)
            item = QListWidgetItem(item_text)
            item.setData(Qt.UserRole, path)
            item.setToolTip(path)
            self.spawn_script_list.addItem(item)
        update_ok_button()

        # Layout
        dlg_layout.addLayout(btn_layout)
        dlg_layout.addWidget(QLabel("Scripts will run in order (top to bottom):"))
        dlg_layout.addWidget(self.spawn_script_list)
        dlg_layout.addWidget(btn_box2)

        if script_dialog.exec_() != QDialog.Accepted:
            print("[DeviceSelector] Script selection cancelled.")
            return

        if self.spawn_script_list.count() == 0:
            QMessageBox.warning(self, "No Scripts", "Please add at least one script.")
            return

        # Extract ordered script paths
        self.script_files = [
            self.spawn_script_list.item(i).data(Qt.UserRole)
            for i in range(self.spawn_script_list.count())
        ]
        
        # MODIFICATION: Add to recent list on spawn
        app_name = selected.text().split(' (')[0].strip()
        self._add_to_recent_processes(self.current_device, 0, app_name) # PID 0 signifies spawn

        spawn_opts = getattr(self, "frida_spawn_options", "")
        self.application_selected_for_spawn.emit(
            self.current_device, app_identifier, self.script_files, spawn_opts
        )
        print("[DeviceSelector] Script accepted and signal emitted.")

    def show_frida_options_dialog(self):
        dlg = QDialog(self)
        dlg.setWindowTitle("Frida Spawn Options")
        dlg.setMinimumWidth(580)
        layout = QVBoxLayout(dlg)

        # Common switches
        common_group = QGroupBox("Common switches")
        common_layout = QVBoxLayout(common_group)
        self.pause_chk = QCheckBox("--pause   (do not resume after spawn)")
        self.debug_chk = QCheckBox("-d        (enable debugging)")
        self.device_chk = QCheckBox("-D <id>   (specify device, auto-filled)")
        self.output_chk = QCheckBox("-O <file> (write output to file)")
        self.stdio_chk = QCheckBox("--stdio  (inherit stdin/stdout)")

        for chk in (self.pause_chk, self.debug_chk, self.device_chk, self.output_chk, self.stdio_chk):
            common_layout.addWidget(chk)
        layout.addWidget(common_group)

        # Custom flags
        extra_group = QGroupBox("Custom flags (order matters)")
        extra_layout = QFormLayout(extra_group)
        self.extra1_edit = QLineEdit()
        self.extra1_edit.setPlaceholderText("e.g. --runtime=v8")
        self.extra2_edit = QLineEdit()
        self.extra2_edit.setPlaceholderText("e.g. --no-pause")
        extra_layout.addRow("Extra flag 1:", self.extra1_edit)
        extra_layout.addRow("Extra flag 2:", self.extra2_edit)
        layout.addWidget(extra_group)

        # Known flags
        known_text = QTextEdit()
        known_text.setReadOnly(True)
        known_text.setMinimumHeight(180)
        known_text.setFont(QFont("Consolas", 11))

        if not hasattr(self, "_frida_help_cache"):
            try:
                self._frida_help_cache = subprocess.check_output(
                    ["frida", "--help"], stderr=subprocess.STDOUT, text=True
                )
            except Exception as e:
                self._frida_help_cache = f"Could not run `frida --help`: {e}"
        known_text.setPlainText(self._frida_help_cache)
        layout.addWidget(QLabel("<b>Known Frida CLI flags (from `frida --help`)</b>"))
        layout.addWidget(known_text)

        # Buttons
        btn_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        btn_box.accepted.connect(dlg.accept)
        btn_box.rejected.connect(dlg.reject)
        layout.addWidget(btn_box)

        # Restore previous options
        if self.frida_spawn_options:
            self._apply_options_to_widgets(self.frida_spawn_options)

        if dlg.exec_() != QDialog.Accepted:
            return

        opts = []
        if self.pause_chk.isChecked():   opts.append("--pause")
        if self.debug_chk.isChecked():   opts.append("-d")
        if self.device_chk.isChecked():  opts.append(f"-D {self.current_device}")
        if self.output_chk.isChecked():  opts.append("-O")
        if self.stdio_chk.isChecked():   opts.append("--stdio")
        if self.extra1_edit.text().strip(): opts.append(self.extra1_edit.text().strip())
        if self.extra2_edit.text().strip(): opts.append(self.extra2_edit.text().strip())

        self.frida_spawn_options = " ".join(opts)
        self.frida_opts_btn.setIcon(qta.icon('fa5s.cog'))
        self.frida_opts_btn.setText(f"Frida Options ({len(opts)})")
        print(f"[DeviceSelector] Frida spawn options set: {self.frida_spawn_options}")

        
    def _apply_options_to_widgets(self, option_str: str):
        parts = option_str.split()
        i = 0
        while i < len(parts):
            flag = parts[i]
            if flag == "--pause": self.pause_chk.setChecked(True)
            elif flag == "-d": self.debug_chk.setChecked(True)
            elif flag == "--stdio": self.stdio_chk.setChecked(True)
            elif flag.startswith("-D"): self.device_chk.setChecked(True); i += 1
            elif flag.startswith("-O"): self.output_chk.setChecked(True)
            else:
                if not self.extra1_edit.text(): self.extra1_edit.setText(flag)
                elif not self.extra2_edit.text(): self.extra2_edit.setText(flag)
            i += 1

    def get_selected_process_info(self):
        try:
            index = self.process_combo.currentIndex()
            if index >= 0:
                device_id = self.device_combo.currentData()
                pid = self.process_combo.currentData()
                name = self.process_combo.currentText().split('(')[0].strip()
                if device_id and pid:
                    return {'device_id': device_id, 'pid': pid, 'name': name}
        except Exception as e:
            print(f"Error getting process info: {e}")
        return None

    def select_device(self, device_id):
        index = self.device_combo.findData(device_id)
        if index >= 0:
            self.device_combo.setCurrentIndex(index)

    def select_process(self, pid):
        for i in range(self.process_combo.count()):
            item_data = self.process_combo.itemData(i)
            if item_data and int(item_data) == int(pid):
                self.process_combo.setCurrentIndex(i)
                break

    # MODIFICATION: New method to handle starting a rename
    def _handle_script_item_double_clicked(self, item):
        """Allows renaming a script file on double-click."""
        if not self.spawn_script_list:
            return
            
        # Only allow renaming if it's not a [PASTED] temp file
        if item.text().startswith("[PASTED]"):
            QMessageBox.information(self, "Rename Not Allowed", "Cannot rename a temporary [PASTED] script.")
            return

        old_name_full = os.path.basename(item.text())
        old_name, ext = os.path.splitext(old_name_full)

        new_name, ok = QInputDialog.getText(self, "Rename Script", 
                                            "Enter new script name (no .js):", 
                                            QLineEdit.Normal, old_name)
        
        if ok and new_name and new_name != old_name:
            self._handle_script_item_renamed(item, new_name)

    # MODIFICATION: New method to handle saving the renamed script
    def _handle_script_item_renamed(self, item, new_name_base):
        """Silently saves the script to the default script directory after renaming."""
        old_path = item.data(Qt.UserRole)
        
        new_name = new_name_base.strip()
        if not new_name.endswith('.js'):
            new_name += '.js'
        
        try:
            new_path = os.path.join(self.default_script_dir, new_name)
            
            if old_path == new_path:
                item.setText(new_name)
                return # No change
                
            # Read old content
            with open(old_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Write new content
            with open(new_path, 'w', encoding='utf-8') as f:
                f.write(content)
                
            # Update item's data to point to new file
            item.setText(new_name)
            item.setData(Qt.UserRole, new_path)
            item.setToolTip(new_path)
            
            print(f"[DeviceSelector] Renamed/copied script saved to: {new_path}")
            
            # We no longer remove the old script, this acts as "Save As"
            # If the old file was also in the default script dir, remove it
            # old_dir = os.path.dirname(old_path)
            # if old_dir == self.default_script_dir and old_path != new_path:
            #     os.remove(old_path)
                
        except Exception as e:
            QMessageBox.critical(self, "Rename Error", f"Could not save renamed script: {e}")
            # Revert text
            item.setText(os.path.basename(old_path))

    # MODIFICATION: New method to add to recent processes
    def _add_to_recent_processes(self, device_id, pid, name):
        """Adds a process to the recent history deque and updates the UI list."""
        try:
            entry = {"device_id": device_id, "pid": int(pid), "name": name}
        except (ValueError, TypeError):
            return # Invalid data

        # Remove duplicates before adding
        new_history = deque(maxlen=5)
        is_duplicate = False
        for e in self.recent_processes_history:
            if e["device_id"] == entry["device_id"] and e["name"] == entry["name"] and e["pid"] == entry["pid"]:
                 is_duplicate = True
            if e != entry:
                new_history.append(e)
        
        new_history.appendleft(entry)
        self.recent_processes_history = new_history
        
        self._update_recent_processes_list()

    # MODIFICATION: New method to update the recent processes UI list
    def _update_recent_processes_list(self):
        """Clears and repopulates the recent processes QListWidget."""
        self.recent_processes_list.clear()
        
        # Use a set to avoid showing the same name/pid combo twice if it's in history multiple times
        seen = set()
        for entry in self.recent_processes_history:
            entry_key = (entry['device_id'], entry['name'], entry['pid'])
            if entry_key in seen:
                continue
            seen.add(entry_key)

            pid_str = f"PID: {entry['pid']}" if entry['pid'] > 0 else "SPAWN"
            item = QListWidgetItem(f"{entry['name']} ({pid_str})")
            item.setData(Qt.UserRole, entry)
            item.setToolTip(f"Click to select {entry['name']} on {entry['device_id']}")
            self.recent_processes_list.addItem(item)
            
    # MODIFICATION: New method to handle clicking on a recent process
    def _on_recent_process_clicked(self, item):
        """Selects a device and process from the recent list."""
        entry = item.data(Qt.UserRole)
        if not entry:
            return
            
        self.select_device(entry['device_id'])
        
        if entry['pid'] > 0:
            # We need to wait for the device change to propagate and processes to refresh
            # A timer is a simple way to do this.
            QTimer.singleShot(250, lambda: self.select_process(entry['pid']))
        else:
            # It's a spawn target, just select the device
            self.process_combo.setCurrentIndex(-1) # Clear process selection


    def cleanup(self):
        """Clean up state and remove temporary files."""
        self.process_combo.clear()
        self.device_combo.clear()
        self.current_device = None
        self.process_list = []
        self.applications = []
        self.frida_spawn_options = ""

        # MODIFIED: Cleanup temporary files
        print("[DeviceSelector] Cleaning up temporary spawn scripts...")
        for file_path in getattr(self, '_temp_files', []):
            try:
                # Only attempt to remove files created by this instance in its session
                if os.path.exists(file_path):
                    os.remove(file_path)
                    print(f"  Removed: {file_path}")
            except Exception as e:
                print(f"  Failed to remove {file_path}: {e}")
        self._temp_files = [] 
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\history_page.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
                           QLabel, QTableWidget, QTableWidgetItem, QHeaderView,
                           QMenu, QMessageBox, QApplication) # MODIFICATION: Added QApplication
from PyQt5.QtCore import Qt, pyqtSignal
import qtawesome as qta
from datetime import datetime

class HistoryPage(QWidget):
    script_selected = pyqtSignal(str)  # For opening scripts in injector
    
    def __init__(self, history_manager):
        super().__init__()
        self.history_manager = history_manager
        self.setup_ui()
        
    def setup_ui(self):
        layout = QVBoxLayout(self)
        
        # Header with title and clear button
        header_layout = QHBoxLayout()
        title = QLabel("Action History")
        title.setStyleSheet("font-size: 18px; font-weight: bold; color: white;")
        
        clear_btn = QPushButton(qta.icon('fa5s.trash'), "Clear History")
        clear_btn.clicked.connect(self.clear_history)
        
        header_layout.addWidget(title)
        header_layout.addStretch()
        header_layout.addWidget(clear_btn)
        
        # History table
        self.table = QTableWidget()
        self.table.setColumnCount(4)
        self.table.setHorizontalHeaderLabels(["Time", "Action", "Details", "Actions"])
        
        # Style the table
        self.table.setStyleSheet("""
            QTableWidget {
                background-color: #36393f;
                border: none;
                border-radius: 8px;
            }
            QTableWidget::item {
                padding: 8px;
                border-bottom: 1px solid #2f3136;
            }
            QHeaderView::section {
                background-color: #2f3136;
                padding: 8px;
                border: none;
                color: white;
                font-weight: bold;
            }
        """)
        
        # Set column stretching
        table_header = self.table.horizontalHeader()
        table_header.setSectionResizeMode(0, QHeaderView.Fixed)    # Time
        table_header.setSectionResizeMode(1, QHeaderView.Fixed)    # Action
        table_header.setSectionResizeMode(2, QHeaderView.Stretch)  # Details
        table_header.setSectionResizeMode(3, QHeaderView.Fixed)    # Actions
        
        self.table.setColumnWidth(0, 180)  # Time
        self.table.setColumnWidth(1, 120)  # Action
        self.table.setColumnWidth(3, 100)  # Actions
        
        # Context menu
        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.show_context_menu)
        
        # Add components to layout
        layout.addLayout(header_layout)
        layout.addWidget(self.table)
        
        self.refresh_history()
        
    # MODIFICATION: This function is modified to truncate script for display only
    def refresh_history(self):
        self.table.setRowCount(0)
        
        for entry in self.history_manager.history:
            row = self.table.rowCount()
            self.table.insertRow(row)
            
            # Time
            time_item = QTableWidgetItem(
                datetime.fromisoformat(entry['timestamp']).strftime('%Y-%m-%d %H:%M:%S')
            )
            
            # Action
            action_item = QTableWidgetItem(entry['type'])
            
            # Details
            details = entry['details']
            
            # MODIFICATION: Custom formatting for script_injection entries
            if entry['type'] == 'script_injection' and isinstance(details, dict):
                details_copy = details.copy() # Make a copy to modify
                script_content = details_copy.get('script', '')
                
                # Truncate *only for display*
                if len(script_content) > 100:
                    details_copy['script'] = script_content[:100] + "... (full script in context menu)"
                
                details_text = "\n".join(f"{k}: {v}" for k, v in details_copy.items())
            
            elif isinstance(details, dict):
                details_text = "\n".join(f"{k}: {v}" for k, v in details.items())
            else:
                details_text = str(details)
                
            details_item = QTableWidgetItem(details_text)
            # MODIFICATION: Store the original full entry data in the item for later use
            details_item.setData(Qt.UserRole, entry) 
            
            # Action buttons
            action_widget = QWidget()
            action_layout = QHBoxLayout(action_widget)
            action_layout.setContentsMargins(4, 4, 4, 4)
            
            if 'script' in entry['details']:
                inject_btn = QPushButton(qta.icon('fa5s.syringe'), "")
                # MODIFICATION: Ensure we are emitting the *full* script
                inject_btn.clicked.connect(
                    lambda x, s=entry['details']['script']: self.script_selected.emit(s)
                )
                action_layout.addWidget(inject_btn)
                
            action_layout.addStretch()
            
            # Add items to row
            self.table.setItem(row, 0, time_item)
            self.table.setItem(row, 1, action_item)
            self.table.setItem(row, 2, details_item)
            self.table.setCellWidget(row, 3, action_widget)
            
    def clear_history(self):
        reply = QMessageBox.question(
            self,
            "Clear History",
            "Are you sure you want to clear all history?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            self.history_manager.clear_history()
            self.refresh_history()
            
    def show_context_menu(self, position):
        menu = QMenu()
        
        copy_action = menu.addAction("Copy Full Details")
        copy_action.triggered.connect(
            lambda: self.copy_details(self.table.currentRow())
        )
        
        menu.exec_(self.table.viewport().mapToGlobal(position))
        
    # MODIFICATION: This function now copies the full, untruncated details
    def copy_details(self, row):
        if row >= 0:
            details_item = self.table.item(row, 2)
            if details_item:
                clipboard = QApplication.clipboard()
                
                # MODIFICATION: Copy the *full* details from UserRole, not the truncated text
                entry_data = details_item.data(Qt.UserRole)
                if entry_data and isinstance(entry_data, dict):
                    # Re-build the full details text from original data
                    details = entry_data.get('details', {})
                    if isinstance(details, dict):
                        details_text = "\n".join(f"{k}: {v}" for k, v in details.items())
                    else:
                        details_text = str(details)
                    clipboard.setText(details_text)
                else:
                    # Fallback to the visible text if something went wrong
                    clipboard.setText(details_item.text()) 
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\injection_panel.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
                           QLabel, QProgressBar, QFrame, QMessageBox, QFileDialog,
                           QTextEdit, QApplication, QLineEdit)
from PyQt5.QtCore import Qt, pyqtSignal
import qtawesome as qta
import os 

class InjectionPanel(QWidget):
    injection_started = pyqtSignal(str, int)  # script, pid
    injection_completed = pyqtSignal(bool, str)
    injection_stopped = pyqtSignal()
    
    message_posted = pyqtSignal(str)

    script_save_requested = pyqtSignal(str, str)

    def __init__(self):
        super().__init__()
        self.current_pid = None
        self.current_device_id = None
        self.script_editor_widget = None
        self.setup_ui()

    def setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 0, 5, 5) 
        layout.setSpacing(8) 

        status_frame = QFrame()
        status_frame.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 8px;
                padding: 8px 12px;
            }
        """)
        status_layout = QHBoxLayout(status_frame)
        status_layout.setContentsMargins(0,0,0,0) 

        self.status_icon = QLabel()
        self.status_icon.setPixmap(qta.icon('fa5s.circle', color='#99aab5').pixmap(14, 14)) 
        self.status_label = QLabel("No process selected")
        self.status_label.setStyleSheet("color: #99aab5; margin-left: 5px;") 

        status_layout.addWidget(self.status_icon)
        status_layout.addWidget(self.status_label)
        status_layout.addStretch()

        save_layout = QHBoxLayout()
        save_layout.setSpacing(6)
        
        self.save_name_input = QLineEdit()
        self.save_name_input.setObjectName('save_name_input')
        self.save_name_input.setPlaceholderText("New script name (e.g., 'my_hook')")
        self.save_name_input.setStyleSheet("padding: 5px;")
        
        js_label = QLabel(".js")
        js_label.setStyleSheet("font-weight: bold; color: #99aab5;")
        
        self.save_btn = QPushButton(qta.icon('fa5s.save', color='white'), " Save Script")
        self.save_btn.setStyleSheet("padding: 5px 10px; background-color: #7289da; border: none; border-radius: 4px; color: white;")
        self.save_btn.clicked.connect(self._save_script_clicked)
        
        save_layout.addWidget(self.save_name_input)
        save_layout.addWidget(js_label)
        save_layout.addWidget(self.save_btn)
        save_layout.addStretch()

        button_layout = QHBoxLayout()
        button_layout.setSpacing(6) 

        self.load_btn = QPushButton(qta.icon('fa5s.folder-open', color='white'), " Load")
        self.load_btn.clicked.connect(self.load_script_file)
        self.load_btn.setToolTip("Load script from .js file")
        self.load_btn.setStyleSheet("padding: 5px 10px; background-color: #5865f2; border: none; border-radius: 4px; color: white;")

        self.clear_btn = QPushButton(qta.icon('fa5s.trash-alt', color='white'), " Clear")
        self.clear_btn.clicked.connect(self.clear_script)
        self.clear_btn.setToolTip("Clear the script editor")
        self.clear_btn.setStyleSheet("padding: 5px 10px; background-color: #4f545c; border: none; border-radius: 4px; color: white;") 

        self.inject_btn = QPushButton(qta.icon('fa5s.syringe', color='white'), " Inject") 
        self.inject_btn.clicked.connect(self.execute_script) 
        self.inject_btn.setToolTip("Inject the current script into the selected process")
        self.inject_btn.setEnabled(False)
        self.inject_btn.setStyleSheet("""
            QPushButton { background-color: #43b581; color: white; padding: 5px 10px; border: none; border-radius: 4px; font-weight: bold; }
            QPushButton:hover { background-color: #3ca374; }
            QPushButton:disabled { background-color: #2f3136; color: #72767d; }
        """)

        self.stop_btn = QPushButton(qta.icon('fa5s.stop', color='white'), " Stop")
        self.stop_btn.clicked.connect(self.stop_injection)
        self.stop_btn.setToolTip("Stop the currently injected script")
        self.stop_btn.setEnabled(False)
        self.stop_btn.setStyleSheet("""
            QPushButton { background-color: #f04747; color: white; padding: 5px 10px; border: none; border-radius: 4px; font-weight: bold; }
            QPushButton:hover { background-color: #d84040; }
            QPushButton:disabled { background-color: #2f3136; color: #72767d; }
        """)

        button_layout.addWidget(self.load_btn)
        button_layout.addWidget(self.clear_btn)
        button_layout.addStretch() 
        button_layout.addWidget(self.inject_btn)
        button_layout.addWidget(self.stop_btn)

        self.progress_bar = QProgressBar()
        self.progress_bar.setTextVisible(False)
        self.progress_bar.setFixedHeight(6) 
        self.progress_bar.setStyleSheet("""
            QProgressBar {
                border: none;
                background-color: #2f3136;
                border-radius: 3px;
                text-align: center;
            }
            QProgressBar::chunk {
                background-color: #7289da;
                border-radius: 3px;
            }
        """)

        repl_layout = QHBoxLayout()
        repl_layout.setSpacing(6)
         
        self.command_input = QLineEdit()
        self.command_input.setPlaceholderText("Send message to script (e.g., 'COMMAND_NAME') and press Enter...")
        self.command_input.setStyleSheet("padding: 5px;")
        self.command_input.returnPressed.connect(self.post_message_to_script)
         
        self.send_btn = QPushButton(qta.icon('fa5s.paper-plane', color='white'), " Send")
        self.send_btn.clicked.connect(self.post_message_to_script)
        self.send_btn.setStyleSheet("padding: 5px 10px; background-color: #5865f2; border: none; border-radius: 4px; color: white;")
         
        repl_layout.addWidget(self.command_input)
        repl_layout.addWidget(self.send_btn)
        
        self.command_input.setEnabled(False)
        self.send_btn.setEnabled(False)
 
 
        layout.addWidget(status_frame)
        layout.addLayout(save_layout)
        layout.addLayout(button_layout)
        layout.addLayout(repl_layout)
        layout.addWidget(self.progress_bar)
    
    def _save_script_clicked(self):
        """Emits signal to save the current script content to a permanent file."""
        if not self.script_editor_widget:
            QMessageBox.critical(self, "Internal Error", "Script editor reference not set.")
            return

        script_content = self.script_editor_widget.toPlainText()
        script_name = self.save_name_input.text().strip()
        
        if not script_name:
            QMessageBox.warning(self, "Input Error", "Please enter a name for the script.")
            return

        if not script_content.strip():
            QMessageBox.warning(self, "Input Error", "Script content is empty. Cannot save.")
            return
            
        self.script_save_requested.emit(script_name, script_content)

    def set_script_editor_widget(self, editor_widget: QTextEdit): 
        """Sets the reference to the QTextEdit widget from ScriptEditorPanel."""
        self.script_editor_widget = editor_widget
        print("[InjectionPanel] Script editor widget reference set.")

    def clear_script(self):
        """Clears the script editor content."""
        if self.script_editor_widget:
            self.script_editor_widget.clear()
            print("[InjectionPanel] Script editor cleared.")
        else:
            print("[InjectionPanel] Error: Script editor reference not set.")
            QMessageBox.warning(self, "Internal Error", "Script editor reference not found.")

    def load_script_file(self):
        """Loads script content from a file into the editor."""
        if not self.script_editor_widget:
            QMessageBox.critical(self, "Internal Error", "Script editor reference not set.")
            return

        start_dir = os.getcwd()
        file_name, _ = QFileDialog.getOpenFileName(
            self,
            "Load Frida Script",
            start_dir,
            "JavaScript Files (*.js);;All Files (*.*)"
        )

        if file_name:
            try:
                with open(file_name, 'r', encoding='utf-8') as f:
                    script_content = f.read()
                self.script_editor_widget.setPlainText(script_content)
                self.status_label.setText(f"Loaded: {os.path.basename(file_name)}")
                self.status_icon.setPixmap(qta.icon('fa5s.circle', color='#99aab5').pixmap(14, 14))
                print(f"[InjectionPanel] Loaded script: {file_name}")
            except Exception as e:
                error_msg = f"Failed to load script: {str(e)}"
                print(f"[InjectionPanel] {error_msg}")
                QMessageBox.critical(self, "File Load Error", error_msg)

    def execute_script(self):
        """Validates and emits signal to start script injection."""
        if not self.script_editor_widget:
             QMessageBox.critical(self, "Internal Error", "Script editor reference not set.")
             return

        script_content = self.script_editor_widget.toPlainText()
        if not script_content.strip(): 
            QMessageBox.warning(self, "Input Error", "Script is empty! Please load or enter a script.")
            return

        if not self.current_pid or not self.current_device_id:
            QMessageBox.warning(self, "Input Error", "No process selected. Please select a device and process first.")
            return

        print(f"[InjectionPanel] Attempting to inject script into PID: {self.current_pid} on device: {self.current_device_id}")

        self.status_icon.setPixmap(qta.icon('fa5s.spinner', color='#faa61a', animation=qta.Spin(self.status_icon)).pixmap(14, 14)) 
        self.status_label.setText(f"Injecting into PID: {self.current_pid}...")
        self._set_buttons_state(injecting=True)
        self.progress_bar.show()
        self.progress_bar.setRange(0, 0)

        try:
            self.injection_started.emit(script_content, self.current_pid)
        except Exception as e:
            error_msg = f"Internal error starting injection process: {str(e)}"
            print(f"[InjectionPanel] {error_msg}")
            self.injection_failed(error_msg)

    def stop_injection(self):
        """Emits signal to stop the current script."""
        if not self.current_pid or not self.current_device_id:
             print("[InjectionPanel] Stop clicked but no active PID/Device known.")
             self._set_buttons_state(process_selected=False) 
             return

        print(f"[InjectionPanel] Attempting to stop script for PID: {self.current_pid} on device: {self.current_device_id}")
        self.status_label.setText(f"Stopping script in PID: {self.current_pid}...")
        self.status_icon.setPixmap(qta.icon('fa5s.spinner', color='#faa61a', animation=qta.Spin(self.status_icon)).pixmap(14, 14)) 
        self._set_buttons_state(stopping=True) 
        self.progress_bar.show()
        self.progress_bar.setRange(0, 0)

        self.injection_stopped.emit() 
        
    def post_message_to_script(self):
        """Gets text from command input and emits message_posted signal."""
        text = self.command_input.text()
        if not text.strip():
            return
            
        if self.send_btn.isEnabled():
            self.message_posted.emit(text)
            self.command_input.clear()

    def set_process(self, device_id, pid):
        """Updates the selected process and device ID. Called by MainWindow."""
        if pid is None:
            print("[InjectionPanel] set_process called with PID=None. Resetting state.")
            self.current_pid = None
            self.current_device_id = device_id 
            self.status_label.setText("No process selected" if device_id else "No device or process selected")
            self.status_icon.setPixmap(qta.icon('fa5s.circle', color='#99aab5').pixmap(14, 14)) 
            self._set_buttons_state(process_selected=False)
            return

        try:
            pid_int = int(pid)
            if pid_int <= 0:
                 raise ValueError("PID must be positive.")

            self.current_pid = pid_int
            self.current_device_id = device_id
            self.status_label.setText(f"Selected PID: {self.current_pid}") 
            self.status_icon.setPixmap(qta.icon('fa5s.circle', color='#43b581').pixmap(14, 14)) 
            self._set_buttons_state(process_selected=True)
            print(f"[InjectionPanel] Process set: PID={self.current_pid}, Device={self.current_device_id}")

        except (ValueError, TypeError) as e:
            print(f"[InjectionPanel] Error setting process: Invalid PID '{pid}'. {e}")
            self.current_pid = None
            self.current_device_id = device_id
            self.status_label.setText(f"Invalid PID")
            self.status_icon.setPixmap(qta.icon('fa5s.circle', color='#f04747').pixmap(14, 14)) 
            self._set_buttons_state(process_selected=False)

    def injection_succeeded(self):
        """Updates UI when injection is confirmed successful."""
        print(f"[InjectionPanel] Injection succeeded for PID {self.current_pid}")
        self.status_icon.setPixmap(qta.icon('fa5s.check-circle', color='#43b581').pixmap(14, 14)) 
        self.status_label.setText(f"Script running in PID: {self.current_pid}")
        self._set_buttons_state(script_running=True)
        self.progress_bar.hide()
        self.progress_bar.setRange(0, 1)

    def injection_failed(self, error_message="Unknown error"):
        """Updates UI when injection fails."""
        print(f"[InjectionPanel] Injection failed for PID {self.current_pid}: {error_message}")
        self.status_icon.setPixmap(qta.icon('fa5s.times-circle', color='#f04747').pixmap(14, 14)) 
        status_text = f"Injection failed"
        if self.current_pid:
            status_text += f": PID {self.current_pid}"
        self.status_label.setText(status_text)
        # FIX: The call to _set_buttons_state must pass a boolean for process_selected
        self._set_buttons_state(process_selected=bool(self.current_pid))
        self.progress_bar.hide()
        self.progress_bar.setRange(0, 1)

    def injection_stopped_update(self):
        """Updates UI after stop signal processing is complete (called by MainWindow)."""
        print(f"[InjectionPanel] Injection stopped confirmation received for PID {self.current_pid}")
        self._set_buttons_state(process_selected=bool(self.current_pid))
        self.progress_bar.hide()
        self.progress_bar.setRange(0, 1)
        if self.current_pid:
             self.status_label.setText(f"Selected PID: {self.current_pid}") 
             self.status_icon.setPixmap(qta.icon('fa5s.circle', color='#43b581').pixmap(14, 14)) 
        else:
             self.status_label.setText("No process selected") 
             self.status_icon.setPixmap(qta.icon('fa5s.circle', color='#99aab5').pixmap(14, 14)) 

    def injection_stopped_externally(self):
        """Called by MainWindow if script stops or detaches unexpectedly."""
        pid_context = f"PID {self.current_pid}" if self.current_pid else "process"
        print(f"[InjectionPanel] Script detached/stopped externally for {pid_context}")
        self.status_label.setText(f"Script detached from {pid_context}")
        self.status_icon.setPixmap(qta.icon('fa5s.exclamation-circle', color='#faa61a').pixmap(14, 14)) 
        self._set_buttons_state(process_selected=bool(self.current_pid))
        self.progress_bar.hide()
        self.progress_bar.setRange(0, 1)

    def _set_buttons_state(self, process_selected=False, injecting=False, script_running=False, stopping=False):
        """Centralized method to manage button enabled/disabled states."""
        can_inject = process_selected and not injecting and not script_running and not stopping
        can_stop = script_running and not stopping
        # FIX: The boolean expression result is cast to bool for PyQt's strict setEnabled.
        can_load_clear_save = bool(not injecting and not stopping) 
        # MODIFICATION: Can only send messages when a script is running
        can_send_message = script_running and not stopping

        self.inject_btn.setEnabled(can_inject)
        self.stop_btn.setEnabled(can_stop)
        self.load_btn.setEnabled(can_load_clear_save)
        self.clear_btn.setEnabled(can_load_clear_save)
        self.save_btn.setEnabled(can_load_clear_save) # MODIFICATION: Set save button state
        self.save_name_input.setEnabled(can_load_clear_save) # MODIFICATION: Set save input state
        
        # MODIFICATION: Enable/disable REPL
        self.command_input.setEnabled(can_send_message)
        self.send_btn.setEnabled(can_send_message) 
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\OLDprocess_monitor.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
                           QLabel, QLineEdit, QTableWidget, QTableWidgetItem,
                           QMenu, QAction, QComboBox, QCheckBox, QFrame,
                           QHeaderView, QStyle, QStyledItemDelegate, QToolButton, QMessageBox)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer, QSize
from PyQt5.QtGui import QColor, QFont, QIcon
import frida
import re
import qtawesome as qta
from datetime import datetime
import subprocess

class ProcessInfoDelegate(QStyledItemDelegate):
    def paint(self, painter, option, index):
        if index.column() in [2, 3]:  # CPU and Memory columns
            value_str = index.data().replace('%', '').replace('MB', '').strip()
            if value_str and value_str != 'N/A':
                try:
                    value = float(value_str)
                    if value > 80:
                        option.backgroundBrush = QColor('#f04747')
                    elif value > 50:
                        option.backgroundBrush = QColor('#faa61a')
                except ValueError:
                    pass
        super().paint(painter, option, index)

class ProcessMonitor(QWidget):
    def __init__(self, main_window=None):
        QWidget.__init__(self)
        self.processes = []
        self.current_device = None
        self.main_window = main_window
        self.setup_ui()
        self.start_monitoring()

    def start_monitoring(self):
        self.update_timer = QTimer()
        self.update_timer.timeout.connect(self.refresh_processes)
        self.update_timer.start(3000)  # Update every 3 seconds

    def stop_monitoring(self):
        if hasattr(self, 'update_timer'):
            self.update_timer.stop()

    def setup_ui(self):
        layout = QVBoxLayout(self)

        # Device selection
        device_frame = QFrame()
        device_frame.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 8px;
                padding: 10px;
            }
        """)
        device_layout = QHBoxLayout(device_frame)

        self.device_combo = QComboBox()
        self.device_combo.currentIndexChanged.connect(self.on_device_changed)

        refresh_devices_btn = QPushButton(qta.icon('fa5s.sync'), "Refresh Devices")
        refresh_devices_btn.clicked.connect(self.refresh_devices)

        device_layout.addWidget(QLabel("Device:"))
        device_layout.addWidget(self.device_combo)
        device_layout.addWidget(refresh_devices_btn)

        # Search and Filter Bar
        filter_frame = QFrame()
        filter_frame.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 8px;
                padding: 10px;
            }
        """)
        filter_layout = QHBoxLayout(filter_frame)

        # Process search with regex toggle
        search_container = QFrame()
        search_layout = QHBoxLayout(search_container)

        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText(" Filter processes (supports regex)")
        self.search_input.textChanged.connect(self.apply_filters)

        self.regex_check = QCheckBox("Regex")
        self.regex_check.toggled.connect(self.apply_filters)

        search_layout.addWidget(self.search_input)
        search_layout.addWidget(self.regex_check)

        # Advanced filters
        self.filter_combo = QComboBox()
        self.filter_combo.addItems(['All', 'User Apps', 'System', 'Running', 'Debuggable'])
        self.filter_combo.currentTextChanged.connect(self.apply_filters)

        filter_layout.addWidget(search_container)
        filter_layout.addWidget(self.filter_combo)

        # Process Table
        self.process_table = QTableWidget()
        self.process_table.setColumnCount(6)
        self.process_table.setHorizontalHeaderLabels([
            "PID", "Name", "Package", "User", "Status", "Debuggable"
        ])

        # Set column widths
        header = self.process_table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Fixed)  # PID
        header.setSectionResizeMode(1, QHeaderView.Stretch)  # Name
        header.setSectionResizeMode(2, QHeaderView.Stretch)  # Package
        header.setSectionResizeMode(3, QHeaderView.Fixed)  # User
        header.setSectionResizeMode(4, QHeaderView.Fixed)  # Status
        header.setSectionResizeMode(5, QHeaderView.Fixed)  # Debuggable

        self.process_table.setColumnWidth(0, 80)
        self.process_table.setColumnWidth(3, 100)
        self.process_table.setColumnWidth(4, 100)
        self.process_table.setColumnWidth(5, 100)

        # Enable sorting
        self.process_table.setSortingEnabled(True)

        # Context menu
        self.process_table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.process_table.customContextMenuRequested.connect(self.show_context_menu)

        # Action buttons
        action_layout = QHBoxLayout()

        self.refresh_btn = QPushButton(qta.icon('fa5s.sync'), "Refresh")
        self.refresh_btn.clicked.connect(self.refresh_processes)

        self.kill_btn = QPushButton(qta.icon('fa5s.stop'), "Kill Process")
        self.kill_btn.clicked.connect(self.kill_selected_process)

        self.inject_btn = QPushButton(qta.icon('fa5s.syringe'), "Open in Injector")
        self.inject_btn.clicked.connect(self.open_in_injector_clicked)

        self.dump_btn = QPushButton(qta.icon('fa5s.download'), "Dump APK")
        self.dump_btn.clicked.connect(self.dump_apk)

        action_layout.addWidget(self.refresh_btn)
        action_layout.addWidget(self.kill_btn)
        action_layout.addWidget(self.inject_btn)
        action_layout.addWidget(self.dump_btn)
        action_layout.addStretch()

        # Status bar
        status_bar = QFrame()
        status_bar.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 4px;
                padding: 5px;
            }
        """)
        status_layout = QHBoxLayout(status_bar)

        self.process_count = QLabel("0 processes")
        self.status_label = QLabel("Ready")

        status_layout.addWidget(self.process_count)
        status_layout.addStretch()
        status_layout.addWidget(self.status_label)

        # Add all components
        layout.addWidget(device_frame)
        layout.addWidget(filter_frame)
        layout.addWidget(self.process_table)
        layout.addLayout(action_layout)
        layout.addWidget(status_bar)

        # Initial device scan
        self.refresh_devices()

    def refresh_devices(self):
        self.device_combo.clear()
        try:
            devices = frida.enumerate_devices()
            for device in devices:
                if device.type == 'usb':
                    self.device_combo.addItem(f" {device.name} (USB)", device.id)
        except Exception as e:
            print(f"Error enumerating devices: {e}")

    def on_device_changed(self, index):
        if index >= 0:
            self.current_device = self.device_combo.currentData()
            self.refresh_processes()

    def show_context_menu(self, position):
        menu = QMenu()

        kill_action = QAction("Kill Process", self)
        kill_action.triggered.connect(self.kill_selected_process)

        inject_action = QAction("Open in Injector", self)
        inject_action.triggered.connect(self.open_in_injector_clicked)

        dump_action = QAction("Dump APK", self)
        dump_action.triggered.connect(self.dump_apk)

        details_action = QAction("Process Details", self)
        details_action.triggered.connect(self.show_process_details)

        menu.addAction(kill_action)
        menu.addAction(inject_action)
        menu.addAction(dump_action)
        menu.addSeparator()
        menu.addAction(details_action)
        menu.exec_(self.process_table.mapToGlobal(position))

    def open_in_injector_clicked(self):
        """Handle click on 'Open in Injector' button"""
        if not self.main_window:
            return

        selected = self.process_table.selectedItems()
        if selected:
            row = selected[0].row()
            try:
                pid = int(self.process_table.item(row, 0).text())
                if self.current_device:
                    self.main_window.open_in_injector(self.current_device, pid)
                else:
                    QMessageBox.warning(self, "Error", "No device selected!")
            except ValueError:
                QMessageBox.critical(self, "Error", "Invalid PID format.")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Error: {e}")

    def refresh_processes(self):
        """Refresh process list using ps command"""
        selected_pid = None
        if self.process_table.selectedItems():
            row = self.process_table.currentRow()
            if row != -1:
                selected_pid = self.process_table.item(row, 0).text()

        self.process_table.setSortingEnabled(False)
        self.process_table.setRowCount(0)
        self.processes.clear()

        if not self.current_device:
            return

        try:
            self.status_label.setText("Refreshing processes...")
            
            # Get process list using ps -A
            adb_output = subprocess.check_output(
                ['adb', '-s', self.current_device, 'shell', 'ps', '-A'],
                text=True,
                stderr=subprocess.DEVNULL
            ).strip().split('\n')

            # Get debuggable packages
            debuggable_pkgs = self.get_debuggable_packages()

            # Parse process list
            for line in adb_output[1:]:  # Skip header
                parts = line.split()
                if len(parts) >= 9:
                    try:
                        user = parts[0]
                        pid = parts[1]
                        # Remove leading 'S', 'R', 'D', etc. status indicators
                        name = parts[8] if len(parts) > 8 else parts[-1]
                        
                        # Clean up process name (remove status prefix if present)
                        if name and len(name) > 1 and name[0] in 'SDTRZX':
                            name = name[1:]
                        
                        status = parts[7] if len(parts) > 7 else 'Unknown'
                        
                        # Determine package name (for apps)
                        package = name if '.' in name else 'N/A'
                        
                        # Check if debuggable
                        is_debuggable = package in debuggable_pkgs
                        
                        process_info = {
                            'pid': pid,
                            'name': name,
                            'package': package,
                            'user': user,
                            'status': status,
                            'debuggable': is_debuggable
                        }
                        
                        self.processes.append(process_info)
                        
                    except (IndexError, ValueError) as e:
                        continue

            self.update_table()
            self.status_label.setText(f"Loaded {len(self.processes)} processes")

        except subprocess.CalledProcessError as e:
            print(f"ADB error: {e}")
            self.status_label.setText("Error: ADB command failed")
        except Exception as e:
            print(f"Error refreshing processes: {e}")
            self.status_label.setText(f"Error: {str(e)}")

        # Restore selection
        if selected_pid:
            for row in range(self.process_table.rowCount()):
                if self.process_table.item(row, 0).text() == selected_pid:
                    self.process_table.selectRow(row)
                    break

        self.process_table.setSortingEnabled(True)

    def get_debuggable_packages(self):
        """Get list of debuggable packages"""
        try:
            output = subprocess.check_output(
                ['adb', '-s', self.current_device, 'shell', 'pm', 'list', 'packages', '-d'],
                text=True,
                stderr=subprocess.DEVNULL
            )
            packages = set()
            for line in output.strip().split('\n'):
                if line.startswith('package:'):
                    packages.add(line.replace('package:', ''))
            return packages
        except:
            return set()

    def update_table(self):
        """Populate table with process data"""
        for process in self.processes:
            row = self.process_table.rowCount()
            self.process_table.insertRow(row)

            items = [
                QTableWidgetItem(process['pid']),
                QTableWidgetItem(process['name']),
                QTableWidgetItem(process['package']),
                QTableWidgetItem(process['user']),
                QTableWidgetItem(process['status']),
                QTableWidgetItem(' Yes' if process['debuggable'] else ' No')
            ]

            # Center align PID, User, Status, Debuggable
            items[0].setTextAlignment(Qt.AlignCenter)
            items[3].setTextAlignment(Qt.AlignCenter)
            items[4].setTextAlignment(Qt.AlignCenter)
            items[5].setTextAlignment(Qt.AlignCenter)

            # Color code debuggable apps
            if process['debuggable']:
                items[5].setForeground(QColor('#43b581'))

            # Add items to row
            for col, item in enumerate(items):
                self.process_table.setItem(row, col, item)

        self.apply_filters()
        self.process_count.setText(f"{self.process_table.rowCount()} processes")

    def apply_filters(self):
        """Apply search and filter criteria"""
        search_text = self.search_input.text().lower()
        filter_type = self.filter_combo.currentText()
        use_regex = self.regex_check.isChecked()

        visible_count = 0
        for row in range(self.process_table.rowCount()):
            show_row = True
            name_item = self.process_table.item(row, 1)
            package_item = self.process_table.item(row, 2)
            debuggable_item = self.process_table.item(row, 5)

            if not name_item:
                continue

            name = name_item.text().lower()
            package = package_item.text().lower() if package_item else ''

            # Apply text filter
            if search_text:
                if use_regex:
                    try:
                        if not (re.search(search_text, name) or re.search(search_text, package)):
                            show_row = False
                    except re.error:
                        show_row = False
                elif search_text not in name and search_text not in package:
                    show_row = False

            # Apply type filter
            if filter_type == 'User Apps' and '.' not in package:
                show_row = False
            elif filter_type == 'System' and '.' in package:
                show_row = False
            elif filter_type == 'Debuggable' and not debuggable_item.text().startswith(''):
                show_row = False

            self.process_table.setRowHidden(row, not show_row)
            if show_row:
                visible_count += 1

        self.process_count.setText(f"{visible_count} processes (of {self.process_table.rowCount()})")

    def kill_selected_process(self):
        """Kill the selected process"""
        selected = self.process_table.selectedItems()
        if selected:
            row = selected[0].row()
            pid = self.process_table.item(row, 0).text()
            name = self.process_table.item(row, 1).text()
            
            reply = QMessageBox.question(
                self, 
                "Kill Process",
                f"Are you sure you want to kill process:\n{name} (PID: {pid})?",
                QMessageBox.Yes | QMessageBox.No
            )
            
            if reply == QMessageBox.Yes:
                try:
                    subprocess.run(
                        ['adb', '-s', self.current_device, 'shell', 'kill', pid],
                        check=True
                    )
                    self.status_label.setText(f"Killed process {pid}")
                    self.refresh_processes()
                except Exception as e:
                    QMessageBox.critical(self, "Error", f"Failed to kill process: {e}")

    def dump_apk(self):
        """Dump APK of selected app"""
        selected = self.process_table.selectedItems()
        if selected:
            row = selected[0].row()
            package = self.process_table.item(row, 2).text()
            
            if package == 'N/A' or '.' not in package:
                QMessageBox.warning(self, "Error", "Not an app package")
                return
            
            try:
                # Get APK path
                path_output = subprocess.check_output(
                    ['adb', '-s', self.current_device, 'shell', 'pm', 'path', package],
                    text=True
                ).strip()
                
                if not path_output.startswith('package:'):
                    raise Exception("Could not find APK path")
                
                apk_path = path_output.replace('package:', '')
                
                # Pull APK
                output_path = f"{package}.apk"
                subprocess.run(
                    ['adb', '-s', self.current_device, 'pull', apk_path, output_path],
                    check=True
                )
                
                QMessageBox.information(self, "Success", f"APK dumped to: {output_path}")
                
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to dump APK: {e}")

    def show_process_details(self):
        """Show detailed info about selected process"""
        selected = self.process_table.selectedItems()
        if selected:
            row = selected[0].row()
            details = "\n".join([
                f"{self.process_table.horizontalHeaderItem(col).text()}: "
                f"{self.process_table.item(row, col).text()}"
                for col in range(self.process_table.columnCount())
            ])
            QMessageBox.information(self, "Process Details", details)
 
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\output_panel.py --- 
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QTextEdit, QHBoxLayout, QLabel, QPushButton, QFrame
from datetime import datetime
import qtawesome as qta 

class OutputPanel(QWidget):
    def __init__(self):
        super().__init__()
        self._title = "Output"
        self.setup_ui()

    def setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        # MODIFICATION: Header/Toolbar for Title and Clear Button
        header_frame = QFrame()
        header_frame.setStyleSheet("""
            QFrame { background-color: #2f3136; border: none; padding: 4px; }
        """)
        header_layout = QHBoxLayout(header_frame)
        header_layout.setContentsMargins(8, 0, 8, 0)
        
        self.title_label = QLabel(self._title)
        self.title_label.setStyleSheet("font-size: 13px; font-weight: bold; color: #dcddde;")

        # MODIFICATION: Clear Button
        self.clear_btn = QPushButton(qta.icon('fa5s.trash-alt', color='#f04747'), " Clear")
        self.clear_btn.clicked.connect(self.clear_output)
        self.clear_btn.setFlat(True)
        self.clear_btn.setStyleSheet("""
            QPushButton { color: #f04747; padding: 2px 5px; background-color: transparent; border: none; } 
            QPushButton:hover { color: white; }
        """)

        header_layout.addWidget(self.title_label)
        header_layout.addStretch()
        header_layout.addWidget(self.clear_btn)
        
        self.output_area = QTextEdit()
        self.output_area.setReadOnly(True)
        self.output_area.setPlaceholderText("Output will appear here...")
        self.output_area.setStyleSheet("border-top-left-radius: 0px; border-top-right-radius: 0px;")

        layout.addWidget(header_frame)
        layout.addWidget(self.output_area)
    
    # MODIFICATION: New method to allow main window to set the title
    def set_title(self, title):
        self._title = title
        self.title_label.setText(title)

    def append_output(self, text):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.output_area.append(f"[{timestamp}] {text}")

    def clear_output(self):
        self.output_area.clear() 
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\process_manager.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, 
                           QLabel, QLineEdit, QTableWidget, QTableWidgetItem,
                           QMenu, QAction, QComboBox, QCheckBox, QFrame,
                           QTableWidgetSelectionRange, QHeaderView)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer
from PyQt5.QtGui import QColor, QFont
import qtawesome as qta
import re
import psutil

class ProcessManager(QWidget):
    process_selected = pyqtSignal(int)  # pid
    
    def __init__(self):
        super().__init__()
        self.processes = {}
        self.filters = {
            'name': '',
            'pid': '',
            'cpu': 0,
            'memory': 0,
            'show_system': False
        }
        self.setup_ui()
        self.start_monitoring()
        
    def setup_ui(self):
        layout = QVBoxLayout(self)
        
        # Filter bar
        filter_frame = QFrame()
        filter_frame.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 8px;
                padding: 10px;
            }
        """)
        filter_layout = QHBoxLayout(filter_frame)
        
        # Search with regex support
        search_container = QFrame()
        search_layout = QHBoxLayout(search_container)
        
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Filter processes (supports regex)")
        self.search_input.textChanged.connect(self.apply_filters)
        
        self.regex_check = QCheckBox("Regex")
        self.regex_check.toggled.connect(self.apply_filters)
        
        search_layout.addWidget(self.search_input)
        search_layout.addWidget(self.regex_check)
        
        # Advanced filters
        self.filter_combo = QComboBox()
        self.filter_combo.addItems(['All', 'User', 'System', 'Android Apps'])
        self.filter_combo.currentTextChanged.connect(self.apply_filters)
        
        # Resource thresholds
        self.cpu_threshold = QSpinBox()
        self.cpu_threshold.setSuffix("% CPU")
        self.cpu_threshold.valueChanged.connect(self.apply_filters)
        
        self.memory_threshold = QSpinBox()
        self.memory_threshold.setSuffix("MB")
        self.memory_threshold.setMaximum(32000)
        self.memory_threshold.valueChanged.connect(self.apply_filters)
        
        filter_layout.addWidget(search_container)
        filter_layout.addWidget(self.filter_combo)
        filter_layout.addWidget(self.cpu_threshold)
        filter_layout.addWidget(self.memory_threshold)
        
        # Process table
        self.process_table = QTableWidget()
        self.process_table.setColumnCount(6)
        self.process_table.setHorizontalHeaderLabels([
            "PID", "Name", "CPU %", "Memory", "Status", "Path"
        ])
        
        # Style the table
        self.process_table.setStyleSheet("""
            QTableWidget {
                background-color: #36393f;
                border: none;
                border-radius: 8px;
                gridline-color: #2f3136;
            }
            QTableWidget::item {
                padding: 5px;
                border-bottom: 1px solid #2f3136;
            }
            QTableWidget::item:selected {
                background-color: #7289da;
            }
        """)
        
        # Set column widths
        header = self.process_table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Fixed)  # PID
        header.setSectionResizeMode(1, QHeaderView.Stretch)  # Name
        header.setSectionResizeMode(2, QHeaderView.Fixed)  # CPU
        header.setSectionResizeMode(3, QHeaderView.Fixed)  # Memory
        header.setSectionResizeMode(4, QHeaderView.Fixed)  # Status
        header.setSectionResizeMode(5, QHeaderView.Stretch)  # Path
        
        self.process_table.setColumnWidth(0, 70)  # PID
        self.process_table.setColumnWidth(2, 80)  # CPU
        self.process_table.setColumnWidth(3, 100)  # Memory
        self.process_table.setColumnWidth(4, 100)  # Status
        
        # Context menu
        self.process_table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.process_table.customContextMenuRequested.connect(self.show_context_menu)
        
        # Quick action buttons
        action_layout = QHBoxLayout()
        
        self.refresh_btn = QPushButton(qta.icon('fa5s.sync'), "Refresh")
        self.refresh_btn.clicked.connect(self.refresh_processes)
        
        self.kill_btn = QPushButton(qta.icon('fa5s.stop'), "Kill")
        self.kill_btn.clicked.connect(self.kill_selected_process)
        
        self.inject_btn = QPushButton(qta.icon('fa5s.syringe'), "Inject")
        self.inject_btn.clicked.connect(self.inject_into_selected)
        
        action_layout.addWidget(self.refresh_btn)
        action_layout.addWidget(self.kill_btn)
        action_layout.addWidget(self.inject_btn)
        action_layout.addStretch()
        
        # Status bar
        status_bar = QFrame()
        status_bar.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 4px;
                padding: 5px;
            }
        """)
        status_layout = QHBoxLayout(status_bar)
        
        self.process_count = QLabel("0 processes")
        self.cpu_usage = QLabel("CPU: 0%")
        self.memory_usage = QLabel("Memory: 0 MB")
        
        status_layout.addWidget(self.process_count)
        status_layout.addStretch()
        status_layout.addWidget(self.cpu_usage)
        status_layout.addWidget(self.memory_usage)
        
        # Add all components
        layout.addWidget(filter_frame)
        layout.addWidget(self.process_table)
        layout.addLayout(action_layout)
        layout.addWidget(status_bar)
        
    def start_monitoring(self):
        self.update_timer = QTimer()
        self.update_timer.timeout.connect(self.refresh_processes)
        self.update_timer.start(2000)  # Update every 2 seconds
        
    def refresh_processes(self):
        self.processes.clear()
        total_cpu = 0
        total_memory = 0
        
        for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_info', 'status', 'exe']):
            try:
                info = proc.info
                memory_mb = info['memory_info'].rss / 1024 / 1024
                self.processes[info['pid']] = {
                    'name': info['name'],
                    'cpu': info['cpu_percent'],
                    'memory': memory_mb,
                    'status': info['status'],
                    'path': info['exe'] or ''
                }
                total_cpu += info['cpu_percent']
                total_memory += memory_mb
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
                
        self.update_table()
        self.update_stats(total_cpu, total_memory)
        
    def update_table(self):
        self.process_table.setSortingEnabled(False)
        self.process_table.setRowCount(0)
        
        filtered_processes = self.filter_processes()
        
        for pid, info in filtered_processes.items():
            row = self.process_table.rowCount()
            self.process_table.insertRow(row)
            
            # PID
            pid_item = QTableWidgetItem(str(pid))
            pid_item.setTextAlignment(Qt.AlignCenter)
            
            # Name
            name_item = QTableWidgetItem(info['name'])
            
            # CPU
            cpu_item = QTableWidgetItem(f"{info['cpu']:.1f}%")
            cpu_item.setTextAlignment(Qt.AlignCenter)
            
            # Memory
            memory_item = QTableWidgetItem(f"{info['memory']:.1f} MB")
            memory_item.setTextAlignment(Qt.AlignCenter)
            
            # Status
            status_item = QTableWidgetItem(info['status'])
            status_item.setTextAlignment(Qt.AlignCenter)
            
            # Path
            path_item = QTableWidgetItem(info['path'])
            
            # Set items
            self.process_table.setItem(row, 0, pid_item)
            self.process_table.setItem(row, 1, name_item)
            self.process_table.setItem(row, 2, cpu_item)
            self.process_table.setItem(row, 3, memory_item)
            self.process_table.setItem(row, 4, status_item)
            self.process_table.setItem(row, 5, path_item)
            
            # Color coding based on resource usage
            if info['cpu'] > 50:
                self.color_row(row, QColor(240, 71, 71, 50))  # Red
            elif info['memory'] > 1000:
                self.color_row(row, QColor(250, 166, 26, 50))  # Orange
                
        self.process_table.setSortingEnabled(True)
        
    def filter_processes(self):
        filtered = {}
        search_text = self.search_input.text().lower()
        
        for pid, info in self.processes.items():
            # Apply regex/text filter
            if self.regex_check.isChecked():
                try:
                    if not re.search(search_text, info['name'].lower()):
                        continue
                except re.error:
                    continue
            elif search_text and search_text not in info['name'].lower():
                continue
                
            # Apply type filter
            if self.filter_combo.currentText() == 'User' and pid < 1000:
                continue
            elif self.filter_combo.currentText() == 'System' and pid >= 1000:
                continue
            elif self.filter_combo.currentText() == 'Android Apps' and not info['name'].startswith('com.'):
                continue
                
            # Apply resource thresholds
            if info['cpu'] < self.cpu_threshold.value():
                continue
            if info['memory'] < self.memory_threshold.value():
                continue
                
            filtered[pid] = info
            
        return filtered
        
    def color_row(self, row, color):
        for col in range(self.process_table.columnCount()):
            item = self.process_table.item(row, col)
            item.setBackground(color)
            
    def update_stats(self, total_cpu, total_memory):
        self.process_count.setText(f"{len(self.processes)} processes")
        self.cpu_usage.setText(f"CPU: {total_cpu:.1f}%")
        self.memory_usage.setText(f"Memory: {total_memory:.0f} MB")
        
    def show_context_menu(self, position):
        menu = QMenu()
        
        kill_action = QAction("Kill Process", self)
        kill_action.triggered.connect(self.kill_selected_process)
        
        inject_action = QAction("Inject Script", self)
        inject_action.triggered.connect(self.inject_into_selected)
        
        menu.addAction(kill_action)
        menu.addAction(inject_action)
        menu.exec_(self.process_table.mapToGlobal(position))
        
    def kill_selected_process(self):
        selected = self.process_table.selectedItems()
        if selected:
            pid = int(self.process_table.item(selected[0].row(), 0).text())
            try:
                psutil.Process(pid).terminate()
                self.refresh_processes()
            except psutil.NoSuchProcess:
                pass
                
    def inject_into_selected(self):
        selected = self.process_table.selectedItems()
        if selected:
            pid = int(self.process_table.item(selected[0].row(), 0).text())
            self.process_selected.emit(pid)  
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\process_monitor.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
                           QLabel, QLineEdit, QTableWidget, QTableWidgetItem,
                           QMenu, QAction, QComboBox, QCheckBox, QFrame,
                           QHeaderView, QStyle, QStyledItemDelegate, QToolButton, QMessageBox)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer, QSize
from PyQt5.QtGui import QColor, QFont, QIcon
from PyQt5.QtCore import QThread, QObject, pyqtSignal
import frida
import re
import qtawesome as qta
from datetime import datetime
import subprocess


class KillProcessWorker(QObject):
    finished = pyqtSignal(str, str) # Signals success: pid, name
    error = pyqtSignal(str)         # Signals error message

    def __init__(self, device_id, pid, name, parent=None):
        super().__init__(parent)
        self._device_id = device_id
        self._pid = pid
        self._name = name

    def run(self):
        try:
            subprocess.run(
                ['adb', '-s', self._device_id, 'shell', 'am', 'force-stop', self._name],
                check=True,
                capture_output=True,
                text=True,
                # Add isolation and resource limits if possible (timeout is best)
                # Adding a timeout is crucial to prevent indefinite blocking
                timeout=10 
            )
            self.finished.emit(self._pid, self._name)
        except subprocess.CalledProcessError as e:
            # Handle non-zero exit code specifically
            self.error.emit(f"Command failed (Code: {e.returncode}): {e.stderr}")
        except subprocess.TimeoutExpired:
            # Handle command timing out
            self.error.emit("Process kill command timed out.")
        except Exception as e:
            # Crucial: Catch all other exceptions (e.g., adb disconnect)
            self.error.emit(f"Unhandled kill error: {type(e).__name__} - {str(e)}")

class ProcessInfoDelegate(QStyledItemDelegate):
    def paint(self, painter, option, index):
        if index.column() in [2, 3]:  # CPU and Memory columns
            value_str = index.data().replace('%', '').replace('MB', '').strip()
            if value_str and value_str != 'N/A':
                try:
                    value = float(value_str)
                    if value > 80:
                        option.backgroundBrush = QColor('#f04747')
                    elif value > 50:
                        option.backgroundBrush = QColor('#faa61a')
                except ValueError:
                    pass
        super().paint(painter, option, index)

class ProcessMonitor(QWidget):
    def __init__(self, main_window=None):
        QWidget.__init__(self)
        self.processes = []
        self.current_device = None
        self.main_window = main_window
        self.setup_ui()
        self.start_monitoring()

    def start_monitoring(self):
        self.update_timer = QTimer()
        self.update_timer.timeout.connect(self.refresh_processes)
        self.update_timer.start(3000)  # Update every 3 seconds

    def stop_monitoring(self):
        if hasattr(self, 'update_timer'):
            self.update_timer.stop()

    def setup_ui(self):
        layout = QVBoxLayout(self)

        # Device selection
        device_frame = QFrame()
        device_frame.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 8px;
                padding: 10px;
            }
        """)
        device_layout = QHBoxLayout(device_frame)

        self.device_combo = QComboBox()
        self.device_combo.currentIndexChanged.connect(self.on_device_changed)

        refresh_devices_btn = QPushButton(qta.icon('fa5s.sync'), "Refresh Devices")
        refresh_devices_btn.clicked.connect(self.refresh_devices)

        device_layout.addWidget(QLabel("Device:"))
        device_layout.addWidget(self.device_combo)
        device_layout.addWidget(refresh_devices_btn)

        # Search and Filter Bar
        filter_frame = QFrame()
        filter_frame.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 8px;
                padding: 10px;
            }
        """)
        filter_layout = QHBoxLayout(filter_frame)

        # Process search with regex toggle
        search_container = QFrame()
        search_layout = QHBoxLayout(search_container)

        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText(" Filter processes (supports regex)")
        self.search_input.textChanged.connect(self.apply_filters)

        self.regex_check = QCheckBox("Regex")
        self.regex_check.toggled.connect(self.apply_filters)

        search_layout.addWidget(self.search_input)
        search_layout.addWidget(self.regex_check)

        # Advanced filters
        self.filter_combo = QComboBox()
        self.filter_combo.addItems(['All', 'User Apps', 'System', 'Running', 'Debuggable'])
        self.filter_combo.currentTextChanged.connect(self.apply_filters)

        filter_layout.addWidget(search_container)
        filter_layout.addWidget(self.filter_combo)

        # Process Table
        self.process_table = QTableWidget()
        self.process_table.setColumnCount(6)
        self.process_table.setHorizontalHeaderLabels([
            "PID", "Name", "Package", "User", "Status", "Debuggable"
        ])

        # Set column widths
        header = self.process_table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Fixed)  # PID
        header.setSectionResizeMode(1, QHeaderView.Stretch)  # Name
        header.setSectionResizeMode(2, QHeaderView.Stretch)  # Package
        header.setSectionResizeMode(3, QHeaderView.Fixed)  # User
        header.setSectionResizeMode(4, QHeaderView.Fixed)  # Status
        header.setSectionResizeMode(5, QHeaderView.Fixed)  # Debuggable

        self.process_table.setColumnWidth(0, 80)
        self.process_table.setColumnWidth(3, 100)
        self.process_table.setColumnWidth(4, 100)
        self.process_table.setColumnWidth(5, 100)

        # Enable sorting
        self.process_table.setSortingEnabled(True)

        # Context menu
        self.process_table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.process_table.customContextMenuRequested.connect(self.show_context_menu)

        # Action buttons
        action_layout = QHBoxLayout()

        self.refresh_btn = QPushButton(qta.icon('fa5s.sync'), "Refresh")
        self.refresh_btn.clicked.connect(self.refresh_processes)

        self.kill_btn = QPushButton(qta.icon('fa5s.stop'), "Kill Process")
        self.kill_btn.clicked.connect(self.kill_selected_process)

        self.inject_btn = QPushButton(qta.icon('fa5s.syringe'), "Open in Injector")
        self.inject_btn.clicked.connect(self.open_in_injector_clicked)

        self.dump_btn = QPushButton(qta.icon('fa5s.download'), "Dump APK")
        self.dump_btn.clicked.connect(self.dump_apk)

        action_layout.addWidget(self.refresh_btn)
        action_layout.addWidget(self.kill_btn)
        action_layout.addWidget(self.inject_btn)
        action_layout.addWidget(self.dump_btn)
        action_layout.addStretch()

        # Status bar
        status_bar = QFrame()
        status_bar.setStyleSheet("""
            QFrame {
                background-color: #2f3136;
                border-radius: 4px;
                padding: 5px;
            }
        """)
        status_layout = QHBoxLayout(status_bar)

        self.process_count = QLabel("0 processes")
        self.status_label = QLabel("Ready")

        status_layout.addWidget(self.process_count)
        status_layout.addStretch()
        status_layout.addWidget(self.status_label)

        # Add all components
        layout.addWidget(device_frame)
        layout.addWidget(filter_frame)
        layout.addWidget(self.process_table)
        layout.addLayout(action_layout)
        layout.addWidget(status_bar)

        # Initial device scan
        self.refresh_devices()

    def refresh_devices(self):
        self.device_combo.clear()
        try:
            devices = frida.enumerate_devices()
            for device in devices:
                if device.type == 'usb':
                    self.device_combo.addItem(f" {device.name} (USB)", device.id)
        except Exception as e:
            print(f"Error enumerating devices: {e}")

    def on_device_changed(self, index):
        if index >= 0:
            self.current_device = self.device_combo.currentData()
            self.refresh_processes()

    def show_context_menu(self, position):
        menu = QMenu()

        kill_action = QAction("Kill Process", self)
        kill_action.triggered.connect(self.kill_selected_process)

        inject_action = QAction("Open in Injector", self)
        inject_action.triggered.connect(self.open_in_injector_clicked)

        dump_action = QAction("Dump APK", self)
        dump_action.triggered.connect(self.dump_apk)

        details_action = QAction("Process Details", self)
        details_action.triggered.connect(self.show_process_details)

        menu.addAction(kill_action)
        menu.addAction(inject_action)
        menu.addAction(dump_action)
        menu.addSeparator()
        menu.addAction(details_action)
        menu.exec_(self.process_table.mapToGlobal(position))

    def open_in_injector_clicked(self):
        """Handle click on 'Open in Injector' button"""
        if not self.main_window:
            return

        selected = self.process_table.selectedItems()
        if selected:
            row = selected[0].row()
            try:
                pid = int(self.process_table.item(row, 0).text())
                if self.current_device:
                    self.main_window.open_in_injector(self.current_device, pid)
                else:
                    QMessageBox.warning(self, "Error", "No device selected!")
            except ValueError:
                QMessageBox.critical(self, "Error", "Invalid PID format.")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Error: {e}")

    def refresh_processes(self):
        """Refresh process list using ps command"""
        selected_pid = None
        if self.process_table.selectedItems():
            row = self.process_table.currentRow()
            if row != -1:
                selected_pid = self.process_table.item(row, 0).text()

        self.process_table.setSortingEnabled(False)
        self.process_table.setRowCount(0)
        self.processes.clear()

        if not self.current_device:
            return

        try:
            self.status_label.setText("Refreshing processes...")
            
            # Get process list using ps -A
            adb_output = subprocess.check_output(
                ['adb', '-s', self.current_device, 'shell', 'ps', '-A'],
                text=True,
                stderr=subprocess.DEVNULL
            ).strip().split('\n')

            # Get debuggable packages
            debuggable_pkgs = self.get_debuggable_packages()

            # Parse process list
            for line in adb_output[1:]:  # Skip header
                parts = line.split()
                if len(parts) >= 9:
                    try:
                        user = parts[0]
                        pid = parts[1]
                        # Remove leading 'S', 'R', 'D', etc. status indicators
                        name = parts[8] if len(parts) > 8 else parts[-1]
                        
                        # Clean up process name (remove status prefix if present)
                        if name and len(name) > 1 and name[0] in 'SDTRZX':
                            name = name[1:]
                        
                        status = parts[7] if len(parts) > 7 else 'Unknown'
                        
                        # Determine package name (for apps)
                        package = name if '.' in name else 'N/A'
                        
                        # Check if debuggable
                        is_debuggable = package in debuggable_pkgs
                        
                        process_info = {
                            'pid': pid,
                            'name': name,
                            'package': package,
                            'user': user,
                            'status': status,
                            'debuggable': is_debuggable
                        }
                        
                        self.processes.append(process_info)
                        
                    except (IndexError, ValueError) as e:
                        continue

            self.update_table()
            self.status_label.setText(f"Loaded {len(self.processes)} processes")

        except subprocess.CalledProcessError as e:
            print(f"ADB error: {e}")
            self.status_label.setText("Error: ADB command failed")
        except Exception as e:
            print(f"Error refreshing processes: {e}")
            self.status_label.setText(f"Error: {str(e)}")

        # Restore selection
        if selected_pid:
            for row in range(self.process_table.rowCount()):
                if self.process_table.item(row, 0).text() == selected_pid:
                    self.process_table.selectRow(row)
                    break

        self.process_table.setSortingEnabled(True)

    def get_debuggable_packages(self):
        """Get list of debuggable packages"""
        try:
            output = subprocess.check_output(
                ['adb', '-s', self.current_device, 'shell', 'pm', 'list', 'packages', '-d'],
                text=True,
                stderr=subprocess.DEVNULL
            )
            packages = set()
            for line in output.strip().split('\n'):
                if line.startswith('package:'):
                    packages.add(line.replace('package:', ''))
            return packages
        except:
            return set()

    def update_table(self):
        """Populate table with process data"""
        for process in self.processes:
            row = self.process_table.rowCount()
            self.process_table.insertRow(row)

            items = [
                QTableWidgetItem(process['pid']),
                QTableWidgetItem(process['name']),
                QTableWidgetItem(process['package']),
                QTableWidgetItem(process['user']),
                QTableWidgetItem(process['status']),
                QTableWidgetItem(' Yes' if process['debuggable'] else ' No')
            ]

            # Center align PID, User, Status, Debuggable
            items[0].setTextAlignment(Qt.AlignCenter)
            items[3].setTextAlignment(Qt.AlignCenter)
            items[4].setTextAlignment(Qt.AlignCenter)
            items[5].setTextAlignment(Qt.AlignCenter)

            # Color code debuggable apps
            if process['debuggable']:
                items[5].setForeground(QColor('#43b581'))

            # Add items to row
            for col, item in enumerate(items):
                self.process_table.setItem(row, col, item)

        self.apply_filters()
        self.process_count.setText(f"{self.process_table.rowCount()} processes")

    def apply_filters(self):
        """Apply search and filter criteria"""
        search_text = self.search_input.text().lower()
        filter_type = self.filter_combo.currentText()
        use_regex = self.regex_check.isChecked()

        visible_count = 0
        for row in range(self.process_table.rowCount()):
            show_row = True
            name_item = self.process_table.item(row, 1)
            package_item = self.process_table.item(row, 2)
            debuggable_item = self.process_table.item(row, 5)

            if not name_item:
                continue

            name = name_item.text().lower()
            package = package_item.text().lower() if package_item else ''

            # Apply text filter
            if search_text:
                if use_regex:
                    try:
                        if not (re.search(search_text, name) or re.search(search_text, package)):
                            show_row = False
                    except re.error:
                        show_row = False
                elif search_text not in name and search_text not in package:
                    show_row = False

            # Apply type filter
            if filter_type == 'User Apps' and '.' not in package:
                show_row = False
            elif filter_type == 'System' and '.' in package:
                show_row = False
            elif filter_type == 'Debuggable' and not debuggable_item.text().startswith(''):
                show_row = False

            self.process_table.setRowHidden(row, not show_row)
            if show_row:
                visible_count += 1

        self.process_count.setText(f"{visible_count} processes (of {self.process_table.rowCount()})")

    def kill_selected_process(self):
        """Kill the selected process (using a non-blocking thread)"""
        selected = self.process_table.selectedItems()
        if not selected:
            return

        row = selected[0].row()
        pid = self.process_table.item(row, 0).text()
        name = self.process_table.item(row, 1).text()
        
        reply = QMessageBox.question(
            self, 
            "Kill Process",
            f"Are you sure you want to kill process:\n{name} (PID: {pid})?",
            QMessageBox.Yes | QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            # 1. Create QThread instance
            self.thread = QThread()
            # 2. Create Worker instance
            self.worker = KillProcessWorker(self.current_device, pid, name)
            
            # 3. Move worker to the thread
            self.worker.moveToThread(self.thread)
            
            # 4. Connect signals to slots
            self.thread.started.connect(self.worker.run)
            self.worker.finished.connect(self._handle_kill_success)
            self.worker.error.connect(self._handle_kill_error)
            
            # 5. Clean up when finished/error (crucial!)
            self.worker.finished.connect(self.thread.quit)
            self.worker.error.connect(self.thread.quit)
            self.worker.finished.connect(self.worker.deleteLater)
            self.worker.error.connect(self.worker.deleteLater)
            self.thread.finished.connect(self.thread.deleteLater)
            
            # 6. Start the thread
            self.thread.start()

    def _handle_kill_success(self, pid, name):
        """Executed on the main thread after successful kill."""
        self.status_label.setText(f"Killed process {pid}: {name}")
        self.refresh_processes()

    def _handle_kill_error(self, error_msg):
        """Executed on the main thread after kill failure."""
        QMessageBox.critical(self, "Error", f"Failed to kill process:\n{error_msg}")

    def dump_apk(self):
        """Dump APK of selected app"""
        selected = self.process_table.selectedItems()
        if selected:
            row = selected[0].row()
            package = self.process_table.item(row, 2).text()
            
            if package == 'N/A' or '.' not in package:
                QMessageBox.warning(self, "Error", "Not an app package")
                return
            
            try:
                # Get APK path
                path_output = subprocess.check_output(
                    ['adb', '-s', self.current_device, 'shell', 'pm', 'path', package],
                    text=True
                ).strip()
                
                if not path_output.startswith('package:'):
                    raise Exception("Could not find APK path")
                
                apk_path = path_output.replace('package:', '')
                
                # Pull APK
                output_path = f"{package}.apk"
                subprocess.run(
                    ['adb', '-s', self.current_device, 'pull', apk_path, output_path],
                    check=True
                )
                
                QMessageBox.information(self, "Success", f"APK dumped to: {output_path}")
                
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to dump APK: {e}")

    def show_process_details(self):
        """Show detailed info about selected process"""
        selected = self.process_table.selectedItems()
        if selected:
            row = selected[0].row()
            details = "\n".join([
                f"{self.process_table.horizontalHeaderItem(col).text()}: "
                f"{self.process_table.item(row, col).text()}"
                for col in range(self.process_table.columnCount())
            ])
            QMessageBox.information(self, "Process Details", details) 
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\process_panel.py --- 
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, 
                           QComboBox, QPushButton, QLabel)
import frida
import subprocess

class ProcessPanel(QWidget):
    def __init__(self):
        super().__init__()
        self.setup_ui()
        self.current_device_id = None
        
    def setup_ui(self):
        layout = QHBoxLayout(self)
        
        self.process_combo = QComboBox()
        self.refresh_button = QPushButton("Refresh Processes")
        
        layout.addWidget(QLabel("Select Process:"))
        layout.addWidget(self.process_combo)
        layout.addWidget(self.refresh_button)
        
        self.refresh_button.clicked.connect(self.refresh_processes)
        
    def update_device(self, device_id):
        self.current_device_id = device_id
        self.refresh_processes()
        
    def refresh_processes(self):
        if not self.current_device_id:
            return
            
        self.process_combo.clear()
        try:
            device = frida.get_device(self.current_device_id)
            if device.type == 'local':
                processes = device.enumerate_processes()
                for process in processes:
                    self.process_combo.addItem(
                        f"{process.name} (PID: {process.pid})", 
                        process.pid
                    )
            else:
                # For ADB devices
                output = subprocess.check_output(
                    ['adb', '-s', self.current_device_id, 'shell', 'ps'],
                    text=True
                ).strip().split('\n')
                
                for line in output[1:]:  # Skip header
                    parts = line.split()
                    if len(parts) >= 9:
                        pid = parts[1]
                        process_name = parts[-1]
                        self.process_combo.addItem(
                            f"{process_name} (PID: {pid})", 
                            pid
                        )
        except Exception as e:
            print(f"Error refreshing processes: {str(e)}")  
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\script_editor.py --- 
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QTextEdit

class ScriptEditorPanel(QWidget):
    def __init__(self):
        super().__init__()
        self.setup_ui()

    def setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        self.editor = QTextEdit()
        self.editor.setPlaceholderText("Enter your Frida script here...")
        self.editor.setFontFamily("Consolas")
        self.editor.setStyleSheet("font-size: 15pt;")

        # FIX: The self.editor.setPlainText call is now correctly inside a method.
        # This default script includes the functional REPL handler.
        self.editor.setPlainText('''Java.perform(function() {
    console.log("Script loaded! Frida REPL is ready (type in the Send field below).");
    
    // REPL Handler (Responds to messages sent from the host GUI)
    // The host sends: {'type': 'input', 'payload': 'YOUR_COMMAND'}
    recv('input', function(message) {
        if (message && typeof message.payload === 'string') {
            console.log("[REPL_HOST] Executing:", message.payload);
            try {
                // WARNING: Be careful when using eval in a real script.
                var result = eval(message.payload); 
                // Send back the result for display in the GUI
                send({type: "REPL_RESPONSE", message: "Result: " + result});
            } catch(e) {
                send({type: "REPL_ERROR", message: "Error in eval: " + e.message});
            }
        }
    });
});''')

        layout.addWidget(self.editor)

    def get_script(self):
        return self.editor.toPlainText()

    def set_script(self, script):
        self.editor.setPlainText(script)

    def clear(self):
        self.editor.clear()

    def get_editor_widget(self):
        return self.editor 
--- File: D:\ANDROID\FridaGUI\src\gui\widgets\__init__.py --- 
# Empty file to make the directory a Python package  
--- File: D:\ANDROID\FridaGUI\src\utils\themes.py --- 
from PyQt5.QtWidgets import QStyleFactory
from PyQt5.QtGui import QPalette, QColor
from PyQt5.QtCore import Qt

# Discord-inspired color scheme
DISCORD_COLORS = {
    'background': '#36393f',
    'secondary_bg': '#2f3136',
    'tertiary_bg': '#202225',
    'text': '#dcddde',
    'secondary_text': '#96989d',
    'accent': '#ec695c',
    'accent_hover': '#4752c4',
    'red': '#ed4245',
    'green': '#3ba55c'
}

STYLE_SHEET = """
QMainWindow, QWidget {
    background-color: """ + DISCORD_COLORS['background'] + """;
    color: """ + DISCORD_COLORS['text'] + """;
    font-family: 'Segoe UI', Arial, sans-serif;
}

QTabWidget::pane {
    border: none;
    background-color: """ + DISCORD_COLORS['background'] + """;
}

QTabWidget::tab-bar {
    alignment: left;
}

QTabBar::tab {
    background-color: """ + DISCORD_COLORS['tertiary_bg'] + """;
    color: """ + DISCORD_COLORS['secondary_text'] + """;
    padding: 8px 16px;
    border: none;
    min-width: 100px;
}

QTabBar::tab:selected {
    background-color: """ + DISCORD_COLORS['background'] + """;
    color: """ + DISCORD_COLORS['text'] + """;
}

QTabBar::tab:hover:!selected {
    background-color: """ + DISCORD_COLORS['secondary_bg'] + """;
}

QPushButton {
    background-color: """ + DISCORD_COLORS['accent'] + """;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    font-weight: bold;
}

QPushButton:hover {
    background-color: """ + DISCORD_COLORS['accent_hover'] + """;
}

QPushButton:pressed {
    background-color: """ + DISCORD_COLORS['accent'] + """;
}

QComboBox {
    background-color: """ + DISCORD_COLORS['tertiary_bg'] + """;
    border: none;
    border-radius: 4px;
    padding: 6px 12px;
    color: """ + DISCORD_COLORS['text'] + """;
    min-width: 150px;
}

QComboBox::drop-down {
    border: none;
    width: 20px;
}

QComboBox::down-arrow {
    image: none;
    border-left: 4px solid transparent;
    border-right: 4px solid transparent;
    border-top: 4px solid """ + DISCORD_COLORS['text'] + """;
    margin-right: 8px;
}

QTextEdit {
    background-color: """ + DISCORD_COLORS['tertiary_bg'] + """;
    border: none;
    border-radius: 4px;
    padding: 8px;
    color: """ + DISCORD_COLORS['text'] + """;
    font-family: 'Consolas', 'Courier New', monospace;
}

QLabel {
    color: """ + DISCORD_COLORS['text'] + """;
    font-weight: bold;
}

QScrollBar:vertical {
    border: none;
    background-color: #2f3136;
    width: 14px;
    margin: 0;
}

QScrollBar::handle:vertical {
    background-color: """ + DISCORD_COLORS['secondary_bg'] + """;
    min-height: 30px;
    border-radius: 7px;
}

QScrollBar::handle:vertical:hover {
    background-color: """ + DISCORD_COLORS['accent'] + """;
}

QScrollBar::up-arrow:vertical, QScrollBar::down-arrow:vertical {
    border: none;
    background: none;
}
/* By not specifying a background for add-page and sub-page, they inherit from QScrollBar:vertical, making the track visible */

QListWidget {
    background-color: """ + DISCORD_COLORS['tertiary_bg'] + """;
    border: none;
    border-radius: 4px;
    padding: 4px;
}

QListWidget::item {
    padding: 8px;
    border-radius: 4px;
}

QListWidget::item:hover {
    background-color: """ + DISCORD_COLORS['secondary_bg'] + """;
}

QListWidget::item:selected {
    background-color: """ + DISCORD_COLORS['accent'] + """;
    color: white;
}
"""

def set_application_style(app):
    app.setStyle(QStyleFactory.create("Fusion"))
    
    # Set the custom style sheet
    app.setStyleSheet(STYLE_SHEET)
    
    # Set up dark palette for system dialogs
    dark_palette = QPalette()
    dark_palette.setColor(QPalette.Window, QColor(DISCORD_COLORS['background']))
    dark_palette.setColor(QPalette.WindowText, QColor(DISCORD_COLORS['text']))
    dark_palette.setColor(QPalette.Base, QColor(DISCORD_COLORS['tertiary_bg']))
    dark_palette.setColor(QPalette.AlternateBase, QColor(DISCORD_COLORS['secondary_bg']))
    dark_palette.setColor(QPalette.ToolTipBase, QColor(DISCORD_COLORS['text']))
    dark_palette.setColor(QPalette.ToolTipText, QColor(DISCORD_COLORS['text']))
    dark_palette.setColor(QPalette.Text, QColor(DISCORD_COLORS['text']))
    dark_palette.setColor(QPalette.Button, QColor(DISCORD_COLORS['accent']))
    dark_palette.setColor(QPalette.ButtonText, Qt.white)
    dark_palette.setColor(QPalette.BrightText, Qt.red)
    dark_palette.setColor(QPalette.Link, QColor(DISCORD_COLORS['accent']))
    dark_palette.setColor(QPalette.Highlight, QColor(DISCORD_COLORS['accent']))
    dark_palette.setColor(QPalette.HighlightedText, Qt.white)
    
    app.setPalette(dark_palette) 
